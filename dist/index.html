<!DOCTYPE html>
<!-- @MineKhan version Alpha 0.7.1

	NOTE:
The "Save" button saves your world to your local browser. Nobody else can see it. However, if you're on a public or shared computer, that save may be deleted unexpectedly. So it's a good idea to keep a safe copy of your save string somewhere where it won't be deleted.

To share your save with other people, copy your world string into the "loadString" variable on line 189.

	Controls:

 * Right-click (or ctrl + left-click): place block
 * Left-click: Remove block
 * Middle-click: Pick block
 * Q: Sprint
 * Shift: Sneak
 * W: Walk forward
 * S: Walk backward
 * A: Walk left
 * D: Walk right
 * E: Open inventory
 * B: Toggle super Breaker
 * H: Toggle Hyper builder
 * Z: Zoom
 * L: Toggle Spectator mode
 * Enter: Toggle slab/stair mode
 * Arrow Keys: look around
 * P or Esc: pause/unpause
 * 1-9 navigate hotbar
 * Spacebar: jump
 * Double jump: toggle flight
 * Shift (flying): fly down
 * Space (flying): fly up
 * T: Open chat
 * ; (semicolon): Release the pointer without pausing (for screenshots)
 * Backspace or delete: drops the item you're holding right now

	Notes and accreditation:
 * This program (MineKhan) was made by Willard (me). The original is https://www.khanacademy.org/cs/mc/5647155001376768 (just adding this so that spin-offs have it)
 * Zushah helped me with some of the menus in the 0.6 update via GitHub. https://www.khanacademy.org/profile/zushah77
 * Element118 helped speed up the process of adding new textures significantly. https://www.khanacademy.org/profile/element118
 * Danielkshin made the current main menu background. https://www.khanacademy.org/profile/danielkshin

 * This program originated as a spin-off of ScusCraft by ScusX.
 * It's 99% different code at this point, but I still never would have made it this far without his code for reference.
 * ScusCraft can be found here: https://www.khanacademy.org/computer-programming/scuscraft-3d/5145400332058624
 * My original spin-off can be found here: https://www.khanacademy.org/computer-programming/high-performance-minecraft/5330738124357632
 * While porting the code from PJS to a webpage, I copied the PJS source code for a few of their helper functions from here: https://raw.githubusercontent.com/Khan/processing-js/master/processing.js
 * The textures are 100% copied from real Minecraft, and are the property of Mojang and Microsoft with whom I have no association.
 * The real Minecraft game can be bought and downloaded at https://www.minecraft.net/en-us/


 * Chunks are kept in memory until you restart. So don't explore too far or memory usage will grow until it crashes unrecoverably.


	To-Do:
 * A lot. Check out the GitHub repo if you'd like to collaborate on this. Must use Discord.
 * https://github.com/Willard21/MineKhan


	How it works:

The graphics in this project are done using WebGL, which is a web implementation of OpenGL ES 2.
It allows us to write shader programs that run right on the GPU, which means it can run as fast as any C++ game.
The infamous P3D mode in Processing.js uses WebGL behind the scenes, but it does it so inefficiently that it might as well not even being using the GPU.

To properly utilize WebGL like this program does, you need to make efficient use of Vertext Buffer Objects (VBOs).
A VBO is an array that contains a whole bunch of vertices. Since WebGL can only render triangles and lines, these vertices are stored in multiples of 3.
A vertex doesn't only include its world coordinates, though. It also includes its texture coordinates, and any other data you want the shaders to manipulate.
In my case, every vertex has an X, Y, Z, textureX, textureY, and shadowIntensity. So 6 values for every block vertex in the world.

A program can only draw 1 VBO per draw call. Since the texture data is attached to the vertex data, you can't switch textures between vertices.
That means you either have to make seperate draw calls for each texture, or only use 1 texture. I do the latter.
I make a single 256x256 pixel texture, and store each of the 16x16 block textures in a section of that big texture, and store the coordinates to it. This is informally called a "texture atlas".
Then when I'm preparing my VBO, I send the texture coordinates along with the block coordinates so the shader knows how to map the 256x256 pixel texture onto the 16x16 pixel block face.

I do this once for each chunk in the world, and store those VBOs so I can draw them every frame. If a block is edited in a chunk, then that VBO is replaced.
Drawing a chunk after the VBO has been created is as simple as binding the buffer and calling "gl.drawArrays" once per chunk. The GPU takes care of the rest.

I also use what's called Vertex Array Objects (VAOs) to re-use shared vertices. Since the GPU expects triangles, and I want to draw squares, I need to draw 2 triangles (6 vertices) per square.
That means 2 of them are being re-used. The VAO lets me tell the GPU to use the cached vertex data instead of looking for a new one, which offers a small inprovement to GPU performance.
This isn't entirely necessary, but it's considered best practice. Some OpenGL ES implementations require it, but WebGL 1 does not. I think WebGL 2 does, but that's not as well supported.
-->

<html lang="en-us">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="description" content="Play creative mode Minecraft right from your browser!">
		<meta name="keywords" content="Khan Academy, Programs, Search">
		<meta property="og:title" content="MineKhan"/>
		<meta property="og:description" content="Play creative mode Minecraft right from your browser!"/>
		<meta property="og:image" content="https://www.khanacademy.org/computer-programming/minekhan/5647155001376768/5308848032661504.png"/>
		<title>MineKhan</title>
		<!-- <link id="vtfont" href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet"> -->
		<link rel="preload" href="https://willard.fun/fonts/VT323.woff2" as="font" type="font/woff2" crossorigin>
		<link rel="shortcut icon" type="image/ico" href="https://willard.fun/assets/minekhan.ico">
	</head>
	<body>
		<div id="background-text">
			<h1>MineKhan</h1>
			<p>Play MineKhan online! This game is a free Minecraft clone developed on <a href="https://www.khanacademy.org/computer-programming/minekhan/5647155001376768">Khan Academy</a>, and later moved to my own website so that I could take advantage of multiplayer servers. The front-end code is completely open source and maintained on <a href="https://github.com/Willard21/MineKhan">GitHub</a>, where contributions are welcome.</p>
		</div>
	<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
	<input type="text" id="savebox" class="hidden" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;">
	<input type="text" id="boxcentertop" class="hidden" spellcheck="false">
	<div id="quota" class="hidden"></div>
	<div id="onhover" class="hidden"></div>
	<div id="chat" class="hidden"></div>
	<input id="chatbar" class="hidden" list="commands">
	<datalist id="commands">
		<option>/ban</option>
 		<option>/online</option>
	</datalist>
	<p id="savedirections" class="hidden" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
		To share your world on KA, copy/paste the saveString<br>
		from this box into the code on line 190.<br>
		var loadString = "Your Code Here";<br>
		Then save the program as a Spin-off.
	</p>
	<div class="world-select hidden" id="worlds"></div>
	<p id="message" class="hidden" style="position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"></p>
	<script>
		// Code edits will erase the world.
		// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
		window.loadString = ""
	</script>
	<script>/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("attribute vec3  aVertex;\r\nattribute vec2  aTexture;\r\nattribute float aShadow;\r\nattribute float aSkylight;\r\nattribute float aBlocklight;\r\nvarying vec2  vTexture;\r\nvarying float vShadow;\r\nvarying float vFog;\r\nuniform mat4 uView;\r\nuniform float uDist;\r\nuniform vec3 uPos;\r\nuniform float uTime;\r\n\r\nvoid main() {\r\n    vTexture = aTexture;\r\n    // If you are going to change this final lightlevel calculation\r\n    // you have to change line 4487 as well since it calculates lightlevel of entity based on this\r\n    vShadow = aShadow * min(max(aSkylight * uTime, aBlocklight) * 0.9 + 0.1, 1.0);\r\n    gl_Position = uView * vec4(aVertex, 1.0);\r\n\r\n    float range = max(uDist / 5.0, 8.0);\r\n    vFog = clamp((length(uPos.xz - aVertex.xz) - uDist + range) / range, 0.0, 1.0);\r\n}");

/***/ }),
/* 2 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n#else\r\n    precision mediump float;\r\n#endif\r\n\r\nuniform sampler2D uSampler;\r\nuniform float uTime;\r\nuniform bool uTrans;\r\nuniform vec3 uSky; // vec3(0.33, 0.54, 0.72)\r\nvarying float vShadow;\r\nvarying vec2 vTexture;\r\nvarying float vFog;\r\n\r\nvoid main(){\r\n    vec4 color = texture2D(uSampler, vTexture);\r\n    gl_FragColor = vec4(mix(color.rgb * vShadow, uSky * uTime, vFog), color.a);\r\n    if (!uTrans && gl_FragColor.a != 1.0) discard;\r\n    else if (uTrans && gl_FragColor.a == 1.0) discard;\r\n}");

/***/ }),
/* 3 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("attribute vec2 aVertex;\r\nattribute vec2 aTexture;\r\nattribute float aShadow;\r\nvarying vec2 vTexture;\r\nvarying float vShadow;\r\n\r\nvoid main() {\r\n    vTexture = aTexture;\r\n    vShadow = aShadow;\r\n    gl_Position = vec4(aVertex, 0.5, 1.0);\r\n}");

/***/ }),
/* 4 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n#else\r\n    precision mediump float;\r\n#endif\r\n\r\nuniform sampler2D uSampler;\r\nvarying vec2 vTexture;\r\nvarying float vShadow;\r\n\r\nvoid main() {\r\n    vec4 color = texture2D(uSampler, vTexture);\r\n    gl_FragColor = vec4(color.rgb * vShadow, color.a);\r\n    if (gl_FragColor.a == 0.0) discard;\r\n}");

/***/ }),
/* 5 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("attribute vec3  aVertex;\r\nattribute vec2  aTexture;\r\nvarying vec2  vTexture;\r\nuniform mat4 uView;\r\n\r\nvoid main() {\r\n    vTexture = aTexture;\r\n    gl_Position = uView * vec4(aVertex, 1.0);\r\n}");

/***/ }),
/* 6 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("#ifdef GL_FRAGMENT_PRECISION_HIGH\r\n    precision highp float;\r\n#else\r\n    precision mediump float;\r\n#endif\r\n\r\nuniform sampler2D uSampler;\r\nuniform float uLightLevel;\r\nvarying vec2 vTexture;\r\n\r\nvoid main(){\r\n    vec4 color = texture2D(uSampler, vTexture);\r\n    gl_FragColor = vec4(color.rgb * uLightLevel, color.a);\r\n}");

/***/ }),
/* 7 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ("function Worker() {\n\tconst { abs, floor } = Math\n\n\tfunction openSimplexNoise(clientSeed) {\n\t\tconst toNums = function(s) {\n\t\t\treturn s.split(\",\").map(function(s) {\n\t\t\t\treturn new Uint8Array(s.split(\"\").map(function(v) {\n\t\t\t\t\treturn Number(v)\n\t\t\t\t}))\n\t\t\t})\n\t\t}\n\t\tconst decode = function(m, r, s) {\n\t\t\treturn new Int8Array(s.split(\"\").map(function(v) {\n\t\t\t\treturn parseInt(v, r) + m\n\t\t\t}))\n\t\t}\n\t\tconst toNumsB32 = function(s) {\n\t\t\treturn s.split(\",\").map(function(s) {\n\t\t\t\treturn parseInt(s, 32)\n\t\t\t})\n\t\t}\n\t\tconst NORM_3D = 1.0 / 206.0\n\t\tconst SQUISH_3D = 1 / 3\n\t\tconst STRETCH_3D = -1 / 6\n\t\tvar base3D = toNums(\"0000110010101001,2110210120113111,110010101001211021012011\")\n\t\tconst gradients3D = decode(-11, 23, \"0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70\")\n\t\tvar lookupPairs3D = function() {\n\t\t\treturn new Uint16Array(toNumsB32(\"0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6\"))\n\t\t}\n\t\tvar p3D = decode(-1, 5, \"112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131\")\n\t\tconst setOf = function(count) {\n\t\t\tvar a = [], i = 0;\n\t\t\twhile (i < count) {\n\t\t\t\ta.push(i++)\n\t\t\t}\n\t\t\treturn a\n\t\t}\n\t\tconst doFor = function(count, cb) {\n\t\t\tvar i = 0;\n\t\t\twhile (i < count && cb(i++) !== true);\n\t\t}\n\n\t\tfunction shuffleSeed(seed,count){\n\t\t\tseed = seed * 1664525 + 1013904223 | 0\n\t\t\tcount -= 1\n\t\t\treturn count > 0 ? shuffleSeed(seed, count) : seed\n\t\t}\n\t\tconst types = {\n\t\t\t_3D : {\n\t\t\t\tbase : base3D,\n\t\t\t\tsquish : SQUISH_3D,\n\t\t\t\tdimensions : 3,\n\t\t\t\tpD : p3D,\n\t\t\t\tlookup : lookupPairs3D,\n\t\t\t}\n\t\t}\n\n\t\tfunction createContribution(type, baseSet, index) {\n\t\t\tvar i = 0\n\t\t\tconst multiplier = baseSet[index ++]\n\t\t\tconst c = { next : undefined }\n\t\t\twhile(i < type.dimensions) {\n\t\t\t\tconst axis = \"xyzw\"[i]\n\t\t\t\tc[axis + \"sb\"] = baseSet[index + i]\n\t\t\t\tc[\"d\" + axis] = - baseSet[index + i++] - multiplier * type.squish\n\t\t\t}\n\t\t\treturn c\n\t\t}\n\n\t\tfunction createLookupPairs(lookupArray, contributions){\n\t\t\tvar i\n\t\t\tconst a = lookupArray()\n\t\t\tconst res = new Map()\n\t\t\tfor (i = 0; i < a.length; i += 2) {\n\t\t\t\tres.set(a[i], contributions[a[i + 1]]);\n\t\t\t}\n\t\t\treturn res\n\t\t}\n\n\t\tfunction createContributionArray(type) {\n\t\t\tconst conts = []\n\t\t\tconst d = type.dimensions\n\t\t\tconst baseStep = d * d\n\t\t\tvar k, i = 0\n\t\t\twhile (i < type.pD.length) {\n\t\t\t\tconst baseSet = type.base[type.pD[i]]\n\t\t\t\tlet previous, current\n\t\t\t\tk = 0\n\t\t\t\tdo {\n\t\t\t\t\tcurrent = createContribution(type, baseSet, k)\n\t\t\t\t\tif (!previous) {\n\t\t\t\t\t\tconts[i / baseStep] = current;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tprevious.next = current;\n\t\t\t\t\t}\n\t\t\t\t\tprevious = current\n\t\t\t\t\tk += d + 1\n\t\t\t\t} while(k < baseSet.length)\n\n\t\t\t\tcurrent.next = createContribution(type, type.pD, i + 1)\n\t\t\t\tif (d >= 3) {\n\t\t\t\t\tcurrent.next.next = createContribution(type, type.pD, i + d + 2)\n\t\t\t\t}\n\t\t\t\tif (d === 4) {\n\t\t\t\t\tcurrent.next.next.next = createContribution(type, type.pD, i + 11)\n\t\t\t\t}\n\t\t\t\ti += baseStep\n\t\t\t}\n\t\t\tconst result = [conts, createLookupPairs(type.lookup, conts)]\n\t\t\ttype.base = undefined\n\t\t\ttype.lookup = undefined\n\t\t\treturn result\n\t\t}\n\n\t\tlet temp = createContributionArray(types._3D)\n\t\tconst lookup3D = temp[1]\n\t\tconst perm = new Uint8Array(256)\n\t\tconst perm3D = new Uint8Array(256)\n\t\tconst source = new Uint8Array(setOf(256))\n\t\tvar seed = shuffleSeed(clientSeed, 3)\n\t\tdoFor(256, function(i) {\n\t\t\ti = 255 - i\n\t\t\tseed = shuffleSeed(seed, 1)\n\t\t\tvar r = (seed + 31) % (i + 1)\n\t\t\tr += r < 0 ? i + 1 : 0\n\t\t\tperm[i] = source[r]\n\t\t\tperm3D[i] = perm[i] % 24 * 3\n\t\t\tsource[r] = source[i]\n\t\t})\n\t\tbase3D = undefined\n\t\tlookupPairs3D = undefined\n\t\tp3D = undefined\n\n\t\treturn function(x, y, z) {\n\t\t\tconst pD = perm3D\n\t\t\tconst p = perm\n\t\t\tconst g = gradients3D\n\t\t\tconst stretchOffset = (x + y + z) * STRETCH_3D\n\t\t\tconst xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset\n\t\t\tconst xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)\n\t\t\tconst squishOffset\t= (xsb + ysb + zsb) * SQUISH_3D\n\t\t\tconst dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)\n\t\t\tconst xins = xs - xsb, yins = ys - ysb, zins = zs - zsb\n\t\t\tconst inSum = xins + yins + zins\n\t\t\tvar c = lookup3D.get(\n\t\t\t\tyins - zins + 1\n\t\t\t\t\t| xins - yins + 1 << 1\n\t\t\t\t\t| xins - zins + 1 << 2\n\t\t\t\t\t| inSum << 3\n\t\t\t\t\t| inSum + zins << 5\n\t\t\t\t\t| inSum + yins << 7\n\t\t\t\t\t| inSum + xins << 9\n\t\t\t)\n\t\t\tvar i, value = 0\n\t\t\twhile (c !== undefined) {\n\t\t\t\tconst dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz\n\t\t\t\tlet attn = 2 - dx * dx - dy * dy - dz * dz\n\t\t\t\tif (attn > 0) {\n\t\t\t\t\ti = pD[(p[xsb + c.xsb & 0xFF] + (ysb + c.ysb) & 0xFF) + (zsb + c.zsb) & 0xFF]\n\t\t\t\t\tattn *= attn\n\t\t\t\t\tvalue += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)\n\t\t\t\t}\n\t\t\t\tc = c.next\n\t\t\t}\n\t\t\treturn value * NORM_3D + 0.5\n\t\t}\n\t}\n\n\tlet noise\n\tconst smooth = 0.02\n\tconst caveSize = 0.0055\n\tfunction isCave(x, y, z) {\n\t\t// Generate a 3D rigid multifractal noise shell.\n\t\t// Then generate another one with different coordinates.\n\t\t// Overlay them on top of each other, and the overlapping parts should form a cave-like structure.\n\t\t// This is extremely slow, and requires generating 2 noise values for every single block in the world.\n\t\t// TODO: replace with a crawler system of some sort, that will never rely on a head position in un-generated chunks.\n\n\t\tlet cave1 = abs(0.5 - noise(x * smooth, y * smooth, z * smooth)) < caveSize\n\t\tlet cave2 = abs(0.5 - noise(y * smooth, z * smooth, x * smooth)) < caveSize\n\t\treturn cave1 && cave2\n\t}\n\n\tconst subChunk = new Int8Array(16 * 16 * 16)\n\tself.onmessage = function(e) {\n\n\t\tif (e.data && e.data.seed) {\n\t\t\tnoise = openSimplexNoise(e.data.seed)\n\t\t\tself.postMessage(e.data)\n\t\t}\n\t\tif (e.data && e.data.caves) {\n\t\t\tconst { x, y, z } = e.data\n\t\t\tfor (let X = 0; X < 16; X++) {\n\t\t\t\tfor (let Y = 0; Y < 16; Y++) {\n\t\t\t\t\tfor (let Z = 0; Z < 16; Z++) {\n\t\t\t\t\t\tsubChunk[X * 256 + Y * 16 + Z] = isCave(X + x, Y + y, Z + z) | 0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tself.postMessage({\n\t\t\t\tjobId: e.data.jobId,\n\t\t\t\tcaves: subChunk,\n\t\t\t})\n\t\t}\n\t}\n}\n\nWorker()");

/***/ }),
/* 8 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9);
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10);

            

var options = {};

options.insert = "head";
options.singleton = false;

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"], options);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_1__["default"].locals || {});

/***/ }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isOldIE = function isOldIE() {
  var memo;
  return function memorize() {
    if (typeof memo === 'undefined') {
      // Test for IE <= 9 as proposed by Browserhacks
      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
      // Tests for existence of standard globals is to allow style-loader
      // to operate correctly into non-standard environments
      // @see https://github.com/webpack-contrib/style-loader/issues/177
      memo = Boolean(window && document && document.all && !window.atob);
    }

    return memo;
  };
}();

var getTarget = function getTarget() {
  var memo = {};
  return function memorize(target) {
    if (typeof memo[target] === 'undefined') {
      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
        try {
          // This will throw an exception if access to iframe is blocked
          // due to cross-origin restrictions
          styleTarget = styleTarget.contentDocument.head;
        } catch (e) {
          // istanbul ignore next
          styleTarget = null;
        }
      }

      memo[target] = styleTarget;
    }

    return memo[target];
  };
}();

var stylesInDom = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDom.length; i++) {
    if (stylesInDom[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var index = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3]
    };

    if (index !== -1) {
      stylesInDom[index].references++;
      stylesInDom[index].updater(obj);
    } else {
      stylesInDom.push({
        identifier: identifier,
        updater: addStyle(obj, options),
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function insertStyleElement(options) {
  var style = document.createElement('style');
  var attributes = options.attributes || {};

  if (typeof attributes.nonce === 'undefined') {
    var nonce =  true ? __webpack_require__.nc : 0;

    if (nonce) {
      attributes.nonce = nonce;
    }
  }

  Object.keys(attributes).forEach(function (key) {
    style.setAttribute(key, attributes[key]);
  });

  if (typeof options.insert === 'function') {
    options.insert(style);
  } else {
    var target = getTarget(options.insert || 'head');

    if (!target) {
      throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
    }

    target.appendChild(style);
  }

  return style;
}

function removeStyleElement(style) {
  // istanbul ignore if
  if (style.parentNode === null) {
    return false;
  }

  style.parentNode.removeChild(style);
}
/* istanbul ignore next  */


var replaceText = function replaceText() {
  var textStore = [];
  return function replace(index, replacement) {
    textStore[index] = replacement;
    return textStore.filter(Boolean).join('\n');
  };
}();

function applyToSingletonTag(style, index, remove, obj) {
  var css = remove ? '' : obj.media ? "@media ".concat(obj.media, " {").concat(obj.css, "}") : obj.css; // For old IE

  /* istanbul ignore if  */

  if (style.styleSheet) {
    style.styleSheet.cssText = replaceText(index, css);
  } else {
    var cssNode = document.createTextNode(css);
    var childNodes = style.childNodes;

    if (childNodes[index]) {
      style.removeChild(childNodes[index]);
    }

    if (childNodes.length) {
      style.insertBefore(cssNode, childNodes[index]);
    } else {
      style.appendChild(cssNode);
    }
  }
}

function applyToTag(style, options, obj) {
  var css = obj.css;
  var media = obj.media;
  var sourceMap = obj.sourceMap;

  if (media) {
    style.setAttribute('media', media);
  } else {
    style.removeAttribute('media');
  }

  if (sourceMap && typeof btoa !== 'undefined') {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  if (style.styleSheet) {
    style.styleSheet.cssText = css;
  } else {
    while (style.firstChild) {
      style.removeChild(style.firstChild);
    }

    style.appendChild(document.createTextNode(css));
  }
}

var singleton = null;
var singletonCounter = 0;

function addStyle(obj, options) {
  var style;
  var update;
  var remove;

  if (options.singleton) {
    var styleIndex = singletonCounter++;
    style = singleton || (singleton = insertStyleElement(options));
    update = applyToSingletonTag.bind(null, style, styleIndex, false);
    remove = applyToSingletonTag.bind(null, style, styleIndex, true);
  } else {
    style = insertStyleElement(options);
    update = applyToTag.bind(null, style, options);

    remove = function remove() {
      removeStyleElement(style);
    };
  }

  update(obj);
  return function updateStyle(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {
        return;
      }

      update(obj = newObj);
    } else {
      remove();
    }
  };
}

module.exports = function (list, options) {
  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
  // tags it will allow on a page

  if (!options.singleton && typeof options.singleton !== 'boolean') {
    options.singleton = isOldIE();
  }

  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    if (Object.prototype.toString.call(newList) !== '[object Array]') {
      return;
    }

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDom[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDom[_index].references === 0) {
        stylesInDom[_index].updater();

        stylesInDom.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),
/* 10 */
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(11);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);
// Imports

var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});
// Module
___CSS_LOADER_EXPORT___.push([module.id, "body {\r\n\toverflow: hidden; /* Hide scrollbars */\r\n    background-color: black;\r\n}\r\n.world-select {\r\n\twidth: 99vw;\r\n\tmin-width: 300px;\r\n\theight: calc(100vh - 220px);\r\n\tposition: absolute;\r\n\tbottom: 120px;\r\n\toverflow-y: auto;\r\n\tbackground-color: RGBA(0, 0, 0, 0.6);\r\n\tjustify-content: center;\r\n\tmargin: 0 auto;\r\n}\r\n.world {\r\n\twidth: 250px;\r\n\theight: auto;\r\n\tborder: 1px solid black;\r\n\tfont-size: 18px;\r\n\tfont-family: 'Courier New', Courier, monospace;\r\n\tcolor: rgb(180, 180, 180);\r\n\tmargin: 0 auto;\r\n\tmargin-top: 15px;\r\n\tpadding: 5px;\r\n\tcursor: pointer;\r\n}\r\nstrong {\r\n\tcolor: white;\r\n}\r\n.selected {\r\n\tborder: 3px solid white;\r\n\tpadding: 3px;\r\n}\r\ninput[type=text] {\r\n\tbackground-color: black;\r\n\tcaret-color: white;\r\n\tborder: 2px solid gray;\r\n\tcolor: white;\r\n\tfont-size: 24px;\r\n\tpadding-left: 12px;\r\n}\r\ninput[type=text]:focus {\r\n\tborder: 2px solid lightgray;\r\n}\r\n#boxcentertop {\r\n\tz-index: 1;\r\n\twidth: 80vw;\r\n\tmax-width: 400px;\r\n\theight: 50px;\r\n\tposition: relative;\r\n\ttop: 30px;\r\n\tdisplay: block;\r\n\tmargin: 0 auto;\r\n}\r\n.hidden {\r\n\tdisplay: none !important;\r\n}\r\n#onhover {\r\n\tbackground-color: rgba(0, 0, 0, 0.9);\r\n\tcolor: rgb(200, 200, 200);\r\n\tfont-family: 'Courier New', Courier, monospace;\r\n\tword-wrap: normal;\r\n\twidth: auto;\r\n\tmax-width: 400px;\r\n\tposition: absolute;\r\n\tz-index: 1;\r\n\tpadding: 10px;\r\n\tcursor: default;\r\n}\r\n#quota {\r\n\tdisplay: block;\r\n\tposition: absolute;\r\n\twidth: 99vw;\r\n\tmargin: 0 auto;\r\n\tbottom: 110px;\r\n\tz-index: 1;\r\n\tbackground-color: RGBA(0, 0, 0, 0.6);\r\n\tjustify-content: center;\r\n\ttext-align: center;\r\n\tcolor: white;\r\n}\r\n#chat {\r\n    position: absolute;\r\n    left: 0px;\r\n    top: 100px;\r\n    height: calc(100vh - 200px);\r\n    overflow-y: auto;\r\n    overflow-x: hidden;\r\n\tpadding-right: 20px;\r\n    width: 40vw;\r\n    min-width: 600px;\r\n    background-color: RGBA(0, 0, 0, 0.5);\r\n    color: white;\r\n}\r\n#chatbar {\r\n    position: absolute;\r\n    left: 30px;\r\n    bottom: 0px;\r\n    height: 20;\r\n    width: calc(100vw - 60px);\r\n    background-color: RGBA(0, 0, 0, 0.5);\r\n    color: white;\r\n}\r\n.message {\r\n    width: 100%;\r\n    background-color: transparent;\r\n    padding: 10px;\r\n    word-wrap: break-word;\r\n}\r\n@font-face {\r\n\tfont-family: 'VT323';\r\n\tfont-style: normal;\r\n\tfont-weight: 400;\r\n\tfont-display: swap;\r\n\tsrc: url(https://willard.fun/fonts/VT323.woff2) format('woff2');\r\n\tunicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;\r\n}\r\n#background-text {\r\n\tposition: absolute;\r\n\tleft: 0;\r\n\ttop: 0;\r\n    width: 100vw;\r\n    height: 100vh;\r\n}", ""]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),
/* 11 */
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
// eslint-disable-next-line func-names
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = cssWithMappingToString(item);

      if (item[2]) {
        return "@media ".concat(item[2], " {").concat(content, "}");
      }

      return content;
    }).join("");
  }; // import a list of modules into the list
  // eslint-disable-next-line func-names


  list.i = function (modules, mediaQuery, dedupe) {
    if (typeof modules === "string") {
      // eslint-disable-next-line no-param-reassign
      modules = [[null, modules, ""]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var i = 0; i < this.length; i++) {
        // eslint-disable-next-line prefer-destructuring
        var id = this[i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i = 0; _i < modules.length; _i++) {
      var item = [].concat(modules[_i]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        // eslint-disable-next-line no-continue
        continue;
      }

      if (mediaQuery) {
        if (!item[2]) {
          item[2] = mediaQuery;
        } else {
          item[2] = "".concat(mediaQuery, " and ").concat(item[2]);
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hash": () => (/* binding */ hash),
/* harmony export */   "noiseProfile": () => (/* binding */ noiseProfile),
/* harmony export */   "openSimplexNoise": () => (/* binding */ openSimplexNoise),
/* harmony export */   "random": () => (/* binding */ random),
/* harmony export */   "randomSeed": () => (/* binding */ randomSeed),
/* harmony export */   "seedHash": () => (/* binding */ seedHash)
/* harmony export */ });
const { imul, floor } = Math;

// implementation of xxHash
const {
	seedHash,
	hash
} = (() => {
	// closure around mutable `seed`; updated via calls to `seedHash`

	let seed = Math.random() * 2100000000 | 0;

	const PRIME32_2 = 1883677709;
	const PRIME32_3 = 2034071983;
	const PRIME32_4 = 668265263;
	const PRIME32_5 = 374761393;

	const seedHash = s => {
		seed = s | 0;
	}

	const hash = (x, y) => {
		let h32 = 0;

		h32 = seed + PRIME32_5 | 0;
		h32 += 8;

		h32 += imul(x, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
		h32 += imul(y, PRIME32_3);
		h32 = imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

		h32 ^= h32 >> 15;
		h32 *= PRIME32_2;
		h32 ^= h32 >> 13;
		h32 *= PRIME32_3;
		h32 ^= h32 >> 16;

		return h32 / 2147483647;
	};

	return {
		seedHash,
		hash
	};
})();

class Marsaglia {
	// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c

	nextInt() {
		const { z, w } = this;

		this.z = 36969 * (z & 65535) + (z >>> 16) & 0xFFFFFFFF;
		this.w = 18000 * (w & 65535) + (w >>> 16) & 0xFFFFFFFF;

		return ((this.z & 0xFFFF) << 16 | this.w & 0xFFFF) & 0xFFFFFFFF;
	}

	nextDouble() {
		const i = this.nextInt() / 4294967296;

		const isNegative = i < 0 | 0; // cast to 1 or 0

		return isNegative + i;
	}

	constructor(i1, i2) { // better param names
		this.z = i1 | 0 || 362436069;
		this.w = i2 || hash(521288629, this.z) * 2147483647 | 0;
	}
}

// The noise and random functions are copied from the processing.js source code

const {
	randomSeed,
	random
} = (() => {
	// closure around mut `currentRandom`

	let currentRandom = null;

	const randomSeed = seed => {
		currentRandom = new Marsaglia(seed);
	};

	const random = (min, max) => {
		if (!max) {
			if (min) {
				max = min;
				min = 0;
			}
			else {
				min = 0;
				max = 1;
			}
		}

		return currentRandom.nextDouble() * (max - min) + min;
	};

	return {
		randomSeed,
		random
	};
})();

class PerlinNoise {
	// http://www.noisemachine.com/talk1/17b.html
	// http://mrl.nyu.edu/~perlin/noise/

	static grad3d(i, x, y, z) {
		const h = i & 15; // convert into 12 gradient directions

		const u = h < 8
			? x
			: y;

		const v = h < 4
			? y
			: h === 12 || h === 14
				? x
				: z;

		return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v)
	}

	static grad2d(i, x, y) {
		const v = (i & 1) === 0
			? x
			: y;

		return (i & 2) === 0
			? -v
			: v;
	}

	static grad1d(i, x) {
		return (i & 1) === 0
			? -x
			: x;
	}

	static lerp(t, a, b) {
		return a + t * (b - a);
	}

	// end of statics

	// prototype functions:
	noise3d(x, y, z) {
		const X = floor(x) & 0xff;
		const Y = floor(y) & 0xff;
		const Z = floor(z) & 0xff;

		x -= floor(x);
		y -= floor(y);
		z -= floor(z);

		const fx = (3 - 2 * x) * x * x;
		const fy = (3 - 2 * y) * y * y;
		const fz = (3 - 2 * z) * z * z;

		const { perm } = this;

		const p0 = perm[X] + Y;
		const p00 = perm[p0] + Z;
		const p01 = perm[p0 + 1] + Z;
		const p1 = perm[X + 1] + Y;
		const p10 = perm[p1] + Z;
		const p11 = perm[p1 + 1] + Z;

		const { lerp, grad3d } = PerlinNoise;

		return lerp(
			fz,
			lerp(
				fy,
				lerp(
					fx,
					grad3d(perm[p00], x, y, z),
					grad3d(perm[p10], x - 1, y, z)
				),
				lerp(
					fx,
					grad3d(perm[p01], x, y - 1, z),
					grad3d(perm[p11],x - 1, y - 1, z)
				)
			),
			lerp(
				fy,
				lerp(
					fx,
					grad3d(perm[p00 + 1], x, y, z - 1),
					grad3d(perm[p10 + 1], x - 1, y, z - 1)
				),
				lerp(
					fx,
					grad3d(perm[p01 + 1], x, y - 1, z - 1),
					grad3d(perm[p11 + 1], x - 1, y - 1, z - 1)
				)
			)
		);
	}

	noise2d(x, y) {
		const X = floor(x) & 0xff;
		const Y = floor(y) & 0xff;

		x -= floor(x);
		y -= floor(y);

		const { perm } = this;
		const fx = (3 - 2 * x) * x * x;
		const fy = (3 - 2 * y) * y * y;
		const p0 = perm[X] + Y;
		const p1 = perm[X + 1] + Y;

		const { lerp, grad2d } = PerlinNoise;

		return lerp(
			fy,
			lerp(
				fx,
				grad2d(
					perm[p0],
					x,
					y
				),
				grad2d(
					perm[p1],
					x - 1,
					y
				)
			),
			lerp(
				fx,
				grad2d(
					perm[p0 + 1],
					x,
					y - 1
				),
				grad2d(
					perm[p1 + 1],
					x - 1,
					y - 1
				)
			)
		);
	}

	constructor(seed) {
		if (seed === undefined) {
			throw new TypeError("A value for `seed` parameter was not provided to `PerlinNoise`");
		}
		// console.log("New noise generator with seed", seed)

		const rnd = new Marsaglia(seed)

		// generate permutation
		const perm = new Uint8Array(0x200)
		this.perm = perm

		// fill 0x0..0x100
		for (let i = 0; i < 0x100; ++i) {
			perm[i] = i
		}

		for (let i = 0; i < 0x100; ++i) {
			const j = rnd.nextInt() & 0xFF
			const t = perm[j]
			perm[j] = perm[i]
			perm[i] = t
		}

		// copy to avoid taking mod in perm[0]
		// copies from first half of array, into the second half
		perm.copyWithin(0x100, 0x0, 0x100)
	}
}

const noiseProfile = {
	generator: undefined,
	octaves: 4,
	fallout: 0.5,
	seed: undefined,
	noiseSeed(seed) {
		this.seed = seed;
		this.generator = new PerlinNoise(noiseProfile.seed);
	},
	noise(x, y, z) {
		const { generator, octaves, fallout } = this;

		let effect = 1,
			sum = 0;

		for (let i = 0; i < octaves; ++i) {
			effect *= fallout;

			const k = 1 << i;

			let temp;
			switch (arguments.length) {
				case 1: {
					temp = generator.noise1d(k * x);
					break;
				} case 2: {
					temp = generator.noise2d(k * x, k * y);
					break;
				} case 3: {
					temp = generator.noise3d(k * x, k * y, k * z);
					break;
				}
			}

			sum += effect * (1 + temp) / 2;
		}

		return sum;
	}
};

// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
function openSimplexNoise(clientSeed) {
	const toNums = function(s) {
		return s.split(",").map(function(s) {
			return new Uint8Array(s.split("").map(function(v) {
				return Number(v)
			}))
		})
	}
	const decode = function(m, r, s) {
		return new Int8Array(s.split("").map(function(v) {
			return parseInt(v, r) + m
		}))
	}
	const toNumsB32 = function(s) {
		return s.split(",").map(function(s) {
			return parseInt(s, 32)
		})
	}
	const NORM_3D = 1.0 / 206.0
	const SQUISH_3D = 1 / 3
	const STRETCH_3D = -1 / 6
	var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011")
	const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70")
	var lookupPairs3D = function() {
		return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6"))
	}
	var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131")
	const setOf = function(count) {
		var a = [], i = 0;
		while (i < count) {
			a.push(i++)
		}
		return a
	}
	const doFor = function(count, cb) {
		var i = 0;
		while (i < count && cb(i++) !== true);
	}

	function shuffleSeed(seed,count){
		seed = seed * 1664525 + 1013904223 | 0
		count -= 1
		return count > 0 ? shuffleSeed(seed, count) : seed
	}
	const types = {
		_3D : {
			base : base3D,
			squish : SQUISH_3D,
			dimensions : 3,
			pD : p3D,
			lookup : lookupPairs3D,
		}
	}

	function createContribution(type, baseSet, index) {
		var i = 0
		const multiplier = baseSet[index ++]
		const c = { next : undefined }
		while(i < type.dimensions) {
			const axis = "xyzw"[i]
			c[axis + "sb"] = baseSet[index + i]
			c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish
		}
		return c
	}

	function createLookupPairs(lookupArray, contributions){
		var i
		const a = lookupArray()
		const res = new Map()
		for (i = 0; i < a.length; i += 2) {
			res.set(a[i], contributions[a[i + 1]]);
		}
		return res
	}

	function createContributionArray(type) {
		const conts = []
		const d = type.dimensions
		const baseStep = d * d
		var k, i = 0
		while (i < type.pD.length) {
			const baseSet = type.base[type.pD[i]]
			let previous, current
			k = 0
			do {
				current = createContribution(type, baseSet, k)
				if (!previous) {
					conts[i / baseStep] = current;
				}
				else {
					previous.next = current;
				}
				previous = current
				k += d + 1
			} while(k < baseSet.length)

			current.next = createContribution(type, type.pD, i + 1)
			if (d >= 3) {
				current.next.next = createContribution(type, type.pD, i + d + 2)
			}
			if (d === 4) {
				current.next.next.next = createContribution(type, type.pD, i + 11)
			}
			i += baseStep
		}
		const result = [conts, createLookupPairs(type.lookup, conts)]
		type.base = undefined
		type.lookup = undefined
		return result
	}

	let temp = createContributionArray(types._3D)
	const lookup3D = temp[1]
	const perm = new Uint8Array(256)
	const perm3D = new Uint8Array(256)
	const source = new Uint8Array(setOf(256))
	var seed = shuffleSeed(clientSeed, 3)
	doFor(256, function(i) {
		i = 255 - i
		seed = shuffleSeed(seed, 1)
		var r = (seed + 31) % (i + 1)
		r += r < 0 ? i + 1 : 0
		perm[i] = source[r]
		perm3D[i] = perm[i] % 24 * 3
		source[r] = source[i]
	})
	base3D = undefined
	lookupPairs3D = undefined
	p3D = undefined

	return function(x, y, z) {
		const pD = perm3D
		const p = perm
		const g = gradients3D
		const stretchOffset = (x + y + z) * STRETCH_3D
		const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset
		const xsb = floor(xs), ysb = floor(ys), zsb = floor(zs)
		const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D
		const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset)
		const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb
		const inSum = xins + yins + zins
		var c = lookup3D.get(
			yins - zins + 1
				| xins - yins + 1 << 1
				| xins - zins + 1 << 2
				| inSum << 3
				| inSum + zins << 5
				| inSum + yins << 7
				| inSum + xins << 9
		)
		var i, value = 0
		while (c !== undefined) {
			const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz
			let attn = 2 - dx * dx - dy * dy - dz * dz
			if (attn > 0) {
				i = pD[(p[xsb + c.xsb & 0xFF] + (ysb + c.ysb) & 0xFF) + (zsb + c.zsb) & 0xFF]
				attn *= attn
				value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz)
			}
			c = c.next
		}
		return value * NORM_3D + 0.5
	}
}



/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Matrix": () => (/* binding */ Matrix),
/* harmony export */   "PVector": () => (/* binding */ PVector),
/* harmony export */   "Plane": () => (/* binding */ Plane),
/* harmony export */   "copyArr": () => (/* binding */ copyArr),
/* harmony export */   "cross": () => (/* binding */ cross),
/* harmony export */   "rotX": () => (/* binding */ rotX),
/* harmony export */   "rotY": () => (/* binding */ rotY),
/* harmony export */   "trans": () => (/* binding */ trans),
/* harmony export */   "transpose": () => (/* binding */ transpose)
/* harmony export */ });
class PVector {
	constructor(x, y, z) {
		this.x = x
		this.y = y
		this.z = z
	}
	set(x, y, z) {
		if (y === undefined) {
			this.x = x.x
			this.y = x.y
			this.z = x.z
		}
		else {
			this.x = x
			this.y = y
			this.z = z
		}
	}
	normalize() {
		let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
		this.x /= mag
		this.y /= mag
		this.z /= mag
	}
	add(v) {
		this.x += v.x
		this.y += v.y
		this.z += v.z
	}
	mult(m) {
		this.x *= m
		this.y *= m
		this.z *= m
	}
	mag() {
		return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
	}
	magSquared() {
		return this.x * this.x + this.y * this.y + this.z * this.z
	}
}

const { cos, sin } = Math;

class Matrix {
	constructor(arr) {
		this.elements = new Float32Array(arr || 16)
	}
	translate(x, y, z) {
		let a = this.elements
		a[3] += a[0] * x + a[1] * y + a[2] * z
		a[7] += a[4] * x + a[5] * y + a[6] * z
		a[11] += a[8] * x + a[9] * y + a[10] * z
		a[15] += a[12] * x + a[13] * y + a[14] * z
	}
	rotX(angle) {
		let elems = this.elements
		let c = cos(angle)
		let s = sin(angle)
		let t = elems[1]
		elems[1] = t * c + elems[2] * s
		elems[2] = t * -s + elems[2] * c
		t = elems[5]
		elems[5] = t * c + elems[6] * s
		elems[6] = t * -s + elems[6] * c
		t = elems[9]
		elems[9] = t * c + elems[10] * s
		elems[10] = t * -s + elems[10] * c
		t = elems[13]
		elems[13] = t * c + elems[14] * s
		elems[14] = t * -s + elems[14] * c
	}
	rotY(angle) {
		let c = cos(angle)
		let s = sin(angle)
		let elems = this.elements
		let t = elems[0]
		elems[0] = t * c + elems[2] * -s
		elems[2] = t * s + elems[2] * c
		t = elems[4]
		elems[4] = t * c + elems[6] * -s
		elems[6] = t * s + elems[6] * c
		t = elems[8]
		elems[8] = t * c + elems[10] * -s
		elems[10] = t * s + elems[10] * c
		t = elems[12]
		elems[12] = t * c + elems[14] * -s
		elems[14] = t * s + elems[14] * c
	}
	scale(x, y, z) {
		let a = this.elements
		a[0] *= x;
		a[1] *= y;
		a[2] *= z;
		a[4] *= x;
		a[5] *= y;
		a[6] *= z;
		a[8] *= x;
		a[9] *= y;
		a[10] *= z;
		a[12] *= x;
		a[13] *= y;
		a[14] *= z;
	}
	identity() {
		let a = this.elements
		a[0] = 1
		a[1] = 0
		a[2] = 0
		a[3] = 0
		a[4] = 0
		a[5] = 1
		a[6] = 0
		a[7] = 0
		a[8] = 0
		a[9] = 0
		a[10] = 1
		a[11] = 0
		a[12] = 0
		a[13] = 0
		a[14] = 0
		a[15] = 1
	}
	// somebody optimize this
	// you just have to expand it
	mult(b) {
		const a = this.elements.slice()
		const out = this.elements
		let e = 0
		for (let row = 0; row < 4; row++) {
			for (let col = 0; col < 4; col++) {
				out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
			}
		}
	}
	// same here
	postMult(a) {
		const b = this.elements.slice()
		const out = this.elements
		let e = 0
		for (let row = 0; row < 4; row++) {
			for (let col = 0; col < 4; col++) {
				out[e++] = a[row * 4 + 0] * b[col + 0] + a[row * 4 + 1] * b[col + 4] + a[row * 4 + 2] * b[col + 8] + a[row * 4 + 3] * b[col + 12];
			}
		}
	}
	transpose() {
		let matrix = this.elements
		let temp = matrix[4]
		matrix[4] = matrix[1]
		matrix[1] = temp

		temp = matrix[8]
		matrix[8] = matrix[2]
		matrix[2] = temp

		temp = matrix[6]
		matrix[6] = matrix[9]
		matrix[9] = temp

		temp = matrix[3]
		matrix[3] = matrix[12]
		matrix[12] = temp

		temp = matrix[7]
		matrix[7] = matrix[13]
		matrix[13] = temp

		temp = matrix[11]
		matrix[11] = matrix[14]
		matrix[14] = temp
	}
	copyArray(from) {
		let to = this.elements
		for (let i = 0; i < from.length; i++) {
			to[i] = from[i]
		}
	}
	copyMatrix(from) {
		let to = this.elements
		from = from.elements
		for (let i = 0; i < from.length; i++) {
			to[i] = from[i]
		}
	}
}

class Plane {
	constructor(nx, ny, nz) {
		this.set(nx, ny, nz)
	}
	set(nx, ny, nz) {
		// Pre-computed chunk offsets to reduce branching during culling
		this.dx = nx > 0 ? 16 : 0
		this.dy = ny > 0
		this.dz = nz > 0 ? 16 : 0

		// Normal vector for the plane
		this.nx = nx
		this.ny = ny
		this.nz = nz
	}
}

function cross(v1, v2, result) {
	let x = v1.x,
		y = v1.y,
		z = v1.z,
		x2 = v2.x,
		y2 = v2.y,
		z2 = v2.z
	result.x = y * z2 - y2 * z
	result.y = z * x2 - z2 * x
	result.z = x * y2 - x2 * y
}

function trans(matrix, x, y, z) {
	let a = matrix
	a[3] += a[0] * x + a[1] * y + a[2] * z
	a[7] += a[4] * x + a[5] * y + a[6] * z
	a[11] += a[8] * x + a[9] * y + a[10] * z
	a[15] += a[12] * x + a[13] * y + a[14] * z
}

function rotX(matrix, angle) {
	// This function is basically multiplying 2 4x4 matrices together,
	// but 1 of them has a bunch of 0's and 1's in it,
	// so I removed all terms that multiplied by 0, and just left off the 1's.
	// mat2 = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
	let elems = matrix
	let c = cos(angle)
	let s = sin(angle)
	let t = elems[1]
	elems[1] = t * c + elems[2] * s
	elems[2] = t * -s + elems[2] * c
	t = elems[5]
	elems[5] = t * c + elems[6] * s
	elems[6] = t * -s + elems[6] * c
	t = elems[9]
	elems[9] = t * c + elems[10] * s
	elems[10] = t * -s + elems[10] * c
	t = elems[13]
	elems[13] = t * c + elems[14] * s
	elems[14] = t * -s + elems[14] * c
}

function rotY(matrix, angle) {
	//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
	let c = cos(angle)
	let s = sin(angle)
	let elems = matrix
	let t = elems[0]
	elems[0] = t * c + elems[2] * -s
	elems[2] = t * s + elems[2] * c
	t = elems[4]
	elems[4] = t * c + elems[6] * -s
	elems[6] = t * s + elems[6] * c
	t = elems[8]
	elems[8] = t * c + elems[10] * -s
	elems[10] = t * s + elems[10] * c
	t = elems[12]
	elems[12] = t * c + elems[14] * -s
	elems[14] = t * s + elems[14] * c
}

function transpose(matrix) {
	let temp = matrix[4]
	matrix[4] = matrix[1]
	matrix[1] = temp

	temp = matrix[8]
	matrix[8] = matrix[2]
	matrix[2] = temp

	temp = matrix[6]
	matrix[6] = matrix[9]
	matrix[9] = temp

	temp = matrix[3]
	matrix[3] = matrix[12]
	matrix[12] = temp

	temp = matrix[7]
	matrix[7] = matrix[13]
	matrix[13] = temp

	temp = matrix[11]
	matrix[11] = matrix[14]
	matrix[14] = temp
}

function copyArr(a, b) {
	for (let i = 0; i < a.length; i++) {
		b[i] = a[i]
	}
}



/***/ }),
/* 14 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "compareArr": () => (/* binding */ compareArr),
/* harmony export */   "roundBits": () => (/* binding */ roundBits),
/* harmony export */   "timeString": () => (/* binding */ timeString)
/* harmony export */ });
const { floor } = Math;

function timeString(millis) {
	if (millis > 300000000000 || !millis) {
		return "never"
	}
	const SECOND = 1000
	const MINUTE = SECOND * 60
	const HOUR = MINUTE * 60
	const DAY = HOUR * 24
	const YEAR = DAY * 365

	if (millis < MINUTE) {
		return "just now"
	}

	let years = floor(millis / YEAR)
	millis -= years * YEAR

	let days = floor(millis / DAY)
	millis -= days * DAY

	let hours = floor(millis / HOUR)
	millis -= hours * HOUR

	let minutes = floor(millis / MINUTE)

	if (years) {
		return `${years} year${years > 1 ? "s" : ""} and ${days} day${days !== 1 ? "s" : ""} ago`
	}
	if (days) {
		return `${days} day${days > 1 ? "s" : ""} and ${hours} hour${hours !== 1 ? "s" : ""} ago`
	}
	if (hours) {
		return `${hours} hour${hours > 1 ? "s" : ""} and ${minutes} minute${minutes !== 1 ? "s" : ""} ago`
	}
	return `${minutes} minute${minutes > 1 ? "s" : ""} ago`
}

function roundBits(number) {
	return (number * 1000000 + 0.5 | 0) / 1000000
}

function compareArr(arr, out) {
	let minX = 1000
	let maxX = -1000
	let minY = 1000
	let maxY = -1000
	let minZ = 1000
	let maxZ = -1000
	let num = 0
	for (let i = 0; i < arr.length; i += 3) {
		num = arr[i]
		minX = minX > num ? num : minX
		maxX = maxX < num ? num : maxX
		num = arr[i + 1]
		minY = minY > num ? num : minY
		maxY = maxY < num ? num : maxY
		num = arr[i + 2]
		minZ = minZ > num ? num : minZ
		maxZ = maxZ < num ? num : maxZ
	}
	out[0] = minX
	out[1] = minY
	out[2] = minZ
	out[3] = maxX
	out[4] = maxY
	out[5] = maxZ
	return out
}



/***/ }),
/* 15 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BLOCK_COUNT": () => (/* binding */ BLOCK_COUNT),
/* harmony export */   "Block": () => (/* binding */ Block),
/* harmony export */   "Sides": () => (/* binding */ Sides),
/* harmony export */   "blockData": () => (/* binding */ blockData),
/* harmony export */   "blockIds": () => (/* binding */ blockIds),
/* harmony export */   "texturesFunc": () => (/* binding */ texturesFunc)
/* harmony export */ });
const randomBetween = (min, max) => min + Math.floor(Math.random() * (max - min + 1));

const texturesFunc = function (setPixel, getPixels) {
	return {
		grassTop: n => {
			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const d = Math.random() * 0.25 + 0.65

					const r = 0x54 * d
					const g = 0xa0 * d
					const b = 0x48 * d

					setPixel(n, x, y, r, g, b)
				}
			}
		},
		grassSide: function(n) {
			const pix = getPixels(this.dirt)

			// Fill in the dirt texture first
			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i + 1], pix[i + 2], pix[i + 3])
			}

			const { random } = Math

			for (let x = 0; x < 16; ++x) {
				const m = random() * 4 + 1
				for (let y = 0; y < m; ++y) {
					const d = random() * 0.25 + 0.65
					const r = 0x54 * d
					const g = 0xa0 * d
					const b = 0x48 * d
					setPixel(n, x, y, r, g, b)
				}
			}
		},
		leaves: n => {
			const { floor, random } = Math;

			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const r = 0
					const g = floor(random() * 30 + 100)
					const b = floor(random() * 30)
					const a = random() < 0.35 ? 0x0 : 0xff

					setPixel(n, x, y, r, g, b, a)
				}
			}
		},
		lava: n => {
			const {floor, random} = Math;

			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					// const yellow = [255, 255, 51]
					const r = randomBetween(100, 200)
					const g = 0.5
					const b = 0.5

					setPixel(n, x, y, r, g, b)
				}
			}
		},
		water: n => {
			const {floor, random} = Math;

			for (let x = 0; x < 16; ++x) {
				for (let y = 0; y < 16; ++y) {
					const r = 0.05
					const g = floor(random() * 0.5)
					const b = floor(random() * 54 - 60)
					const a = 75

					setPixel(n, x, y, r, g, b, a)
				}
			}
		},
		hitbox: "0g0g100W",  // Black
		nothing: "0g0g1000", // Transparent black
		"acaciaLog": "0g0g6YQYYAWUZnH50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		"acaciaLogTop": "0g0gbYVQY)HPjZHWZNYRYW?3Y1xizNj1g4Q??UQTAGIIkQ?Q]>XVVVVP)]*VVTBP5]5VVlXPBVVVV])?QQ@])IIII>QV?VQTgNxg0iz(",
		"acaciaPlanks": "0g0g7HWZRYWNYiY4AJ9A080Aw2cJi3aAP2KwoX1_0jA92TAX40czSAA4SA4PkiA9c0PNg0AG",
		"andesite": "0g0g6ZHZEZYY461a2BwA]V+pe0^j6Rc!Td|+4({*C!S+r)gVSi$m3c)",
		"bedrock": "0g0g5W(WVVHHwW4J|iw(%I(PA{5j]J^J^A+1FyMywTPk(RddQxi19y0QcJ^c*hCkr1iT^(ER",
		"birchLog": "0g0g8Y|HZZZZZH)YY00Q4Q0riJ04r_TSFwTB4]?+vwjZ]+1iTB0f&6Q%95w",
		"birchLogTop": "0g0gaZZZHW)H8HYEZHGHH1xizNj1g4Q??UQTAGIIkQ?Q]>BXVVVVP)]*VVTBP5]5VVlXPBVVVV])?QQ@])IIII>AQV?VQTgNxg0iz(",
		"birchPlanks": "0g0g78HYEZGHHHCW4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		"blackConcrete": "0g0g48wZ8MW4wZ8xWme9;yX^<~<L4;k,",
		"blackWool": "0g0gfcMWcTH8MWgYoZcMHkZ8wZkY8xWAJYgTH4wZsWwH1w)5IFIQ9r||Q]|<b8QGQDDd717rbQO^]h@5|QB1:yG8Q@EwIhQ0GhGD)X@|XVXg10|",
		"blueConcrete": "0g0g3$W$Z$Wl?T?QA]0@VUUh?kkw55kUoTlV0Uhhg0VUR0g?QghX54UVS40UlUk",
		"blueWool": "0g0gj$H(H$W)Y-W(H)W$W)Z)Z<:W-H(Y$Z.aH<aY-W<qY.aY0Q1MeAwR^k0I$,cz8I]]4#s}>aJg!ayg[h1FkcTIEI8Up1]xA4o#axR#oI!k^I?-XcPhX1^I8}G;[ph5F2hc-dJx4USwh5K{l",
		"bookshelf": "0g0gt*WkZWZ$W)HAWMZF,YSYTWKYYMWHHMWHEYi+YZKHZdWWVYPAY;ZW0RxcRgRgIw18RXx^1FF^iFX3K2.m#wugM0M020XgygRh8K1^mFc3mkmb}b@U3!b}au06M^06M00",
		"bricks": "0g0g9XZUWHWnZ>ZjHWZ0iO(0k(0hUhhUhGVy]RyA]RyO0gk(0gihlVVmGRyA]Qyy]0kO(gkO0hUhhhVVA]Ryy]Ryg0gi(0gkhhUhhRyy]QyAI",
		"brownConcrete": "0g0g3ZKWKZqlVTVlVJIVIV",
		"brownWool": "0g0gi2W2HWiHNZ2WyYKWyYiYWNZiHKZRZ>WyY2H0QxMeAw[PhI$cz7]]4#s}OaJga2yg[h1FXTIEI8Upg]pA4nob2RbyFT^I?-cPh{KXhRC8}G;[ph5Ehc:wMwkSy.5K{l",
		"chiseledQuartzBlock": "0g0g6YHZYWZ4Ja]+]5Bri]9,A0id4d9wJ09_PFi210JxA|AJPi@4kPB.{4wJ0]X]mJ]Dw0id*%AA49CC",
		"chiseledQuartzBlockTop": "0g0g5YHZWZ4MJh46gB1EgD2-zg+T0biiRRK0020(JiJJPAJPA00p039kpz8,2+w@RwRk8h1giRJ",
		"chiseledStoneBricks": "0g0g7ZEYYZYWY00]0Rd+&A!090e2e7J!n)&ck!nE)aIB)eLEe!dJA2S0J:;$PAJPA",
		"coalBlock": "0g0g5sZkHc(Z4gHEY0_A)SFP|1Ag9F$J^iiPy2CI4kTF(E^J5NF]X5g9xgJQJQ",
		"coalOre": "0g0g7-ZZHY;Z)H?kH4|y0Bm04Fp90g{iiQ5gw#QQB6P|J00igRAmU1oS+AJ0d^1F+2P^0PmPFg1wkAJAJS",
		"cobblestone": "0g0g6ZWH?WHoY5C^l!?!VmC_KCA_T?UA!cbTh|6wdMS_wmi$QBmwr?MVm^8lP)T4",
		"cyanConcrete": "0g0g3lYlYlH1IpE?Smkw6PB?S4k299kRPw?A2I8pUiSg95Eak??1RFKS",
		"cyanWool": "0g0gelYm8ZmFWmPHlZm.WlYmZmHmoZlYmYmYm.H10zTKy6BG6ppF:*x:#PxROimO6_@1@p1GyJGNhG*1:V<TpmF6po?GGO*J24Vh<4llhz%GFFh%g14",
		"darkOakLog": "0g0g6;Z(W]ZEW(HiY50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		"darkOakLogTop": "0g0gb;Z)YAWsKZ{Y]HY(Z-W;W(H1xizNj1g4Q??UQTAGIIkQ?Q]>XVVVVP)]*VVTBP5]5VVlXPBVVVV])?QQ@])IIII>QV?VQTgNxg0iz(",
		"darkOakPlanks": "0g0g7{Y]HY-W;W(ZEKZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		"diamondBlock": "0g0g9_HWHncHZHZZZYWWeZ00h01hg23QVO*N4VKh7N4*K0GlV0lVK6VKo3VG1o3GGK18lGK0lGG7m8gVK658g1gGKhGKh60gg1g0yEIyIyI",
		"diamondOre": "0g0g8-ZZHYWYWHZH4|y0Bm04Fr90g|iiQ5gw#QC6P|J00mgRAmVg1oS+AJ0d1F+20PrkPFg1wkAJAJS",
		"diorite": "0g0g6EYWWY;ZY4P)yR,g+E?bX_{o|i+]ohFM2TQpbjKNxR+lAA(&nj^wX6c+Ng",
		"dirt": "0g0g7lZYYYoHZH49Pg?S9(J9C)yBkaE%U{)9E84]2$FkQ?Pwh?0KNFih{RPA?${)9FX1kEiBy",
		"emeraldBlock": "0g0g6nkHqHZ>HnWuY0000019A]800w0c)J@8w00mV8wJocw?c(?8(4gc(Cgcim?gPA?cB01gJPAJg]48+",
		"emeraldOre": "0g0g7-ZZHYYnW1Y4|y0BiB4FPm060pQwbw(gQ&4PP00gBRAJak^!AJ41%5+2]4P,g1wkwiAJS",
		"glass": "0g0g5Y|Y000HcZ0000019AJPA9wJPA94JPA8JPA9AJPA9AJPA9AJPA9AJPA9AJPA9AJPA9AJPAFAJPAk9AJPwFAJPACpAJP9",
		"glowstone": "0g0g8HlHRYiWZZZZYYNH5+T%^Yb?g_m2wKb~>r$e+FDDn5j#_yl",
		"goldBlock": "0g0g9NHWWZWZZZZZZZXYNH00h01hg23QVO*N4VKh7N4*K0GlV0lVK6VKo3VG1o3GGK18lGK0lGG7m8gVK658g1gGKhGKh60gg1g0yEIyIyI",
		"goldOre": "0g0g8-ZZHYZYZHYZZZ4|y0Bm04Fr90g|iiQ5gw#QC6P|J00mgRAmVg1oS+AJ0d1F+20PrkPFg1wkAJAJS",
		"granite": "0g0gaWYWUH{ZDHH3HWaZ1xMihTmioMjMjNnhiCMnlnihmNhNjzGwyjh+jygMMmhjOjh1A,MylxjNhMCM+ljm2MEh,+nj>h+RRNMhMzhFiMDNxhozigMh2yMMh+",
		"gravel": "0g0g8Y7Z-ZYHZWZ5,$#_{/dl$#g$Y#Kj<#..$BF(cGD)",
		"grayConcrete": "0g0g2)Z-Z00000000090000000000000000S100gg",
		"grayWool": "0g0gd-W<4HTAZTkYTAY)Z<kY-Z?*W?AZ?)Z.4W-Z00i0)7jIh711h^QI>g!rq1gM1yV6cy5a50511IyhmMI@0I>0!OQb15hc1pVj3IkIQ>mM10ObA03VjViI*>I^hIhN0bg.0",
		"greenConcrete": "0g0g2PHPHh;M!yl|acK",
		"greenWool": "0g0gh|WZYH|ZVYYPWVYhYZPHHHHPH|W0S1c4F4w7T^1!rkMaOcS@4{25&!y917.;131^@M9]q^8l16M[k1yIEgy,]1pFcKI80gX08B8GNfgMpaFgw]Qow-s5^0",
		"ironBlock": "0g0gb;ZcWWZYHYWZWH1g0001hgiyyO)VVlVVVVVVIIIiyyzOVVlVVVVVVIIizOOVVVlVVVVVVIIIiyyzO*VlVVVVVVIIiyzO*VVlVVVVVVhhhm",
		"ironOre": "0g0g8-ZZHYWW,HaY4|y0Bm04Fr90g|iiQ5gw#QC6P|J00mgRAmVg1oS+AJ0d1F+20PrkPFg1wkAJAJS",
		"jungleLog": "0g0g9hYNWHHSW;WVMYJHW1y3OOhg004S404VQQ@?US4xh0hy33O(Sh04Q6K03O??Vh10OO02x??V1g>O(0iwQy00QOQO)V0hhg4?U>(>UhQ0xh6KQQj3)Q010Q?hTg01g>O00OO",
		"jungleLogTop": "0g0g9HWSW;WmHH+YHY1xiOyi1g4Q??UQTAGGIIGkQ?Q[>BVVVV])X[*VVTBX]5X[5XVVlG]*XVVVV[)X?QQ@[AGGGGRAQV?VQTgzxg0izw",
		"junglePlanks": "0g0g7mHH+YHYHiZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		"lapisBlock": "0g0gdBYxPZ*WMIYtFHxEYsWt8HoHoYt7ZFZkW100gzkkklj5MnV7V5GrbVVG57GDD7lnl5lG@GoII",
		"lapisOre": "0g0ga-ZZHYpZxYloZgZhqZgZ1gixzyg0hO(01jOii?@jyxh1g8+10yxizN1N2hgj)jzwx,X1hhEw2iNw061E)jNg1MEI-MOOEhJ0Oh6iw9O+K0iKw1ixKg1yxhhg1hhh0",
		"lightBlueConcrete": "0g0g3C$Yy$HysHiVUS1kklk?gVKk4lVTVlhS5UhhlxTTkV9hVgFS155Vkh??TlV4VlSl",
		"lightBlueWool": "0g0gq&ZNW!Z/Y@W&W&W=ZRZC;Y!ZC{Y~uH[eW+Hy$H!{Y+H_eH/YRZRWNHC$YNW=Z0Q1/i_p2Mm^Q@M7oD#xJ;^NV,yhP_y1%m9zeMj8u1z?xsRFP7O>1(p7@(w{E{c|({I~wl",
		"lightGrayConcrete": "0g0g2HWGZYGH<:|",
		"lightGrayWool": "0g0ginYnZ7Y-HWJ]YZH7HHWEWW-H-YJZDZH0QxxFx]ppi2w#No{a!!No8yg[T194_^]^8l^g{!Olk(aRa9FU{N>g^gR}A[p6o:P{@c^n=2SUTP^5^",
		"limeConcrete": "0g0g3YYY4020088Ewg1204000Aww2A024A14gh00020wE01g00oS081820",
		"limeWool": "0g0ggYYYY1YYYYYYYNHYYH1YHhZ1w)VIy@2j}=@QDD1sB1@O-_h5B@;yk+~FBIh@5qh~%)@OZVgB]1M5}",
		"magentaConcrete": "0g0g4ZWZZ5SVPTUV@2^SK@345@9VoRt4VVx}xQ11hxl50",
		"magentaWool": "0g0gsHYHHbW:YY#H#YWrWWbWrHW:ZZZZaZ{WYrH#Y_ZYWH0QNk/iBE_hqp$Oz/?gdK]X)F@5FyP|>A1N>toi7.m8up>Rns|SRydOg7{hXp%8UPxU.Tx{PaFwz~",
		"mossyCobblestone": "0g0gbWYHW*HlWWoYHZ?W1yMj?6Bi)3hMghnV3?w,DgDMniGhnV1kg+j0G(j10Mhpgjj4Dj??5G47hpGn1nhm",
		"mossyStoneBricks": "0g0gcEYZWlW*HYZWYYYW1z)>xQ3?m7>R6DgNN(Em.KpFC+9zDGyGIVQMh81hjQw06gK036KmCK6pJ3@6y4GFVIVV",
		"netherBricks": "0g0g7oMW;HQJYwTH(ZEY-Z000000BmQJKBA0+0+A}7PAbPAP%_030326uuddJ_JTTAJAJTA",
		"netherQuartzOre": "0g0gcHUWYYWSHY#YZ4WZW12NQO)MjMBzQ5Ow>>l@wN))^GT3zPQQAM4@PO>3Q)T5C>!N)KOQzPR))k,@QN@5SRi3>A-4-(k)P@mSzQx))Oy)R)lzQO",
		"netherrack": "0g0g7HUWYYWSH4W4Cp%IOR6g)?ph+e#s7)XU2)@s}2M?@e*o][oM]}{VrP*.r",
		"netherWartBlock": "0g0g50WgW0WYW02I0w10241A2084oQ0{ww0wJ1{804RE0h0S52wN9A104809KkgQ4^Xy1SyIAU121g4yg50g0wg17g1S10",
		"oakLog": "0g0g6H{HW-YyYY50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		"oakLogTop": "0g0g9yY{HHVZ*HWHWkZ1210x0g0jO))U>OM3GIIG3O)O,(4QQQQ-Sj[,T4@QQ[(4[]XX-S4[],Sk[QQX[T4[X-S4QQQQ,Sj)OO*,T3GGGG(3OQ)?QO(1010x0i0",
		"oakPlanks": "0g0g7VZ*HWWkZHRZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		"orangeConcrete": "0g0g2WWRgguhKoC124Sw0x8Q21SSSo40",
		"orangeWool": "0g0gmHYHHWYYHYWWWRY1ZZZiWNHHZHyH0QNk/iBE_xqI&u]~QgM7w_7O25:RFNyPi|3A1NRCheMi8udp3dR4O-ROMxgT7QhSpPxU(T~Ph7ic]E{xxc}",
		"pinkConcrete": "0g0g3ZWZ5QS14gkgk01gQ10gQ4000ghS0?0]9kgk41Q42T4g01h105k4S4hS00gggQS",
		"pinkWool": "0g0gvYWH!YYZZWHWY/ZH/YYZqHaHWWH^ZHHaWZWZYW_W0Q1/i{h3dp((/}Q.7-$D+;a/hP_N1&moob7.l8u1ORp{{(CuF|7|I17pm-T-er90~l",
		"polishedAndesite": "0g0g9ZZ.ZEHWWWYPW11hhh1gijQ>O),jOO)SIO[38Q)O,jO*NQQ,k>)Q*OQ@jOX-Iy)k>QQUO+jEO-8j>)>)>N,j-XQIO,mOOOIOIjI)Q(jOQQOQ,kQ]O)>,GGGGGG",
		"polishedDiorite": "0g0g8HYW$YYWW-Y0i00J25+_5@VAkKE$z%)x!)5iC}cTy92$mMQ-$%dB]}cI1ddjm9!(tC",
		"polishedGranite": "0g0g9WWDHHYWUH3H{Z00gwy2zz4VQU)QV?kk>)QR[4QVUOV@4QQ>VQQCUVQQU@5>)QQQ4QQ@U>)@B@QOQVBAQ?U?UQ@lQQQQAV@4TVQQ@4OQQ>)V[BU?QU>+AQUQVQT[GIGGGI",
		"purpleConcrete": "0g0g4ZZKYYlm100TNVQgp58200S2RV1lhgg4pjk0T)S?lUlRS10TTp0T]Q4T1",
		"purpleWool": "0g0gmWHWYWWZZYZcZXWHZXHIYZZZXHHIH0Q15MeAwPT2^mz,1zpES]X3s5(gaJg[Ps11j1TE8Up1]pAP1^P21^I?-c]gcKX0EC8}DphlE1-w]Qw]D05o|(1",
		"quartzBlockBottom": "0g0g3HZY05?150V0V01VU10050060500V051S01",
		"quartzBlockSide": "0g0g6ZHZYWY0000005AJ{9+JV%A%A+9+P9yP4J^PA4]J|9+AJV4JPB+4J4|y|9CAJV%)AJAJ_",
		"quartzBlockTop": "0g0g6ZHZYWY0000005AJ{9+JV%A%A+9+P9yP4J^PA4]J|9+AJV4JPB+4J4|y|9CAJV%)AJAJ_",
		"quartzPillar": "0g0g4WHZYh&tiu&%u&%x%%&yy%uuhiuy%&%tt",
		"quartzPillarTop": "0g0g5WYYHZ546P490FDs)J.rJ@1JP8Qi^*i^FjkF2^?kD4?i2C^QkTJP81.AJ@PDAJ)F0J90J8k|y",
		"redConcrete": "0g0g1W",
		"redNetherBricks": "0g0g7$0WTHY)0WQgH-gHUMW000000BmQJKBA0+0+A}7PAbPAP%_030326uuddJ_JTTAJAJTA",
		"redstoneBlock": "0g0g5YYKY(WW0000004Q]4XPyI4zCI0s}Q05@I58a@9o859q]I5]d4s]5BAJA0kyI49]J]000000",
		"redstoneOre": "0g0g9-ZZHY0W0W0WgHgH1gixzyg0hx(01jOiiORjNxUh011l1gyxizN1x2hgh*izwxo@1@hhzMg0ONw05T1zih2h1MD01MxROw3Myhhg03BK1iz(2@i0lh6xhix01g1yxhhhwhhh0",
		"redWool": "0g0gdWJWWJWWWJWZHWHHW1w)0Vw2*GM21JjjVVM^h/3M3QF2Q2ya919hw1GQO+GhGV0^VV$12OyoJ+5G*GVVm30h?0ylhJF)GVOOUcgw1M0",
		"sand": "0g0g6Y/WWpHYY4?r8@+9AFNPE^$NKi$_%bi5J((BoPlm?laEE?o?k$",
		"smoothStone": "0g0g7ZH-ZYWWZ42Byg&,qOsJ+my|sp*|Pm%&.+d[qlN:x5wiSJg",
		"soulSand": "0g0g6jYSH)W]ZQHW4A3{4hBCyFcMItT]dIUdp(Kq3C3Rc+KPR(qyoI}No{RwRwA^T$4-pTd",
		"spruceLog": "0g0g6-W(Y{H$Y$YUZ50cyX6cy4eS4i4{SQgNkQSSSXTgwT0Xy1Tg5yh?g0whko0x3gko4x3/85j(wX1g0Sj4iSh42X",
		"spruceLogTop": "0g0g8UZQWiHYHYyZRZ4wSQ20%s+d%Zdj.AJ[L[j]Pjj[Oj.jAJ[Lrfds@40SQ2",
		"sprucePlanks": "0g0g7YHYyZRZiHUZ4AJ9A080Aw2cJi3aAP2KwoX1_0jA92PAX40czSAA4A4PQiA9cgPNg0AG",
		"stone": "0g0g4-ZZHY0VV?5SB?V8!V1k5k1VTV4@6VV0VT",
		"stoneBricks": "0g0g7EYZYZYYW4JPA2$(0dx8&(syN.iA^%JAJR4JP0x3d&8rK,!Mi(JdJ_",
		"tntBottom": "0g0g4HY-ZWkkkkZZZZkkkkZZZZkkkkZZZZkkkkZZZZ",
		"tntSide": "0g0ga1YYHWZZZ;ZY)HoZW0i0i0i0ihzhzhzhzhzhzhzhzhzhzhzhzhzhzhzhz?V@GUVG?GV@VUyOyOyOyOhzhzhzhzhzhzhzhzhzhzhzhzyzyzyzyz",
		"tntTop": "0g0g7Y1Y-ZHVVHWgTZ4]4]FNFN!4]4]FN;!]+[4c]!{;!l4]!NMOjFF",
		"whiteConcrete": "0g0g3HH|H4?541S4k40ggh50g?0k1wA0l4g04U0kQ?4l00U01h0044l0h1QkTg45h",
		"whiteWool": "0g0gnWHZZYHWWWHYZYWZZZYYHZYZYY0QNkRU*1reoO,=_.%^X)uV/yJU1*Rmsi7.)8p*^G-}S;2dO<EpXpE%8Vx.^s7AzT",
		"yellowConcrete": "0g0g4HHYHlV01zs@S1?4S9551OKV14VN[lllRh(0oUVUV{{0SQh",
		"yellowWool": "0g0gjZZYYiHZ>WyYNZHYZZ2W2WZHZYyHZNZZ>HW0QNk0MygPxqSA$#*:}GEwKX25O0R890y]^0w1222hX!E8Uowp.o1aJ$RaUx1t^})>gQgcKXo2y@8I]x]E.>eMISnz]yK|h"
	}
}

const blockData = [
	{
		name: "air",
		id: 0,
		textures: [],
		transparent: true,
		shadow: false,
		solid: false
	},
	{
		name: "grass",
		textures: ["dirt", "grassTop", "grassSide"],
	},
	{ name: "dirt" },
	{ name: "stone" },
	{ name: "bedrock" },
	{ name: "sand" },
	{ name: "gravel" },
	{
		name: "leaves",
		transparent: true,
	},
	{
		name: "glass",
		transparent: true,
		shadow: false,
	},
	{ name: "cobblestone" },
	{ name: "mossyCobblestone" },
	{ name: "stoneBricks" },
	{ name: "mossyStoneBricks" },
	{ name: "bricks" },
	{ name: "coalOre" },
	{ name: "ironOre" },
	{ name: "goldOre" },
	{ name: "diamondOre" },
	{ name: "redstoneOre" },
	{ name: "lapisOre" },
	{ name: "emeraldOre" },
	{ name: "coalBlock" },
	{ name: "ironBlock" },
	{ name: "goldBlock" },
	{ name: "diamondBlock" },
	{ name: "redstoneBlock" },
	{ name: "lapisBlock" },
	{ name: "emeraldBlock" },
	{ name: "oakPlanks" },
	{
		name: "oakLog",
		textures: ["oakLogTop", "oakLog"],
	},
	{ name: "acaciaPlanks" },
	{
		name: "acaciaLog",
		textures: ["acaciaLogTop", "acaciaLog"],
	},
	{ name: "birchPlanks" },
	{
		name: "birchLog",
		textures: ["birchLogTop", "birchLog"],
	},
	{ name: "darkOakPlanks" },
	{
		name: "darkOakLog",
		textures: ["darkOakLogTop", "darkOakLog"],
	},
	{ name: "junglePlanks" },
	{
		name: "jungleLog",
		textures: ["jungleLogTop", "jungleLog"],
	},
	{ name: "sprucePlanks" },
	{
		name: "spruceLog",
		textures: ["spruceLogTop", "spruceLog"],
	},
	{ name: "whiteWool" },
	{ name: "orangeWool" },
	{ name: "magentaWool" },
	{ name: "lightBlueWool" },
	{ name: "yellowWool" },
	{ name: "limeWool" },
	{ name: "pinkWool" },
	{ name: "grayWool" },
	{ name: "lightGrayWool" },
	{ name: "cyanWool" },
	{ name: "purpleWool" },
	{ name: "blueWool" },
	{ name: "brownWool" },
	{ name: "greenWool" },
	{ name: "redWool" },
	{ name: "blackWool" },
	{ name: "whiteConcrete" },
	{ name: "orangeConcrete" },
	{ name: "magentaConcrete" },
	{ name: "lightBlueConcrete" },
	{ name: "yellowConcrete" },
	{ name: "limeConcrete" },
	{ name: "pinkConcrete" },
	{ name: "grayConcrete" },
	{ name: "lightGrayConcrete" },
	{ name: "cyanConcrete" },
	{ name: "purpleConcrete" },
	{ name: "blueConcrete" },
	{ name: "brownConcrete" },
	{ name: "greenConcrete" },
	{ name: "redConcrete" },
	{ name: "blackConcrete" },
	{
		name: "bookshelf",
		textures: ["oakPlanks", "bookshelf"]
	},
	{ name: "netherrack" },
	{ name: "soulSand" },
	{
		name: "glowstone",
		lightLevel: 15
	},
	{ name: "netherWartBlock" },
	{ name: "netherBricks" },
	{ name: "redNetherBricks" },
	{ name: "netherQuartzOre" },
	{
		name: "quartzBlock",
		textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"]
	},
	{
		name: "quartzPillar",
		textures: ["quartzPillarTop", "quartzPillar"]
	},
	{
		name: "chiseledQuartzBlock",
		textures: ["chiseledQuartzBlock", "chiseledQuartzBlockTop"]
	},
	{ name: "chiseledStoneBricks" },
	{ name: "smoothStone" },
	{ name: "andesite" },
	{ name: "polishedAndesite" },
	{ name: "diorite" },
	{ name: "polishedDiorite" },
	{ name: "granite" },
	{ name: "polishedGranite" },
	{ name: "light", textures: "nothing", lightLevel: 15, solid: false, icon: "glass", transparent: true, shadow: false },
	{ name: "water", semiTrans: true, transparent: true, solid: false, shadow: false },
	{ name: "lava", solid: false, transparent: true },
	{ name: "tnt", textures: ["tntBottom", "tntTop", "tntSide"] }
]

const BLOCK_COUNT = blockData.length;

// Set defaults on blockData
for (let i = 1; i < BLOCK_COUNT; ++i) {
	const data = blockData[i];
	data.id = i;

	if ( !("textures" in data) ) {
		data.textures = new Array(6).fill(data.name);
	}
	else if (typeof data.textures === "string") {
		data.textures = new Array(6).fill(data.textures);
	}
	else {
		const { textures } = data;

		if (textures.length === 3) {
			textures[3] = textures[2];
			textures[4] = textures[2];
			textures[5] = textures[2];
		}
		else if (textures.length === 2) {
			// Top and bottom are the first texture, sides are the second.
			textures[2] = textures[1];
			textures[3] = textures[2];
			textures[4] = textures[2];
			textures[5] = textures[2];
			textures[1] = textures[0];
		}
	}

	data.transparent = data.transparent || false;

	data.shadow = data.shadow !== undefined
		? data.shadow
		: true;

	data.lightLevel = data.lightLevel || 0;
	data.solid = data.solid !== undefined ? data.solid : true
	data.icon = data.icon || false
	data.semiTrans = data.semiTrans || false
}

const blockIds = {}
blockData.forEach(block => blockIds[block.name] = block.id)

let Block = {
	top: 0x4,
	bottom: 0x8,
	north: 0x20,
	south: 0x10,
	east: 0x2,
	west: 0x1,
}
let Sides = {
	top: 0,
	bottom: 1,
	north: 2,
	south: 3,
	east: 4,
	west: 5,
}



/***/ }),
/* 16 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createDatabase": () => (/* binding */ createDatabase),
/* harmony export */   "deleteFromDB": () => (/* binding */ deleteFromDB),
/* harmony export */   "loadFromDB": () => (/* binding */ loadFromDB),
/* harmony export */   "saveToDB": () => (/* binding */ saveToDB)
/* harmony export */ });
async function createDatabase() {
	return await new Promise((resolve, reject) => {
		let request = window.indexedDB.open("MineKhan", 1)

		request.onupgradeneeded = function(event) {
			let DB = event.target.result
			// Worlds will contain and ID containing the timestamp at which the world was created, a "saved" timestamp,
			// and a "data" string that's identical to the copy/paste save string
			let store = DB.createObjectStore("worlds", { keyPath: "id" })
			store.createIndex("id", "id", { unique: true })
			store.createIndex("data", "data", { unique: false })
		}

		request.onsuccess = function() {
			resolve(request.result)
		}

		request.onerror = function(e) {
			console.error(e)
			reject(e)
		}
	})
}
async function loadFromDB(id) {
	let db = await createDatabase()
	let trans = db.transaction("worlds", "readwrite")
	let store = trans.objectStore("worlds")
	let req = id ? store.get(id) : store.getAll()
	return await new Promise(resolve => {
		req.onsuccess = function() {
			resolve(req.result)
			db.close()
		}
		req.onerror = function() {
			resolve(null)
			db.close()
		}
	})
}
async function saveToDB(id, data) {
	let db = await createDatabase()
	let trans = db.transaction("worlds", "readwrite")
	let store = trans.objectStore("worlds")
	let req = store.put({ id: id, data: data })
	return new Promise((resolve, reject) => {
		req.onsuccess = function() {
			resolve(req.result)
		}
		req.onerror = function(e) {
			reject(e)
		}
	})
}
async function deleteFromDB(id) {
	let db = await createDatabase()
	let trans = db.transaction("worlds", "readwrite")
	let store = trans.objectStore("worlds")
	let req = store.delete(id)
	return new Promise((resolve, reject) => {
		req.onsuccess = function() {
			resolve(req.result)
		}
		req.onerror = function(e) {
			reject(e)
		}
	})
}



/***/ }),
/* 17 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shapes": () => (/* binding */ shapes)
/* harmony export */ });
function objectify(x, y, z, width, height, textureX, textureY) {
	return {
		x: x,
		y: y,
		z: z,
		w: width,
		h: height,
		tx: textureX,
		ty: textureY
	}
}
let shapes = {
	/*
		[
			[(-x, -z), (+x, -z), (+x, +z), (-x, +z)], // minX = 0,  minZ = 2,  maxX = 6, maxZ = 8
			[(-x, +z), (+x, +z), (+x, -z), (-x, -z)], // minX = 9,  minZ = 10, maxX = 3, maxZ = 4
			[(+x, +y), (-x, +y), (-x, -y), (+x, -y)], // minX = 6,  minY = 7,  maxX = 0, maxY = 1
			[(-x, +y), (+x, +y), (+x, -y), (-x, -y)], // minX = 9,  minY = 10, maxX = 3, maxY = 4
			[(+y, -z), (+y, +z), (-y, +z), (-y, -z)], // minY = 10, minZ = 11, maxY = 4, maxZ = 5
			[(+y, +z), (+y, -z), (-y, -z), (-y, +z)]  // minY = 7,  minZ = 8,  maxY = 1, maxZ = 2
		]
		*/
	cube: {
		verts: [
			// x, y, z, width, height, textureX, textureY
			// 0, 0, 0 is the corner on the top left of the texture
			[objectify( 0,  0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 16, 16, 16, 16, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify( 0, 16,  0, 16, 16, 0, 0)], //south
			[objectify(16, 16,  0, 16, 16, 0, 0)], //east
			[objectify( 0, 16, 16, 16, 16, 0, 0)]  //west
		],
		cull: {
			top: 3,
			bottom: 3,
			north: 3,
			south: 3,
			east: 3,
			west: 3
		},
		texVerts: [],
		varients: [],
		buffer: null,
		size: 6
	},
	slab: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 8, 16, 16, 16, 0, 0)], //top
			[objectify(16, 8, 16, 16, 8, 0, 0)], //north
			[objectify( 0, 8,  0, 16, 8, 0, 0)], //south
			[objectify(16, 8,  0, 16, 8, 0, 0)], //east
			[objectify( 0, 8, 16, 16, 8, 0, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 1,
			south: 1,
			east: 1,
			west: 1
		},
		texVerts: [],
		buffer: null,
		size: 6,
		varients: [],
		flip: true,
		rotate: false
	},
	stair: {
		verts: [
			[objectify( 0, 0,  0, 16, 16, 0, 0)], //bottom
			[objectify( 0, 8,  8, 16, 8, 0, 8), objectify( 0, 16,  16, 16, 8, 0, 0)], //top
			[objectify(16, 16, 16, 16, 16, 0, 0)], //north
			[objectify( 0, 8,  0, 16, 8, 0, 0), objectify( 0, 16,  8, 16, 8, 0, 0)], //south
			[objectify(16, 8, 0, 8, 8, 8, 0), objectify(16, 16, 8, 8, 16, 0, 0)], //east
			[objectify( 0, 8, 8, 8, 8, 0, 0), objectify( 0, 16, 16, 8, 16, 8, 0)]  //west
		],
		cull: {
			top: 0,
			bottom: 3,
			north: 3,
			south: 0,
			east: 0,
			west: 0
		},
		texVerts: [],
		buffer: null,
		size: 10,
		varients: [],
		flip: true,
		rotate: true
	},
}



/***/ }),
/* 18 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createProgramObject": () => (/* binding */ createProgramObject),
/* harmony export */   "uniformMatrix": () => (/* binding */ uniformMatrix),
/* harmony export */   "vertexAttribPointer": () => (/* binding */ vertexAttribPointer)
/* harmony export */ });
function createProgramObject(curContext, vetexShaderSource, fragmentShaderSource) {
	let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER)
	curContext.shaderSource(vertexShaderObject, vetexShaderSource)
	curContext.compileShader(vertexShaderObject)
	if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
		throw curContext.getShaderInfoLog(vertexShaderObject)
	}

	let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER)
	curContext.shaderSource(fragmentShaderObject, fragmentShaderSource)
	curContext.compileShader(fragmentShaderObject)
	if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
		throw curContext.getShaderInfoLog(fragmentShaderObject)
	}

	let programObject = curContext.createProgram()
	curContext.attachShader(programObject, vertexShaderObject)
	curContext.attachShader(programObject, fragmentShaderObject)
	curContext.linkProgram(programObject)
	if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
		throw "Error linking shaders."
	}

	return programObject
}

function uniformMatrix(gl, glCache, cacheId, programObj, vrName, transpose, matrix) {
	let vrLocation = glCache[cacheId]
	if(vrLocation === undefined) {
		vrLocation = gl.getUniformLocation(programObj, vrName)
		glCache[cacheId] = vrLocation
	}
	gl.uniformMatrix4fv(vrLocation, transpose, matrix)
}

function vertexAttribPointer(gl, glCache, cacheId, programObj, vrName, size, VBO) {
	let vrLocation = glCache[cacheId]
	if(vrLocation === undefined) {
		vrLocation = gl.getAttribLocation(programObj, vrName)
		glCache[cacheId] = vrLocation
	}
	if (vrLocation !== -1) {
		gl.enableVertexAttribArray(vrLocation)
		gl.bindBuffer(gl.ARRAY_BUFFER, VBO)
		gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0)

	}
}



/***/ }),
/* 19 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "initTextures": () => (/* binding */ initTextures),
/* harmony export */   "textureAtlas": () => (/* binding */ textureAtlas),
/* harmony export */   "textureCoords": () => (/* binding */ textureCoords),
/* harmony export */   "textureMap": () => (/* binding */ textureMap)
/* harmony export */ });
/* harmony import */ var _blockData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);


const textureMap = {}
const textureCoords = []

let dirtTexture
let textureAtlas

function initTextures(gl, glCache) {
	let textureSize = 256
	let scale = 1 / 16
	let texturePixels = new Uint8Array(textureSize * textureSize * 4)
	const setPixel = function(textureNum, x, y, r, g, b, a) {
		let texX = textureNum & 15
		let texY = textureNum >> 4
		let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4
		texturePixels[offset] = r
		texturePixels[offset + 1] = g
		texturePixels[offset + 2] = b
		texturePixels[offset + 3] = a !== undefined ? a : 255
	}

	const base256CharSet = '0123456789abcdefghijklmnopqrstuvwxyzABCDEF!#$%&L(MNO)*+,-./:;<=WSTR>Q?@[]P^_{|}~UVKGHXIJYZ'
	const base256DecodeMap = new Map()
	for (let i = 0; i < 256; i++) base256DecodeMap.set(base256CharSet[i], i)
	function decodeByte(str) {
		let num = 0
		for (let char of str) {
			num <<= 8
			num += base256DecodeMap.get(char)
		}
		return num
	}

	const getPixels = function(str, r = 255, g = 255, b = 255) {
		if (Array.isArray(r)) {
			[r, g, b] = r
		}
		const width = decodeByte(str.substr(0, 2))
		const height = decodeByte(str.substr(2, 2))
		const colorCount = decodeByte(str.substr(4, 1))
		const colors = []
		const pixels = new Uint8ClampedArray(width * height * 4)
		let pixi = 0
	
		for (let i = 0; i < colorCount; i++) {
			const num = decodeByte(str.substr(5 + i * 3, 3))
	
			let alpha = (num & 63) << 2
			let blue  = (num >>> 6 & 63) << 2
			let green = (num >>> 12 & 63) << 2
			let red   = (num >>> 18 & 63) << 2
			if (alpha >= 240) alpha = 255 // Make sure we didn't accidentally make the texture transparent
	
			if (red === blue && red === green) {
				red = red / 252 * r | 0
				green = green / 252 * g | 0
				blue = blue / 252 * b | 0
			}
			colors.push([ red, green, blue, alpha ])
		}
	
		// Special case for a texture filled with 1 pixel color
		if (colorCount === 1) {
			while (pixi < pixels.length) {
				pixels[pixi + 0] = colors[0][0]
				pixels[pixi + 1] = colors[0][1]
				pixels[pixi + 2] = colors[0][2]
				pixels[pixi + 3] = colors[0][3]
				pixi += 4
			}
			return pixels
		}
	
		let bytes = []
		for (let i = 5 + colorCount * 3; i < str.length; i++) { // Load the bit-packed index array
			const byte = decodeByte(str[i])
			bytes.push(byte)
		}
	
		const bits = Math.ceil(Math.log2(colorCount))
		const bitMask = (1 << bits) - 1
		let filledBits = 8
		let byte = bytes.shift()
		while (bytes.length || filledBits) {
			let num = 0
			if (filledBits >= bits) { // The entire number is inside the byte
				num = byte >> (filledBits - bits) & bitMask
				if (filledBits === bits && bytes.length) {
					byte = bytes.shift()
					filledBits = 8
				}
				else filledBits -= bits
			}
			else {
				num = byte << (bits - filledBits) & bitMask // Only part of the number is in the byte
				byte = bytes.shift() // Load in the next byte
				num |= byte >> (8 - bits + filledBits) // Apply the rest of the number from this byte
				filledBits += 8 - bits
			}
	
			pixels[pixi + 0] = colors[num][0]
			pixels[pixi + 1] = colors[num][1]
			pixels[pixi + 2] = colors[num][2]
			pixels[pixi + 3] = colors[num][3]
			pixi += 4
		}
		return pixels
	}

	const textures = (0,_blockData_js__WEBPACK_IMPORTED_MODULE_0__.texturesFunc)(setPixel, getPixels);

	{
		// Specify the texture coords for each index
		const s = scale
		for (let i = 0; i < 256; i++) {
			let texX = i & 15
			let texY = i >> 4
			let offsetX = texX * s
			let offsetY = texY * s
			textureCoords.push(new Float32Array([offsetX, offsetY, offsetX + s, offsetY, offsetX + s, offsetY + s, offsetX, offsetY + s]))
		}

		// Set all of the textures into 1 big tiled texture
		let n = 0
		for (let name in textures) {
			if (typeof textures[name] === "function") {
				textures[name](n)
			}
			else if (typeof textures[name] === "string") {
				let pix = name.includes("water") ?
				getPixels(textures[name], 40, 100, 220) :
				getPixels(textures[name])
				for (let j = 0; j < pix.length; j += 4) {
					setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3])
				}
			}
			textureMap[name] = n
			n++
		}

		//Set the hitbox texture to 1 pixel
		let arr = new Float32Array(192)
		for (let i = 0; i < 192; i += 2) {
			arr[i] = textureCoords[textureMap.hitbox][0] + 0.01
			arr[i + 1] = textureCoords[textureMap.hitbox][1] + 0.01
		}
		textureCoords[textureMap.hitbox] = arr
	}

	// Big texture with everything in it
	textureAtlas = gl.createTexture()
	gl.activeTexture(gl.TEXTURE0)
	gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels)
	gl.generateMipmap(gl.TEXTURE_2D)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
	gl.uniform1i(glCache.uSampler, 0)

	// Dirt texture for the background
	let dirtPixels = new Uint8Array(getPixels(textures.dirt))
	dirtTexture = gl.createTexture()
	gl.activeTexture(gl.TEXTURE1)
	gl.bindTexture(gl.TEXTURE_2D, dirtTexture)
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, dirtPixels)
	gl.generateMipmap(gl.TEXTURE_2D)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT)
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT)
}



/***/ }),
/* 20 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Section": () => (/* binding */ Section),
/* harmony export */   "emptySection": () => (/* binding */ emptySection),
/* harmony export */   "fullSection": () => (/* binding */ fullSection),
/* harmony export */   "noiseSettings": () => (/* binding */ noiseSettings)
/* harmony export */ });
/* harmony import */ var _blockData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);



function getBlock(x, y, z, blocks) {
	return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)]
}

// this will be modified once exported to be
// open simplex noise
let noiseSettings = {};

// Save the coords for a small sphere used to carve out caves
let sphere;
{
	let blocks = []
	let radius = 3.5
	let radsq = radius * radius
	for (let i = -radius; i <= radius; i++) {
		for (let j = -radius; j <= radius; j++) {
			for (let k = -radius; k <= radius; k++) {
				if (i*i + j*j + k*k < radsq) {
					blocks.push(i|0, j|0, k|0)
				}
			}
		}
	}
	sphere = new Int8Array(blocks)
}

function carveSphere(x, y, z, world) {
	if (y > 3) {
		for (let i = 0; i < sphere.length; i += 3) {
			world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockIds.air, true)
		}
	}
}

/**
 * Returns a 1 if the face is exposed and should be drawn, or a 0 if the face is hidden
 *
 * @param {number} x - The X coordinate of the block that may be covering a face
 * @param {number} y - The Y coordinate of the block that may be covering a face
 * @param {number} z - The Z coordinate of the block that may be covering a face
 * @param {Collection} blocks - Some collection of blocks that can return the block at (x, y, z)
 * @param {number} type - The blockstate of the block that's being considered for face culling
 * @param {function} func - The function that can be called to return a block from the blocks collection
 * @param {World} world - the world
*/
function hideFace(x, y, z, blocks, type, func, sourceDir, dir, world, screen) {
	let block = func.call(world, x, y, z, blocks)
	if (!block) {
		return 1
	}

	let data = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[block]
	let sourceData = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[type]

	let sourceRange = 3
	let hiderRange = 3
	if (func !== getBlock || screen === "loading") {
		// getBlock is only used during the optimize phase of worldGen
		sourceRange = sourceData.shape.cull[sourceDir]
		hiderRange = data.shape.cull[dir]
	}

	if ((sourceRange & hiderRange) !== sourceRange || sourceRange === 0 || block !== type && data.transparent || data.transparent && data.shadow) {
		return 1
	}
	return 0
}

let getShadows = {
	shade: [1, 0.85, 0.7, 0.6, 0.3],
	ret: [],
	blocks: [],
	top: function(x, y, z, block) { // Actually the bottom... How did these get flipped?
		let blocks = this.blocks
		let ret = this.ret
		blocks[0] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z-1, block)].shadow
		blocks[1] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y-1, z-1, block)].shadow
		blocks[2] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z-1, block)].shadow
		blocks[3] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z, block)].shadow
		blocks[4] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y-1, z, block)].shadow
		blocks[5] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z, block)].shadow
		blocks[6] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z+1, block)].shadow
		blocks[7] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y-1, z+1, block)].shadow
		blocks[8] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z+1, block)].shadow

		ret[0] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.75
		ret[1] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.75
		ret[2] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.75
		ret[3] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.75
		return ret
	},
	bottom: function(x, y, z, block) { // Actually the top
		let blocks = this.blocks
		let ret = this.ret
		blocks[0] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z-1, block)].shadow
		blocks[1] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y+1, z-1, block)].shadow
		blocks[2] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z-1, block)].shadow
		blocks[3] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z, block)].shadow
		blocks[4] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y+1, z, block)].shadow
		blocks[5] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z, block)].shadow
		blocks[6] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z+1, block)].shadow
		blocks[7] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y+1, z+1, block)].shadow
		blocks[8] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z+1, block)].shadow

		ret[0] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]
		ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]
		ret[2] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]
		ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]
		return ret
	},
	north: function(x, y, z, block) {
		let blocks = this.blocks
		let ret = this.ret
		blocks[0] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z+1, block)].shadow
		blocks[1] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y-1, z+1, block)].shadow
		blocks[2] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z+1, block)].shadow
		blocks[3] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y, z+1, block)].shadow
		blocks[4] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y, z+1, block)].shadow
		blocks[5] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y, z+1, block)].shadow
		blocks[6] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z+1, block)].shadow
		blocks[7] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y+1, z+1, block)].shadow
		blocks[8] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z+1, block)].shadow

		ret[0] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
		ret[1] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
		ret[2] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
		ret[3] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
		return ret
	},
	south: function(x, y, z, block) {
		let blocks = this.blocks
		let ret = this.ret
		blocks[0] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z-1, block)].shadow
		blocks[1] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y, z-1, block)].shadow
		blocks[2] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z-1, block)].shadow
		blocks[3] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y-1, z-1, block)].shadow
		blocks[4] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y, z-1, block)].shadow
		blocks[5] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x, y+1, z-1, block)].shadow
		blocks[6] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z-1, block)].shadow
		blocks[7] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y, z-1, block)].shadow
		blocks[8] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z-1, block)].shadow

		ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.95
		ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.95
		ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.95
		ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.95
		return ret
	},
	east: function(x, y, z, block) {
		let blocks = this.blocks
		let ret = this.ret
		blocks[0] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z-1, block)].shadow
		blocks[1] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y, z-1, block)].shadow
		blocks[2] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z-1, block)].shadow
		blocks[3] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z, block)].shadow
		blocks[4] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y, z, block)].shadow
		blocks[5] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z, block)].shadow
		blocks[6] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y-1, z+1, block)].shadow
		blocks[7] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y, z+1, block)].shadow
		blocks[8] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x+1, y+1, z+1, block)].shadow

		ret[0] = this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8
		ret[1] = this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8
		ret[2] = this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8
		ret[3] = this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8
		return ret
	},
	west: function(x, y, z, block) {
		let blocks = this.blocks
		let ret = this.ret
		blocks[0] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z-1, block)].shadow
		blocks[1] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y, z-1, block)].shadow
		blocks[2] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z-1, block)].shadow
		blocks[3] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z, block)].shadow
		blocks[4] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y, z, block)].shadow
		blocks[5] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z, block)].shadow
		blocks[6] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y-1, z+1, block)].shadow
		blocks[7] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y, z+1, block)].shadow
		blocks[8] = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[getBlock(x-1, y+1, z+1, block)].shadow

		ret[0] = this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8
		ret[1] = this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8
		ret[2] = this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8
		ret[3] = this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8
		return ret
	},
}

const { abs, max } = Math

function average(l, a, b, c, d) {
	a = l[a]
	b = l[b]
	c = l[c]
	d = l[d]
	let count = 1
	let zero = 0
	let total = a
	if (b && abs(a-b) <= 2) {
		total += b
		count++
	}
	else zero++
	if (c && abs(a-c) <= 2) {
		total += c
		count++
	}
	else zero++
	if (d && abs(a-d) <= 2) {
		total += d
		count++
	}
	else zero++

	let mx = max(a, b, c, d)
	if (mx > 2) {
		return total / (count * 15)
	}
	if (mx > 1) {
		return zero ? total / (count * 15 + 15) : total / (count * 15)
	}
	return total / 60
}

let getLight = {
	blocks: [],
	top: function(x, y, z, block, ret, blockLight = 0) { // Actually the bottom... How did these get flipped?
		let blocks = this.blocks
		blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[1] = (getBlock(x, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[2] = (getBlock(x+1, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[4] = (getBlock(x, y-1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[5] = (getBlock(x+1, y-1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[7] = (getBlock(x, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[8] = (getBlock(x+1, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4

		ret[0] = average(blocks, 4, 0, 1, 3)
		ret[1] = average(blocks, 4, 1, 2, 5)
		ret[2] = average(blocks, 4, 5, 7, 8)
		ret[3] = average(blocks, 4, 3, 6, 7)
		// debugger
		return ret
	},
	bottom: function(x, y, z, block, ret, blockLight = 0) { // Actually the top
		let blocks = this.blocks
		blocks[0] = (getBlock(x-1, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[1] = (getBlock(x, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[3] = (getBlock(x-1, y+1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[4] = (getBlock(x, y+1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4

		ret[0] = average(blocks, 4, 3, 6, 7)
		ret[1] = average(blocks, 4, 5, 7, 8)
		ret[2] = average(blocks, 4, 1, 2, 5)
		ret[3] = average(blocks, 4, 0, 1, 3)
		return ret
	},
	north: function(x, y, z, block, ret, blockLight = 0) {
		let blocks = this.blocks
		blocks[0] = (getBlock(x-1, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[1] = (getBlock(x, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[2] = (getBlock(x+1, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[3] = (getBlock(x-1, y, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[4] = (getBlock(x, y, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[5] = (getBlock(x+1, y, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[6] = (getBlock(x-1, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[7] = (getBlock(x, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4

		ret[0] = average(blocks, 4, 5, 7, 8)
		ret[1] = average(blocks, 4, 3, 6, 7)
		ret[2] = average(blocks, 4, 0, 1, 3)
		ret[3] = average(blocks, 4, 1, 2, 5)
		return ret
	},
	south: function(x, y, z, block, ret, blockLight = 0) {
		let blocks = this.blocks
		blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[3] = (getBlock(x, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[4] = (getBlock(x, y, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[5] = (getBlock(x, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[6] = (getBlock(x+1, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[7] = (getBlock(x+1, y, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[8] = (getBlock(x+1, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4

		ret[0] = average(blocks, 4, 1, 2, 5)
		ret[1] = average(blocks, 4, 5, 7, 8)
		ret[2] = average(blocks, 4, 3, 6, 7)
		ret[3] = average(blocks, 4, 0, 1, 3)
		return ret
	},
	east: function(x, y, z, block, ret, blockLight = 0) {
		let blocks = this.blocks
		blocks[0] = (getBlock(x+1, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[1] = (getBlock(x+1, y, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[2] = (getBlock(x+1, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[3] = (getBlock(x+1, y-1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[4] = (getBlock(x+1, y, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[5] = (getBlock(x+1, y+1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[6] = (getBlock(x+1, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[7] = (getBlock(x+1, y, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[8] = (getBlock(x+1, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4

		ret[0] = average(blocks, 4, 1, 2, 5)
		ret[1] = average(blocks, 4, 5, 7, 8)
		ret[2] = average(blocks, 4, 3, 6, 7)
		ret[3] = average(blocks, 4, 0, 1, 3)
		return ret
	},
	west: function(x, y, z, block, ret, blockLight = 0) {
		let blocks = this.blocks
		blocks[0] = (getBlock(x-1, y-1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[1] = (getBlock(x-1, y, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[2] = (getBlock(x-1, y+1, z-1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[3] = (getBlock(x-1, y-1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[4] = (getBlock(x-1, y, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[5] = (getBlock(x-1, y+1, z, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[6] = (getBlock(x-1, y-1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[7] = (getBlock(x-1, y, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4
		blocks[8] = (getBlock(x-1, y+1, z+1, block) & 0xf << blockLight * 4) >> blockLight * 4

		ret[0] = average(blocks, 4, 5, 7, 8)
		ret[1] = average(blocks, 4, 1, 2, 5)
		ret[2] = average(blocks, 4, 0, 1, 3)
		ret[3] = average(blocks, 4, 3, 6, 7)
		return ret
	},
}

class Section {
	constructor(x, y, z, size, chunk, caves, world) {
		this.x = x
		this.y = y
		this.z = z
		this.size = size
		this.arraySize = size * size * size
		this.blocks = new Int32Array(this.arraySize)
		this.light = new Uint8Array(this.arraySize)
		this.renderData = []
		this.renderLength = 0
		this.faces = 0
		this.hasVisibleBlocks = false
		this.chunk = chunk
		this.edited = false
		this.caves = !caves
		this.pallete = [0]
		this.palleteMap = { "0": 0 }
		this.palleteSize = 0
		this.world = world
	}
	getBlock(x, y, z) {
		let s = this.size
		return this.blocks[x * s * s + y * s + z]
	}
	setBlock(x, y, z, blockId) {
		let s = this.size
		this.blocks[x * s * s + y * s + z] = blockId
	}
	deleteBlock(x, y, z) {
		let s = this.size
		this.blocks[x * s * s + y * s + z] = 0
	}
	optimize(screen) {
		const { world } = this
		let visible = false
		let pos = 0
		let xx = this.x
		let yy = this.y
		let zz = this.z
		let blockState = 0
		let palleteIndex = 0
		let index = 0
		let s = this.size
		let blocks = this.blocks
		this.hasVisibleBlocks = false
		this.renderLength = 0
		let localBlocks = world.getAdjacentSubchunks(xx, yy, zz)

		//Check all the blocks in the subchunk to see if they're visible.
		for (let i = 0; i < s; i++) {
			for (let j = 0; j < s; j++) {
				for (let k = 0; k < s; k++, index++) {
					blockState = blocks[index]

					if (this.palleteMap[blockState] === undefined) {
						this.palleteMap[blockState] = this.pallete.length
						palleteIndex = this.pallete.length
						this.pallete.push(blockState)
					}
					else {
						palleteIndex = this.palleteMap[blockState]
					}

					visible = blockState && hideFace(i-1, j, k, localBlocks, blockState, getBlock, "west", "east", world, screen)
					| hideFace(i+1, j, k, localBlocks, blockState, getBlock, "east", "west", world, screen) << 1
					| hideFace(i, j-1, k, localBlocks, blockState, getBlock, "bottom", "top", world, screen) << 2
					| hideFace(i, j+1, k, localBlocks, blockState, getBlock, "top", "bottom", world, screen) << 3
					| hideFace(i, j, k-1, localBlocks, blockState, getBlock, "south", "north", world, screen) << 4
					| hideFace(i, j, k+1, localBlocks, blockState, getBlock, "north", "south", world, screen) << 5
					if (visible) {
						pos = (i | j << 4 | k << 8) << 19
						this.renderData[this.renderLength++] = 1 << 31 | pos | visible << 13 | palleteIndex
						this.hasVisibleBlocks = true
					}
				}
			}
		}
	}
	updateBlock(x, y, z, world, screen) {
		if (!world.meshQueue.includes(this.chunk)) {
			world.meshQueue.push(this.chunk)
		}
		let i = x
		let j = y
		let k = z
		let s = this.size
		x += this.x
		y += this.y
		z += this.z
		let blockState = this.blocks[i * s * s + j * s + k]
		let visible = blockState && hideFace(x-1, y, z, 0, blockState, world.getBlock, "west", "east", world, screen)
		| hideFace(x+1, y, z, 0, blockState, world.getBlock, "east", "west", world, screen) << 1
		| hideFace(x, y-1, z, 0, blockState, world.getBlock, "bottom", "top", world, screen) << 2
		| hideFace(x, y+1, z, 0, blockState, world.getBlock, "top", "bottom", world, screen) << 3
		| hideFace(x, y, z-1, 0, blockState, world.getBlock, "south", "north", world, screen) << 4
		| hideFace(x, y, z+1, 0, blockState, world.getBlock, "north", "south", world, screen) << 5
		let pos = (i | j << 4 | k << 8) << 19
		let index = -1

		// Find index of current block in this.renderData
		for (let i = 0; i < this.renderLength; i++) {
			if ((this.renderData[i] & 0x7ff80000) === pos) {
				index = i
				break
			}
		}

		// Update pallete
		if (this.palleteMap[blockState] === undefined) {
			this.palleteMap[blockState] = this.pallete.length
			this.pallete.push(blockState)
		}

		if (index < 0 && !visible) {
			// Wasn't visible before, isn't visible after.
			return
		}
		if (!visible) {
			// Was visible before, isn't visible after.
			this.renderData.splice(index, 1)
			this.renderLength--
			this.hasVisibleBlocks = !!this.renderLength
			return
		}
		if (visible && index < 0) {
			// Wasn't visible before, is visible after.
			index = this.renderLength++
			this.hasVisibleBlocks = true
		}
		this.renderData[index] = 1 << 31 | pos | visible << 13 | this.palleteMap[blockState]
	}
	genMesh(barray, index) {
		const { world } = this
		if (!this.renderLength) {
			return index
		}
		let length = this.renderLength
		let rData = this.renderData
		let x = 0, y = 0, z = 0, loc = 0, data = 0,
			sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0,
			verts = null, texVerts = null, texShapeVerts = null,
			tx = 0, ty = 0
		let wx = this.x, wy = this.y, wz = this.z
		let blocks = world.getAdjacentSubchunks(wx, wy, wz)
		let lightChunks = world.getAdjacentSubchunks(wx, wy, wz, true)
		let block = null

		let shadows = null, slights = [0, 0, 0, 0], blights = [0, 0, 0, 0]
		let blockSides = Object.keys(_blockData_js__WEBPACK_IMPORTED_MODULE_0__.Block)
		let side = ""
		let shapeVerts = null
		let shapeTexVerts = null
		let pallete = this.pallete
		// let intShad = interpolateShadows

		for (let i = 0; i < length; i++) {
			data = rData[i]
			block = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[pallete[data & 0x1fff]]
			tex = block.textures
			sides = data >> 13 & 0x3f
			loc = data >> 19 & 0xfff
			x = loc & 15
			y = loc >> 4 & 15
			z = loc >> 8 & 15

			x2 = x + this.x
			y2 = y + this.y
			z2 = z + this.z

			shapeVerts = block.shape.verts
			shapeTexVerts = block.shape.texVerts

			let texNum = 0
			for (let n = 0; n < 6; n++) {
				side = blockSides[n]
				if (sides & _blockData_js__WEBPACK_IMPORTED_MODULE_0__.Block[side]) {
					shadows = getShadows[side](x, y, z, blocks)
					slights = getLight[side](x, y, z, lightChunks, slights, 0)
					blights = getLight[side](x, y, z, lightChunks, blights, 1)
					let directionalFaces = shapeVerts[_blockData_js__WEBPACK_IMPORTED_MODULE_0__.Sides[side]]
					for (let facei = 0; facei < directionalFaces.length; facei++) {
						verts = directionalFaces[facei]
						texVerts = _texture_js__WEBPACK_IMPORTED_MODULE_1__.textureCoords[_texture_js__WEBPACK_IMPORTED_MODULE_1__.textureMap[tex[texNum]]]
						tx = texVerts[0]
						ty = texVerts[1]
						texShapeVerts = shapeTexVerts[n][facei]

						barray[index] = verts[0] + x2
						barray[index+1] = verts[1] + y2
						barray[index+2] = verts[2] + z2
						barray[index+3] = tx + texShapeVerts[0]
						barray[index+4] = ty + texShapeVerts[1]
						barray[index+5] = shadows[0]
						barray[index+6] = slights[0]
						barray[index+7] = blights[0]

						barray[index+8] = verts[3] + x2
						barray[index+9] = verts[4] + y2
						barray[index+10] = verts[5] + z2
						barray[index+11] = tx + texShapeVerts[2]
						barray[index+12] = ty + texShapeVerts[3]
						barray[index+13] = shadows[1]
						barray[index+14] = slights[1]
						barray[index+15] = blights[1]

						barray[index+16] = verts[6] + x2
						barray[index+17] = verts[7] + y2
						barray[index+18] = verts[8] + z2
						barray[index+19] = tx + texShapeVerts[4]
						barray[index+20] = ty + texShapeVerts[5]
						barray[index+21] = shadows[2]
						barray[index+22] = slights[2]
						barray[index+23] = blights[2]

						barray[index+24] = verts[9] + x2
						barray[index+25] = verts[10] + y2
						barray[index+26] = verts[11] + z2
						barray[index+27] = tx + texShapeVerts[6]
						barray[index+28] = ty + texShapeVerts[7]
						barray[index+29] = shadows[3]
						barray[index+30] = slights[3]
						barray[index+31] = blights[3]
						index += 32
					}
				}
				texNum++
			}
		}
		return index
	}
	async carveCaves() {
		const { world } = this
		while (!window.workers.length) {
			await Promise.race(window.pendingWorkers)
		}
		const data = await window.doWork({
			caves: true,
			x: this.x,
			y: this.y,
			z: this.z
		})
		const caves = data.caves

		let sx = this.x, sy = this.y, sz = this.z
		let cy = 0
		for (let x = 0; x < 16; x++) {
			for (let z = 0; z < 16; z++) {
				cy = this.chunk.tops[z * 16 + x]
				cy = cy > sy + 15 ? 16 : cy & 15
				for (let y = 0; y < cy; y++) {
					if (caves[x * 256 + y * 16 + z]) {
						carveSphere(sx + x, sy + y, sz + z, world)
					}
				}
			}
		}
		this.caves = true
	}
	tick() {
		const { world } = this
		for (let i = 0; i < 3; i++) {
			let rnd = Math.random() * this.blocks.length | 0
			if (this.blocks[rnd] === _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockIds.grass) {
				// Spread grass

				let x = (rnd >> 8) + this.x
				let y = (rnd >> 4 & 15) + this.y
				let z = (rnd & 15) + this.z
				if (!_blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[world.getBlock(x, y + 1, z)].transparent) {
					world.setBlock(x, y, z, _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockIds.dirt, false)
					return
				}

				let rnd2 = Math.random() * 27 | 0
				let x2 = rnd2 % 3 - 1
				rnd2 = (rnd2 - x2 - 1) / 3
				let y2 = rnd2 % 3 - 1
				rnd2 = (rnd2 - y2 - 1) / 3
				z += rnd2 - 1
				x += x2
				y += y2

				if (world.getBlock(x, y, z) === _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockIds.dirt && world.getBlock(x, y + 1, z) === _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockIds.air) {
					world.setBlock(x, y, z, _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockIds.grass, false)
				}
			}
		}
	}
	getLight(x, y, z, block = 0) {
		let s = this.size
		let i = x * s * s + y * s + z
		return (this.light[i] & 15 << block * 4) >> block * 4
	}
	setLight(x, y, z, level, block = 0) {
		let s = this.size
		let i = x * s * s + y * s + z
		this.light[i] = level << block * 4 | this.light[i] & 15 << !block * 4
	}
	setWorld(world) {
		this.world = world
	}
	setCaves(caves) {
		this.caves = caves
	}
}

let emptySection = new Section(0, 0, 0, 16, null, null)
let fullSection = new Section(0, 0, 0, 16, null, null)

fullSection.blocks.fill(_blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockIds.bedrock)
emptySection.light.fill(15)



/***/ }),
/* 21 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Chunk": () => (/* binding */ Chunk)
/* harmony export */ });
/* harmony import */ var _random_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);
/* harmony import */ var _blockData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);
/* harmony import */ var _section_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(20);




const { floor, min, max } = Math;

class Chunk {
	constructor(x, z, world, glExtensions, gl, glCache, superflat, caves) {
		this.x = x
		this.z = z
		this.maxY = 0
		this.minY = 255
		this.sections = []
		this.cleanSections = []
		this.tops = new Uint8Array(16 * 16) // Store the heighest block at every (x,z) coordinate
		this.optimized = false
		this.generated = false; // Terrain
		this.populated = superflat // Trees and ores
		this.lit = false
		this.lazy = false
		this.edited = false
		this.loaded = false
		// vao for this chunk
		this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
		this.caves = !caves
		this.world = world
		this.gl = gl
		this.glCache = glCache
		this.glExtensions = glExtensions
		this.doubleRender = false
	}
	getBlock(x, y, z) {
		let s = y >> 4
		return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0
	}
	setBlock(x, y, z, blockID, user) {
		if (!this.sections[y >> 4]) {
			do {
				this.sections.push(new _section_js__WEBPACK_IMPORTED_MODULE_2__.Section(this.x, this.sections.length * 16, this.z, 16, this, !this.caves, this.world))
			} while (!this.sections[y >> 4])
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
			this.sections[y >> 4].edited = true
			this.edited = true
		}
		if (_blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockData[blockID].semiTrans) {
			this.doubleRender = true
			if (!this.world.doubleRenderChunks.includes(this)) {
				this.world.doubleRenderChunks.push(this)
			}
		}
		this.sections[y >> 4].setBlock(x, y & 15, z, blockID)
	}
	fillLight() {
		let max = this.sections.length * 16 - 1
		let blockSpread = []

		// Set virtical columns of light to level 15
		for (let x = 0; x < 16; x++) {
			for (let z = 0; z < 16; z++) {
				let stop = false
				for (let y = max; y >= 0; y--) {
					let data = _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockData[this.getBlock(x, y, z)]
					if (data.lightLevel) {
						if (!blockSpread[data.lightLevel]) blockSpread[data.lightLevel] = []
						blockSpread[data.lightLevel].push(x + this.x, y, z + this.z)
						this.setLight(x, y, z, data.lightLevel, 1)
					}
					if (!stop && !data.transparent) {
						this.tops[z * 16 + x] = y
						stop = true
					}
					else if (!stop) {
						this.setLight(x, y, z, 15, 0)
					}
				}
			}
		}

		// Spread the light to places where the virtical columns stopped earlier, plus chunk borders
		let spread = []
		for (let x = 0; x < 16; x++) {
			for (let z = 0; z < 16; z++) {
				for (let y = this.tops[z * 16 + x] + 1; y <= max; y++) {
					if (x === 15 || this.tops[z * 16 + x + 1] > y) {
						spread.push(x + this.x, y, z + this.z)
						continue
					}
					if (x === 0 || this.tops[z * 16 + x - 1] > y) {
						spread.push(x + this.x, y, z + this.z)
						continue
					}
					if (z === 15 || this.tops[(z + 1) * 16 + x] > y) {
						spread.push(x + this.x, y, z + this.z)
						continue
					}
					if (z === 0 || this.tops[(z - 1) * 16 + x] > y) {
						spread.push(x + this.x, y, z + this.z)
						continue
					}
					break
				}
			}
		}
		this.spreadLight(spread, 14)

		for (let i = blockSpread.length - 1; i > 0; i--) {
			let blocks = blockSpread[i]
			if (blocks && blocks.length) {
				this.spreadLight(blocks, i - 1, false, 1)
			}
		}

		this.lit = true
	}
	setLight(x, y, z, level, blockLight) {
		if (y < this.sections.length * 16) {
			this.sections[y >> 4].setLight(x, y & 15, z, level, blockLight)
		}
	}
	getLight(x, y, z, blockLight = 0) {
		if (y >= this.sections.length * 16) return 15
		return this.sections[y >> 4].getLight(x, y & 15, z, blockLight)
	}
	trySpread(x, y, z, level, spread, blockLight, update = false) {
		const { world } = this
		if (world.getLight(x, y, z, blockLight) < level) {
			if (_blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockData[world.getBlock(x, y, z)].transparent) {
				world.setLight(x, y, z, level, blockLight)
				spread.push(x, y, z)
			}
		}
		if (update && (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15)) {
			let chunk = world.getChunk(x, z)
			if (chunk.buffer && !world.meshQueue.includes(chunk)) {
				world.meshQueue.push(chunk)
			}
		}
	}
	spreadLight(blocks, level, update = false, blockLight = 0) {
		let spread = []
		let x = 0, y = 0, z = 0
		for (let i = 0; i < blocks.length; i += 3) {
			x = blocks[i]
			y = blocks[i+1]
			z = blocks[i+2]
			this.trySpread(x - 1, y, z, level, spread, blockLight, update)
			this.trySpread(x + 1, y, z, level, spread, blockLight, update)
			this.trySpread(x, y - 1, z, level, spread, blockLight, update)
			this.trySpread(x, y + 1, z, level, spread, blockLight, update)
			this.trySpread(x, y, z - 1, level, spread, blockLight, update)
			this.trySpread(x, y, z + 1, level, spread, blockLight, update)
		}
		if (level > 1 && spread.length) {
			this.spreadLight(spread, level - 1, update, blockLight)
		}
	}
	tryUnSpread(x, y, z, level, spread, respread, blockLight) {
		const { world } = this
		let light = world.getLight(x, y, z, blockLight)
		let trans = _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockData[world.getBlock(x, y, z)].transparent
		if (light === level) {
			if (trans) {
				world.setLight(x, y, z, 0, blockLight)
				spread.push(x, y, z)
			}
		}
		else if (light > level) {
			respread[light].push(x, y, z)
		}
		if (x < this.x || x > this.x + 15 || z < this.z || z > this.z + 15) {
			let chunk = world.getChunk(x, z)
			if (chunk && chunk.buffer && !world.meshQueue.includes(chunk)) {
				world.meshQueue.push(chunk)
			}
		}
	}
	unSpreadLight(blocks, level, respread, blockLight) {
		let spread = []
		let x = 0, y = 0, z = 0
		for (let i = 0; i < blocks.length; i += 3) {
			x = blocks[i]
			y = blocks[i+1]
			z = blocks[i+2]
			this.tryUnSpread(x - 1, y, z, level, spread, respread, blockLight)
			this.tryUnSpread(x + 1, y, z, level, spread, respread, blockLight)
			this.tryUnSpread(x, y - 1, z, level, spread, respread, blockLight)
			this.tryUnSpread(x, y + 1, z, level, spread, respread, blockLight)
			this.tryUnSpread(x, y, z - 1, level, spread, respread, blockLight)
			this.tryUnSpread(x, y, z + 1, level, spread, respread, blockLight)
		}
		if (level > 1 && spread.length) {
			this.unSpreadLight(spread, level - 1, respread, blockLight)
		}
	}
	reSpreadLight(respread, blockLight) {
		for (let i = respread.length - 1; i > 1; i--) {
			let blocks = respread[i]
			let level = i - 1
			let spread = respread[level]
			for (let j = 0; j < blocks.length; j += 3) {
				let x = blocks[j]
				let y = blocks[j+1]
				let z = blocks[j+2]
				this.trySpread(x - 1, y, z, level, spread, blockLight)
				this.trySpread(x + 1, y, z, level, spread, blockLight)
				this.trySpread(x, y - 1, z, level, spread, blockLight)
				this.trySpread(x, y + 1, z, level, spread, blockLight)
				this.trySpread(x, y, z - 1, level, spread, blockLight)
				this.trySpread(x, y, z + 1, level, spread, blockLight)
			}
		}
	}
	optimize(screen) {
		const { world } = this
		for (let i = 0; i < this.sections.length; i++) {
			this.sections[i].optimize(screen)
		}
		if (!world.meshQueue.includes(this)) {
			world.meshQueue.push(this)
		}
		this.optimized = true
	}
	render(p, global) {
		const { glExtensions, gl } = this
		if (this.buffer === undefined) {
			return
		}
		if (p.canSee(this.x, this.minY, this.z, this.maxY)) {
			global.renderedChunks++
			glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
			glExtensions.vertex_array_object.bindVertexArrayOES(null)
		}
	}
	updateBlock(x, y, z, world, lazy, screen) {
		if (this.buffer) {
			this.lazy = lazy
			if (this.sections.length > y >> 4) {
				this.sections[y >> 4].updateBlock(x, y & 15, z, world, screen)
			}
		}
	}
	deleteBlock(x, y, z, user) {
		if (!this.sections[y >> 4]) {
			return
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice()
			this.sections[y >> 4].edited = true
			this.edited = true
		}
		this.sections[y >> 4].deleteBlock(x, y & 15, z)
		this.minY = y < this.minY ? y : this.minY
		this.maxY = y > this.maxY ? y : this.maxY
	}
	async carveCaves() {
		let promises = []
		for (let i = 0; i < this.sections.length; i++) {
			if (!this.sections[i].caves) {
				promises.push(this.sections[i].carveCaves())
			}
		}
		await Promise.all(promises)
		this.caves = true
	}
	populate(trees) {
		const { world } = this
		;(0,_random_js__WEBPACK_IMPORTED_MODULE_0__.randomSeed)((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.hash)(this.x, this.z) * 210000000)
		let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false

		for (let i = 0; i < 16; i++) {
			for (let k = 0; k < 16; k++) {
				wx = this.x + i
				wz = this.z + k

				ground = this.tops[k * 16 + i]
				if (trees && (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 0.005 && this.getBlock(i, ground, k) === _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.grass) {

					top = ground + floor(4.5 + (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)(2.5))
					rand = floor((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)(4096))
					let tree = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 0.6 ? _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.oakLog : ++top && _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.birchLog

					//Center
					for (let j = ground + 1; j <= top; j++) {
						this.setBlock(i, j, k, tree)
					}
					this.setBlock(i, top + 1, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
					this.setBlock(i, ground, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.dirt)

					//Bottom leaves
					for (let x = -2; x <= 2; x++) {
						for (let z = -2; z <= 2; z++) {
							if (x || z) {
								if ((x * z & 7) === 4) {
									place = rand & 1
									rand >>>= 1
									if (place) {
										world.spawnBlock(wx + x, top - 2, wz + z, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
									}
								}
								else {
									world.spawnBlock(wx + x, top - 2, wz + z, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
								}
							}
						}
					}

					//2nd layer leaves
					for (let x = -2; x <= 2; x++) {
						for (let z = -2; z <= 2; z++) {
							if (x || z) {
								if ((x * z & 7) === 4) {
									place = rand & 1
									rand >>>= 1
									if (place) {
										world.spawnBlock(wx + x, top - 1, wz + z, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
									}
								}
								else {
									world.spawnBlock(wx + x, top - 1, wz + z, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
								}
							}
						}
					}

					//3rd layer leaves
					for (let x = -1; x <= 1; x++) {
						for (let z = -1; z <= 1; z++) {
							if (x || z) {
								if (x & z) {
									place = rand & 1
									rand >>>= 1
									if (place) {
										world.spawnBlock(wx + x, top, wz + z, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
									}
								}
								else {
									world.spawnBlock(wx + x, top, wz + z, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
								}
							}
						}
					}

					//Top leaves
					world.spawnBlock(wx + 1, top + 1, wz, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
					world.spawnBlock(wx, top + 1, wz - 1, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
					world.spawnBlock(wx, top + 1, wz + 1, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
					world.spawnBlock(wx - 1, top + 1, wz, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.leaves)
				}

				// Blocks of each per chunk in Minecraft
				// Coal: 185.5
				// Iron: 111.5
				// Gold: 10.4
				// Redstone: 29.1
				// Diamond: 3.7
				// Lapis: 4.1
				ground -= 4

				if ((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 3.7 / 256) {
					let y = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() * 16 | 0 + 1
					y = y < ground ? y : ground
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.diamondOre)
					}
				}

				if ((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 111.5 / 256) {
					let y = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() * 64 | 0 + 1
					y = y < ground ? y : ground
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.ironOre)
					}
				}

				if ((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 185.5 / 256) {
					let y = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() * ground | 0 + 1
					y = y < ground ? y : ground
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.coalOre)
					}
				}

				if ((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 10.4 / 256) {
					let y = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() * 32 | 0 + 1
					y = y < ground ? y : ground
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.goldOre)
					}
				}

				if ((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 29.1 / 256) {
					let y = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() * 16 | 0 + 1
					y = y < ground ? y : ground
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.redstoneOre)
					}
				}

				if ((0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() < 4.1 / 256) {
					let y = (0,_random_js__WEBPACK_IMPORTED_MODULE_0__.random)() * 32 | 0 + 1
					y = y < ground ? y : ground
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, _blockData_js__WEBPACK_IMPORTED_MODULE_1__.blockIds.lapisOre)
					}
				}
			}
		}

		this.populated = true
	}
	genMesh(indexBuffer, bigArray) {
		const { glExtensions, gl, glCache } = this
		let barray = bigArray
		let index = 0
		for (let i = 0; i < this.sections.length; i++) {
			index = this.sections[i].genMesh(barray, index)
		}

		if (!this.buffer) {
			this.buffer = gl.createBuffer()
		}
		let data = barray.slice(0, index)

		let maxY = 0
		let minY = 255
		let y = 0
		for (let i = 1; i < data.length; i += 6) {
			y = data[i]
			maxY = max(maxY, y)
			minY = min(minY, y)
		}
		this.maxY = maxY
		this.minY = minY
		this.faces = data.length / 32
		glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
		gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer)
		gl.bufferData(gl.ARRAY_BUFFER, data, gl.DYNAMIC_DRAW)
		gl.enableVertexAttribArray(glCache.aVertex)
		gl.enableVertexAttribArray(glCache.aTexture)
		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
		gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 32, 0)
		gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 32, 12)
		gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 32, 20)
		gl.vertexAttribPointer(glCache.aSkylight, 1, gl.FLOAT, false, 32, 24)
		gl.vertexAttribPointer(glCache.aBlocklight, 1, gl.FLOAT, false, 32, 28)
		glExtensions.vertex_array_object.bindVertexArrayOES(null)
		this.lazy = false
	}
	tick() {
		if (this.edited) {
			for (let i = 0; i < this.sections.length; i++) {
				if (this.sections[i].edited) {
					this.sections[i].tick()
				}
			}
		}
	}
	load() {
		const { world } = this
		let chunkX = this.x >> 4
		let chunkZ = this.z >> 4
		let load = null

		for (let i = 0; i < world.loadFrom.length; i++) {
			load = world.loadFrom[i]
			if (load.x === chunkX && load.z === chunkZ) {
				let y = load.y * 16
				for (let j in load.blocks) {
					world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j])
				}
				world.loadFrom.splice(i--, 1)
			}
		}
		this.loaded = true
	}
}



/***/ }),
/* 22 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Item": () => (/* binding */ Item)
/* harmony export */ });
/* harmony import */ var _blockData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _texture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23);




class Item extends _entity_js__WEBPACK_IMPORTED_MODULE_2__.Entity {
	constructor(x, y, z, velx, vely, velz, blockID, glExtensions, gl, glCache, indexBuffer, world, p) {
		const block = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[blockID]
		const tex = block.textures
		const shape = block.shape
		const shapeVerts = shape.verts
		const shapeTexVerts = shape.texVerts
		const size = shape.size
		let blockSides = Object.keys(_blockData_js__WEBPACK_IMPORTED_MODULE_0__.Block)
		let texNum = 0
		let texture = []
		let index = 0
		for (let n = 0; n < 6; n++) {
			let side = blockSides[n]
			let directionalFaces = shapeVerts[_blockData_js__WEBPACK_IMPORTED_MODULE_0__.Sides[side]]
			for (let facei = 0; facei < directionalFaces.length; facei++) {
				let texVerts = _texture_js__WEBPACK_IMPORTED_MODULE_1__.textureCoords[_texture_js__WEBPACK_IMPORTED_MODULE_1__.textureMap[tex[texNum]]]
				let tx = texVerts[0]
				let ty = texVerts[1]
				let texShapeVerts = shapeTexVerts[n][facei]
				texture[index    ] = tx + texShapeVerts[0]
				texture[index + 1] = ty + texShapeVerts[1]
				texture[index + 2] = tx + texShapeVerts[2]
				texture[index + 3] = ty + texShapeVerts[3]
				texture[index + 4] = tx + texShapeVerts[4]
				texture[index + 5] = ty + texShapeVerts[5]
				texture[index + 6] = tx + texShapeVerts[6]
				texture[index + 7] = ty + texShapeVerts[7]
				index += 8
			}
			texNum++
		}
		super(x, y, z, Math.PI / 4, Math.PI / 4, velx, vely, velz, 0.25, 0.25, 0.25, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, 1500000, glExtensions, gl, glCache, indexBuffer, world, p)
	}
	render() {
		const { gl, glCache, glExtensions, p } = this
		const offsetY = -0.1 * cos((performance.now() - this.spawn) * 0.0015) + 0.15
		const modelMatrix = new Matrix();
		modelMatrix.identity()
		modelMatrix.translate(this.x, this.y + offsetY, this.z)
		modelMatrix.rotX(this.pitch)
		modelMatrix.rotY(this.yaw)
		modelMatrix.scale(this.width, this.height, this.depth)
		const viewMatrix = p.transformation.elements
		const proj = p.projection
		const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
		const modelViewProjectionMatrix = new Matrix()
		modelViewProjectionMatrix.identity()
		modelViewProjectionMatrix.mult(projectionMatrix)
		modelViewProjectionMatrix.mult(viewMatrix)
		modelViewProjectionMatrix.mult(modelMatrix.elements)
		// row major to column major
		modelViewProjectionMatrix.transpose()
		// const x = round(this.x)
		// const y = round(this.y)
		// const z = round(this.z)
		// let blockLight = 15
		// let skyLight = 15
		// try {
		// 	blockLight = world.getLight(x, y, z, 1)
		// 	skyLight = world.getLight(x, y, z, 0)
		// }
		// catch(e) {
		// 	console.error(e)
		// }
		const lightLevel = 1 // min(max(skyLight, blockLight) * 0.9 + 0.1, 1.0)
		gl.bindTexture(gl.TEXTURE_2D, textureAtlas)
		gl.uniform1i(glCache.uSamplerEntity, 0)
		gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
		gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
		glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
		gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
		glExtensions.vertex_array_object.bindVertexArrayOES(null)
	}
}



/***/ }),
/* 23 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Entity": () => (/* binding */ Entity)
/* harmony export */ });
/* harmony import */ var _blockData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(14);
/* harmony import */ var _3Dutils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(13);
/* harmony import */ var _texture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19);





const { round, floor, ceil, cos, min, max } = Math

class Contacts {
	constructor() {
		this.array = []
		this.size = 0
	}
	add(x, y, z, block) {
		if (this.size === this.array.length) {
			this.array.push([x, y, z, block])
		}
		else {
			this.array[this.size][0] = x
			this.array[this.size][1] = y
			this.array[this.size][2] = z
			this.array[this.size][3] = block
		}
		this.size++
	}
	clear() {
		this.size = 0
	}
}

class Entity {
	constructor(x, y, z, pitch, yaw, velx, vely, velz, width, height, depth, vertices, texture, faces, despawns, glExtensions, gl, glCache, indexBuffer, world, p) {
		this.x = x
		this.y = y
		this.z = z
		this.previousX = x
		this.previousY = y
		this.previousZ = z
		this.canStepX = true
		this.canStepY = true
		this.pitch = pitch
		this.yaw = yaw
		this.velx = velx
		this.vely = vely
		this.velz = velz
		this.width = width
		this.height = height
		this.depth = depth
		this.contacts = new Contacts()
		this.lastUpdate = performance.now()
		this.onGround = false
		this.despawns = despawns
		this.spawn = this.lastUpdate
		this.canDespawn = false
		this.faces = faces
		this.vao = glExtensions.vertex_array_object.createVertexArrayOES()
		const verticesBuffer = gl.createBuffer()
		const textureBuffer = gl.createBuffer()
		glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)

		gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aVertexEntity, 3, gl.FLOAT, false, 0, 0)

		gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, texture, gl.STATIC_DRAW)
		gl.vertexAttribPointer(glCache.aTextureEntity, 2, gl.FLOAT, false, 0, 0)

		gl.enableVertexAttribArray(glCache.aVertexEntity)
		gl.enableVertexAttribArray(glCache.aTextureEntity)
		glExtensions.vertex_array_object.bindVertexArrayOES(null)
		this.glExtensions = glExtensions
		this.gl = gl
		this.glCache = glCache
		this.indexBuffer = indexBuffer
		this.world = world
		this.p = p
	}
	updateVelocity(now) {
		let dt = (now - this.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt
		// this.vely += -0.02 * dt
		if (this.vely < -1.5) {
			this.vely = -1.5
		}

		this.velz += (this.velz * 0.9 - this.velz) * dt
		this.velx += (this.velx * 0.9 - this.velx) * dt
		// this.vely += (this.vely * 0.9 - this.vely) * dt
	}
	collided(x, y, z, vx, vy, vz, block) {
		let verts = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[block].shape.verts
		let px = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.roundBits)(this.x - this.width / 2 - x)
		let py = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.roundBits)(this.y - this.height / 2 - y)
		let pz = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.roundBits)(this.z - this.depth / 2 - z)
		let pxx = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.roundBits)(this.x + this.width / 2 - x)
		let pyy = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.roundBits)(this.y + this.height / 2 - y)
		let pzz = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.roundBits)(this.z + this.depth / 2 - z)
		let minX, minY, minZ, maxX, maxY, maxZ, min, max

		//Top and bottom faces
		let faces = verts[0]
		if (vy <= 0) {
			faces = verts[1]
		}
		if (!vx && !vz) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
					if (vy <= 0) {
						this.onGround = true
						this.y = round((face[1] + y + this.height / 2) * 10000) / 10000
						this.vely = 0
						return false
					}
					else {
						return true
					}
				}
			}
			return false
		}

		//West and East faces
		if (vx < 0) {
			faces = verts[4]
		}
		else if (vx > 0) {
			faces = verts[5]
		}
		if (vx) {
			let col = false
			for (let face of faces) {
				min = face.min
				minZ = min[2]
				minY = min[1]
				max = face.max
				maxZ = max[2]
				maxY = max[1]
				if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
					if (maxY - py > 0.5) {
						this.canStepX = false
					}
					col = true
				}
			}
			return col
		}

		//South and North faces
		if (vz < 0) {
			faces = verts[2]
		}
		else if (vz > 0) {
			faces = verts[3]
		}
		if (vz) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
					if (maxY - py > 0.5) {
						this.canStepZ = false
					}
					col = true
				}
			}
			return col
		}
	}
	move(now) {
		const { world } = this
		let pminX = floor(this.x - this.width / 2)
		let pmaxX = ceil(this.x + this.width / 2)
		let pminY = floor(this.y - this.height / 2)
		let pmaxY = ceil(this.y + this.height / 2)
		let pminZ = floor(this.z - this.depth / 2)
		let pmaxZ = ceil(this.z + this.depth / 2)
		let block = null

		for (let x = pminX; x <= pmaxX; x++) {
			for (let y = pminY; y <= pmaxY; y++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = world.getBlock(x, y, z)
					if (block) {
						this.contacts.add(x, y, z, block)
					}
				}
			}
		}
		let dt = (now - this.lastUpdate) / 33
		dt = dt > 2 ? 2 : dt

		this.previousX = this.x
		this.previousY = this.y
		this.previousZ = this.z

		this.canStepX = false
		this.canStepY = false
		this.onGround = false
		//Check collisions in the Y direction
		this.y += this.vely * dt
		for (let i = 0; i < this.contacts.size; i++) {
			block = this.contacts.array[i]
			if (this.collided(block[0], block[1], block[2], 0, this.vely, 0, block[3])) {
				this.y = this.previousY
				this.vely = 0
				break
			}
		}

		if (this.y === this.previousY) {
			this.canStepX = true
			this.canStepZ = true
		}

		//Check collisions in the X direction
		this.x += this.velx * dt
		for (let i = 0; i < this.contacts.size; i++) {
			block = this.contacts.array[i]
			if (this.collided(block[0], block[1], block[2], this.velx, 0, 0, block[3])) {
				if (this.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				this.x = this.previousX
				this.velx = 0
				break
			}
		}

		//Check collisions in the Z direction
		this.z += this.velz * dt
		for (let i = 0; i < this.contacts.size; i++) {
			block = this.contacts.array[i]
			if (this.collided(block[0], block[1], block[2], 0, 0, this.velz, block[3])) {
				if (this.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
					continue
				}
				this.z = this.previousZ
				this.velz = 0
				break
			}
		}

		this.lastUpdate = now
		this.contacts.clear()
	}
	update() {
		let now = performance.now()
		this.updateVelocity(now)
		this.move(now)
		if (now - this.spawn > this.despawns) {
			this.canDespawn = true
		}
	}
}



/***/ }),
/* 24 */
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Player": () => (/* binding */ Player)
/* harmony export */ });
/* harmony import */ var _blockData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(15);
/* harmony import */ var _shapes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);
/* harmony import */ var _texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19);
/* harmony import */ var _entity_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);
/* harmony import */ var _3Dutils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(13);






class Player extends _entity_js__WEBPACK_IMPORTED_MODULE_3__.Entity {
	constructor(x, y, z, vx, vy, vz, blockID, glExtensions, gl, glCache, indexBuffer, world, p) {
		const block = _blockData_js__WEBPACK_IMPORTED_MODULE_0__.blockData[blockID & 255]
		const tex = block.textures
		const shape = _shapes_js__WEBPACK_IMPORTED_MODULE_1__.shapes.cube
		const shapeVerts = shape.verts
		const shapeTexVerts = shape.texVerts
		const size = shape.size
		let blockSides = Object.keys(_blockData_js__WEBPACK_IMPORTED_MODULE_0__.Block)
		let texNum = 0
		let texture = []
		let index = 0
		for (let n = 0; n < 6; n++) {
			let side = blockSides[n]
			let directionalFaces = shapeVerts[_blockData_js__WEBPACK_IMPORTED_MODULE_0__.Sides[side]]
			for (let facei = 0; facei < directionalFaces.length; facei++) {
				let texVerts = _texture_js__WEBPACK_IMPORTED_MODULE_2__.textureCoords[_texture_js__WEBPACK_IMPORTED_MODULE_2__.textureMap[tex[texNum]]]
				let tx = texVerts[0]
				let ty = texVerts[1]
				let texShapeVerts = shapeTexVerts[n][facei]
				texture[index    ] = tx + texShapeVerts[0]
				texture[index + 1] = ty + texShapeVerts[1]
				texture[index + 2] = tx + texShapeVerts[2]
				texture[index + 3] = ty + texShapeVerts[3]
				texture[index + 4] = tx + texShapeVerts[4]
				texture[index + 5] = ty + texShapeVerts[5]
				texture[index + 6] = tx + texShapeVerts[6]
				texture[index + 7] = ty + texShapeVerts[7]
				index += 8
			}
			texNum++
		}
		super(x, y, z, 0, 0, vx || 0, vy || 0, vz || 0, 0.6, 1.7, 0.6, new Float32Array(shapeVerts.flat(Infinity)), new Float32Array(texture), size, Infinity, glExtensions, gl, glCache, indexBuffer, world, p)
		if (p) this.camera = null
	}
	render() {
		const { gl, glCache, glExtensions, p } = this
		const modelMatrix = new _3Dutils_js__WEBPACK_IMPORTED_MODULE_4__.Matrix();
		modelMatrix.identity()
		modelMatrix.translate(this.x, this.y, this.z)
		modelMatrix.rotX(this.pitch)
		modelMatrix.rotY(this.yaw)
		modelMatrix.scale(this.width, this.height, this.depth)
		const viewMatrix = p.transformation.elements
		const proj = p.projection
		const projectionMatrix = [proj[0], 0, 0, 0, 0, proj[1], 0, 0, 0, 0, proj[2], proj[3], 0, 0, proj[4], 0]
		const modelViewProjectionMatrix = new _3Dutils_js__WEBPACK_IMPORTED_MODULE_4__.Matrix()
		modelViewProjectionMatrix.identity()
		modelViewProjectionMatrix.mult(projectionMatrix)
		modelViewProjectionMatrix.mult(viewMatrix)
		modelViewProjectionMatrix.mult(modelMatrix.elements)
		// row major to column major
		modelViewProjectionMatrix.transpose()

		const lightLevel = 1 // min(max(skyLight, blockLight) * 0.9 + 0.1, 1.0)
		gl.bindTexture(gl.TEXTURE_2D, _texture_js__WEBPACK_IMPORTED_MODULE_2__.textureAtlas)
		gl.uniform1i(glCache.uSamplerEntity, 0)
		gl.uniform1f(glCache.uLightLevelEntity, lightLevel)
		gl.uniformMatrix4fv(glCache.uViewEntity, false, modelViewProjectionMatrix.elements)
		glExtensions.vertex_array_object.bindVertexArrayOES(this.vao)
		gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0)
		glExtensions.vertex_array_object.bindVertexArrayOES(null)
	}
}



/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _shaders_blockVertexShader_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _shaders_blockFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);
/* harmony import */ var _shaders_2dVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(3);
/* harmony import */ var _shaders_2dFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4);
/* harmony import */ var _shaders_entityVertexShader_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var _shaders_entityFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);
/* harmony import */ var _js_Worker_jsw__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(7);
/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(8);
/* harmony import */ var _js_random_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(12);
/* harmony import */ var _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(13);
/* harmony import */ var _js_utils_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(14);
/* harmony import */ var _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(15);
/* harmony import */ var _js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(16);
/* harmony import */ var _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(17);
/* harmony import */ var _js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(18);
/* harmony import */ var _js_texture_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(19);
/* harmony import */ var _js_section_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(20);
/* harmony import */ var _js_chunk_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(21);
/* harmony import */ var _js_item_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(22);
/* harmony import */ var _js_player_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(24);


// GLSL Shader code
;






// Import Worker code


// import css


// imports













window.blockData = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData
window.canvas = document.getElementById("overlay")
window.ctx = window.canvas.getContext("2d")
window.savebox = document.getElementById("savebox")
window.boxCenterTop = document.getElementById("boxcentertop")
window.saveDirections = document.getElementById("savedirections")
window.message = document.getElementById("message")
window.worlds = document.getElementById("worlds") // I have too many "worlds" variables. This one uses "window" as its namespace.
window.quota = document.getElementById("quota")
window.hoverbox = document.getElementById("onhover")
window.canvas.width  = window.innerWidth
window.canvas.height = window.innerHeight
window.controlMap = {}

async function MineKhan() {
	// Cache user-defined globals
	const { canvas, ctx, savebox, boxCenterTop, saveDirections, message, quota, hoverbox, loadString, controlMap } = window

	// cache global objects locally.
	const { Math, performance, Date, document, console } = window
	const { cos, sin, round, floor, ceil, min, max, abs, sqrt } = Math
	const win = window.parent
	const chatOutput = document.getElementById("chat")
	const chatInput = document.getElementById("chatbar")
	let now = Date.now()

	// Shh don't tell anyone I'm overriding native objects
	String.prototype.hashCode = function() {
		var hash = 0, i, chr
		if (this.length === 0) return hash
		for (i = 0; i < this.length; i++) {
			chr   = this.charCodeAt(i)
			hash  = (hash << 5) - hash + chr
			hash |= 0 // Convert to 32bit integer
		}
		return hash
	}

	{
		// I'm throwing stuff in the window scope since I can't be bothered to figure out how all this fancy import export stuff works
		const workerURL = window.URL.createObjectURL(new Blob([_js_Worker_jsw__WEBPACK_IMPORTED_MODULE_6__["default"]], { type: "text/javascript" }))
		window.workers = []
		window.pendingWorkers = [] // Array of promises; can be awaited with Promise.race()
		let jobId = 1
		const pendingJobs = new Map()
		for (let i = 0, count = (navigator.hardwareConcurrency || 4) - 1 || 1; i < count; i++) { // Generate between 1 and (processors - 1) workers.
			let worker = new Worker(workerURL)
			worker.onmessage = e => {
				let [promise, resolve] = pendingJobs.get(e.data.jobId)
				resolve(e.data)
				pendingJobs.delete(e.data.jobId)
				window.workers.push(worker)
				window.pendingWorkers.splice(window.pendingWorkers.indexOf(promise), 1)
			}
			window.workers.push(worker)
		}

		window.doWork = function(data) {
			let job = []
			let promise = new Promise(resolve => {
				let id = jobId++
				data.jobId = id
				job[1] = resolve
				pendingJobs.set(id, job)
				window.workers.shift().postMessage(data)
			})
			job[0] = promise
			window.pendingWorkers.push(promise)
			return promise
		}

		// await window.yieldThread() will pause the current task until the event loop is cleared
		const channel = new MessageChannel()
		let res
		channel.port1.onmessage = () => res()
		window.yieldThread = function() {
			return new Promise(resolve => {
				res = resolve
				channel.port2.postMessage("")
			})
		}
	}

	let world, worldSeed

	function setSeed(seed) {
		worldSeed = seed
		;(0,_js_random_js__WEBPACK_IMPORTED_MODULE_8__.seedHash)(seed)
		_js_random_js__WEBPACK_IMPORTED_MODULE_8__.noiseProfile.noiseSeed(seed)
		while(window.workers.length) {
			window.doWork({ seed })
		}
	}

	let fill = function(r, g, b) {
		if (g === undefined) {
			g = r
			b = r
		}
		ctx.fillStyle = `rgb(${r}, ${g}, ${b})`
	}
	let stroke = function(r, g, b) {
		if (g === undefined) {
			g = r
			b = r
		}
		ctx.strokeStyle = `rgb(${r}, ${g}, ${b})`
	}
	// function line(x1, y1, x2, y2) {
	// 	ctx.moveTo(x1, y1)
	// 	ctx.lineTo(x2, y2)
	// }
	function text(txt, x, y, h) {
		h = h || 0

		let lines = txt.split("\n")
		for (let i = 0; i < lines.length; i++) {
			ctx.fillText(lines[i], x, y + h * i)
		}
	}
	function textSize(size) {
		ctx.font = size + 'px Monospace' // VT323
	}
	let strokeWeight = function(num) {
		ctx.lineWidth = num
	}
	// const ARROW = "arrow"
	const HAND = "pointer"
	// const CROSS = "crosshair"
	let cursor = function(type) {
		canvas.style.cursor = type
	}
	;(0,_js_random_js__WEBPACK_IMPORTED_MODULE_8__.randomSeed)(Math.random() * 10000000 | 0)

	async function save() {
		let saveObj = {
			id: world.id,
			edited: now,
			name: world.name,
			version: version,
			code: world.getSaveString()
		}
		await (0,_js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.saveToDB)(world.id, saveObj).catch(e => console.error(e))
		world.edited = now
		console.log('Saving to server')
		await fetch('https://willard.fun/minekhan/saves', {
			method: "POST",
			headers: {
				"Content-Type": "application/json"
			},
			body: JSON.stringify(saveObj)
		})
	}

	// Expose these functions to the global scope for debugging
	win.saveToDB = _js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.saveToDB
	win.loadFromDB = _js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.loadFromDB
	win.createDatabase = _js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.createDatabase
	win.deleteFromDB = _js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.deleteFromDB

	//globals
	//{
	let version = "Alpha 0.7.1"
	let reach = 5 // Max distance player can place or break blocks
	let sky = new Float32Array([0.33, 0.54, 0.72]) // 0 to 1 RGB color scale
	let superflat = false
	let trees = true
	let caves = true

	win.blockData = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData
	win.blockIds = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds

	// Configurable and savable settings
	let settings = {
		renderDistance: 4,
		fov: 70, // Field of view in degrees
		mouseSense: 100 // Mouse sensitivity as a percentage of the default
	}
	let generatedChunks
	let mouseX, mouseY, mouseDown
	let width = window.innerWidth
	let height = window.innerHeight

	if (height === 400) alert("Canvas is too small. Click the \"Settings\" button to the left of the \"Vote Up\" button under the editor and change the height to 600.")

	let generator = {
		height: 80, // Height of the hills
		smooth: 0.01, // Smoothness of the terrain
		extra: 30, // Extra height added to the world.
		caveSize: 0.00 // Redefined right above where it's used
	}
	let maxHeight = 255
	let blockOutlines = false
	let blockFill = true
	let updateHUD = true
	const CUBE     = 0
	const SLAB     = 0x100 // 9th bit
	const STAIR    = 0x200 // 10th bit
	const FLIP     = 0x400 // 11th bit
	// const NORTH    = 0 // 12th and 13th bits for the 4 directions
	const SOUTH    = 0x800
	const EAST     = 0x1000
	const WEST     = 0x1800
	// const ROTATION = 0x1800 // Mask for the direction bits
	let blockMode  = CUBE
	let tex
	let dirtBuffer
	let texCoordsBuffers
	let mainbg, dirtbg // Background images
	let bigArray = win.bigArray || new Float32Array(1000000)
	win.bigArray = bigArray

	// Callback functions for all the screens; will define them further down the page
	let drawScreens = {
		"main menu": () => {},
		"options": () => {},
		"play": () => {},
		"pause": () => {},
		"creation menu": () => {},
		"inventory": () => {},
		"multiplayer menu": () => {},
		"comingsoon menu": () => {},
		"loadsave menu": () => {},
		"chat": () => {}
	}
	let html = {
		pause: {
			enter: [window.message],
			exit: [window.savebox, window.saveDirections, window.message]
		},
		"loadsave menu": {
			enter: [window.worlds, window.boxCenterTop, quota],
			exit: [window.worlds, window.boxCenterTop, quota],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter Save String (Optional)"
				if (navigator && navigator.storage && navigator.storage.estimate) {
					navigator.storage.estimate().then(data => {
						quota.innerText = `${data.usage.toLocaleString()} / ${data.quota.toLocaleString()} bytes (${(100 * data.usage / data.quota).toLocaleString(undefined, { maximumSignificantDigits: 2 })}%) of your quota used`
					}).catch(console.error)
				}
				window.boxCenterTop.onmousedown = () => {
					let elem = document.getElementsByClassName("selected")
					if (elem && elem[0]) {
						elem[0].classList.remove("selected")
					}
					selectedWorld = 0
					Button.draw()
				}
			},
			onexit: () => {
				window.boxCenterTop.onmousedown = null
			}
		},
		"creation menu": {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = ""
			}
		},
		loading: {
			onenter: startLoad
		},
		editworld: {
			enter: [window.boxCenterTop],
			exit: [window.boxCenterTop],
			onenter: () => {
				window.boxCenterTop.placeholder = "Enter World Name"
				window.boxCenterTop.value = ""
			}
		},
		"multiplayer menu": {
			enter: [window.worlds],
			exit: [window.worlds]
		},
		chat: {
			enter: [chatInput, chatOutput],
			exit: [chatInput, chatOutput],
			onenter: () => {
				chatInput.focus()
				releasePointer()
				chatOutput.scroll(0, 10000000)
			}
		},
	}

	let screen = "main menu"
	let previousScreen = screen
	function changeScene(newScene) {
		document.getElementById('background-text').classList.add('hidden')
		if (screen === "options") {
			(0,_js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.saveToDB)("settings", settings).catch(e => console.error(e))
		}

		if (html[screen] && html[screen].exit) {
			for (let element of html[screen].exit) {
				element.classList.add("hidden")
			}
		}

		if (html[newScene] && html[newScene].enter) {
			for (let element of html[newScene].enter) {
				element.classList.remove("hidden")
			}
		}

		if (html[newScene] && html[newScene].onenter) {
			html[newScene].onenter()
		}
		if (html[screen] && html[screen].onexit) {
			html[screen].onexit()
		}

		previousScreen = screen
		screen = newScene
		mouseDown = false
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
	}
	let hitBox = {}
	let holding = 0
	let Key = {}
	let modelView = win.modelView || new Float32Array(16)
	win.modelView = modelView
	let glCache
	let worlds, selectedWorld = 0
	let freezeFrame = 0
	let p
	let vec1 = new _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.PVector(), vec2 = new _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.PVector(), vec3 = new _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.PVector()
	let move = {
		x: 0,
		y: 0,
		z: 0,
		ang: Math.sqrt(0.5),
	}
	let p2 = {
		x: 0,
		y: 0,
		z: 0,
	}
	let inventory = {
		hotbar: [1, 2, 3, 4, 5, 6, 7, 8, 9],
		main: [],
		hotbarSlot: 0,
		size: 40 * min(width, height) / 600,
		holding: 0,
	}

	function setControl(name, key, shift = false, ctrl = false, alt = false) {
		controlMap[name] = {
			key,
			shift,
			ctrl,
			alt,
			get pressed() {
				return Boolean(Key[this.key]
					&& (!this.shift || Key.ShiftLeft || Key.ShiftRight)
					&& (!this.ctrl || Key.ControlLeft || Key.ControlRight)
					&& (!this.alt || Key.AltLeft || Key.AltRight))
			},
			// Check to see if all of an event's data matches this key map
			event(e) {
				return Boolean(e.code === this.key
					&& (!this.shift || e.shiftKey)
					&& (!this.ctrl || e.ctrlKey)
					&& (!this.alt || e.altKey))
			}
		}
	}
	setControl("jump", "Space")
	setControl("walkForwards", "KeyW")
	setControl("strafeLeft", "KeyA")
	setControl("walkBackwards", "KeyS")
	setControl("strafeRight", "KeyD")
	setControl("sprint", "KeyQ")
	setControl("openInventory", "KeyE")
	setControl("openChat", "KeyT")
	setControl("pause", "KeyP")
	setControl("hyperBuilder", "KeyH")
	setControl("superBreaker", "KeyB")
	setControl("toggleSpectator", "KeyL")
	setControl("zoom", "KeyZ")
	setControl("cycleBlockShapes", "Enter")
	setControl("sneak", "ShiftLeft")
	setControl("dropItem", "Backspace")
	setControl("breakBlock", "leftMouse")
	setControl("placeBlock", "rightMouse")
	setControl("pickBlock", "middleMouse")
	//}

	function play() {
		canvas.onblur()
		p.lastBreak = now
		holding = inventory.hotbar[inventory.hotbarSlot]
		updateHUD = true
		use3d()
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		getPointer()
		fill(255, 255, 255)
		textSize(10)
		canvas.focus()
		changeScene("play")
	}

	let gl
	let glExtensions
	function getPointer() {
		if (canvas.requestPointerLock) {
			canvas.requestPointerLock()
		}
	}
	function releasePointer() {
		if (document.exitPointerLock) {
			document.exitPointerLock()
		}
	}

	let program3D, program2D, programEntity

	win.shapes = _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes

	function initShapes() {
		function mapCoords(rect, face) {
			let x = rect.x
			let y = rect.y
			let z = rect.z
			let w = rect.w
			let h = rect.h
			let tx = rect.tx
			let ty = rect.ty
			let tex = [tx+w,ty, tx,ty, tx,ty+h, tx+w,ty+h]
			let pos = null
			switch(face) {
				case 0: // Bottom
					pos = [x,y,z, x+w,y,z, x+w,y,z+h, x,y,z+h]
					break
				case 1: // Top
					pos = [x,y,z, x+w,y,z, x+w,y,z-h, x,y,z-h]
					break
				case 2: // North
					pos = [x,y,z, x-w,y,z, x-w,y-h,z, x,y-h,z]
					break
				case 3: // South
					pos = [x,y,z, x+w,y,z, x+w,y-h,z, x,y-h,z]
					break
				case 4: // East
					pos = [x,y,z, x,y,z+w, x,y-h,z+w, x,y-h,z]
					break
				case 5: // West
					pos = [x,y,z, x,y,z-w, x,y-h,z-w, x,y-h,z]
					break
			}
			pos = pos.map(c => c / 16 - 0.5)
			let minmax = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.compareArr)(pos, [])
			pos.max = minmax.splice(3, 3)
			pos.min = minmax
			tex = tex.map(c => c / 16 / 16)

			return {
				pos: pos,
				tex: tex
			}
		}

		// 90 degree clockwise rotation; returns a new shape object
		function rotate(shape) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = face[k + 1]
						c[k + 2] = -face[k]
					}

					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
					if (i === 0) {
						// Bottom
						c.push(...c.splice(0, 3))
						tex[i][j].push(...tex[i][j].splice(0, 2))
					}
					if (i === 1) {
						// Top
						c.unshift(...c.splice(-3, 3))
						tex[i][j].unshift(...tex[i][j].splice(-2, 2))
					}

					let minmax = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.compareArr)(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax
				}
			}
			let temp = tex[2] // North
			tex[2] = tex[5] // North = West
			tex[5] = tex[3] // West = South
			tex[3] = tex[4] // South = East
			tex[4] = temp // East = North

			temp = pos[2] // North
			pos[2] = pos[5] // North = West
			pos[5] = pos[3] // West = South
			pos[3] = pos[4] // South = East
			pos[4] = temp // East = North

			let cull2 = {
				top: cull.top,
				bottom: cull.bottom,
				north: cull.west,
				west: cull.south,
				south: cull.east,
				east: cull.north
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: true,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients
			}
		}

		// Reflect over the y plane; returns a new shape object
		function flip(shape) {
			let verts = shape.verts
			let texVerts = shape.texVerts
			let cull = shape.cull
			let pos = []
			tex = []
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				pos[i] = []
				tex[i] = []
				for (let j = 0; j < side.length; j++) {
					let face = side[j].slice().reverse()
					let c = []
					pos[i][j] = c
					for (let k = 0; k < face.length; k += 3) {
						c[k] = face[k + 2]
						c[k + 1] = -face[k + 1]
						c[k + 2] = face[k]
					}
					let minmax = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.compareArr)(c, [])
					c.max = minmax.splice(3, 3)
					c.min = minmax

					tex[i][j] = texVerts[i][j].slice() // Copy texture verts exactly
				}
			}
			let temp = pos[0] // Bottom
			pos[0] = pos[1] // Bottom = Top
			pos[1] = temp // Top = Bottom

			temp = tex[0] // Bottom
			tex[0] = tex[1] // Bottom = Top
			tex[1] = temp // Top = Bottom

			let cull2 = {
				top: cull.bottom,
				bottom: cull.top,
				north: (cull.north & 1) << 1 | (cull.north & 2) >> 1,
				west: (cull.west & 1) << 1 | (cull.west & 2) >> 1,
				south: (cull.south & 1) << 1 | (cull.south & 2) >> 1,
				east: (cull.east & 1) << 1 | (cull.east & 2) >> 1
			}

			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(pos.flat(2)), gl.STATIC_DRAW)

			return {
				verts: pos,
				texVerts: tex,
				cull: cull2,
				rotate: shape.rotate,
				flip: shape.flip,
				buffer: buffer,
				size: shape.size,
				varients: shape.varients
			}
		}

		for (let shape in _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes) {
			let obj = _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes[shape]
			let verts = obj.verts

			// Populate the vertex coordinates
			for (let i = 0; i < verts.length; i++) {
				let side = verts[i]
				let texArr = []
				obj.texVerts.push(texArr)
				for (let j = 0; j < side.length; j++) {
					let face = side[j]
					let mapped = mapCoords(face, i)
					side[j] = mapped.pos
					texArr.push(mapped.tex)
				}
			}

			if (obj.rotate) {
				let v = obj.varients
				let east = rotate(obj)
				let south = rotate(east)
				let west = rotate(south)
				v[0] = obj
				v[2] = south
				v[4] = east
				v[6] = west
			}
			if (obj.flip) {
				let v = obj.varients
				v[1] = flip(obj)
				if (obj.rotate) {
					v[3] = flip(v[2])
					v[5] = flip(v[4])
					v[7] = flip(v[6])
				}
			}

			obj.buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts.flat(2)), gl.STATIC_DRAW)
		}

		for (let i = 0; i < _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.BLOCK_COUNT; i++) {
			let baseBlock = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[i]
			let slabBlock = Object.create(baseBlock)
			slabBlock.transparent = true
			let stairBlock = Object.create(baseBlock)
			stairBlock.transparent = true
			slabBlock.shape = _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes.slab
			baseBlock.shape = _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes.cube
			stairBlock.shape = _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes.stair
			_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[i | SLAB] = slabBlock
			_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[i | STAIR] = stairBlock
			let v = slabBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.transparent = true
					block.shape = v[j]
					_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[i | SLAB | j << 10] = block
				}
			}
			v = stairBlock.shape.varients
			for (let j = 0; j < v.length; j++) {
				if (v[j]) {
					let block = Object.create(baseBlock)
					block.transparent = true
					block.shape = v[j]
					_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[i | STAIR | j << 10] = block
				}
			}
		}
	}
	let indexOrder = new Uint32Array(bigArray.length / 6 | 0)
	for (let i = 0, j = 0; i < indexOrder.length; i += 6, j += 4) {
		indexOrder[i]     = j
		indexOrder[i + 1] = 1 + j
		indexOrder[i + 2] = 2 + j
		indexOrder[i + 3] = 0 + j
		indexOrder[i + 4] = 2 + j
		indexOrder[i + 5] = 3 + j
	}

	let hexagonVerts
	let slabIconVerts
	let stairIconVerts
	let blockIcons
	{
		let side = Math.sqrt(3) / 2
		let s = side
		let q = s / 2
		hexagonVerts = new Float32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		])

		slabIconVerts = new Float32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		])

		stairIconVerts = [
			-s,0.5,0,0,1,         0,1,1,0,1,         q,0.75,1,0.5,1,    -q,0.25,0,0.5,1,    // top of the top step
			-q,-0.25,0,0,1,       q,0.25,1,0,1,      s,0,1,0.5,1,        0,-0.5,0,0.5,1,    // top of the bottom step
			-q,0.25,0,0,0.6,      q,0.75,1,0,0.6,    q,0.25,1,0.5,0.6,  -q,-0.25,0,0.5,0.6, // front of the top step
			0,-0.5,0,0,0.6,       s,0,1,0,0.6,       s,-0.5,1,0.5,0.6,   0,-1,0,0.5,0.6,    // front of the bottom step
			-s,0.5,0,0,0.8,      -q,0.25,0.5,0,0.8, -q,-0.75,0.5,1,0.8, -s,-0.5,0,1,0.8,    // side of the top step
			-q,-0.25,0.5,0.5,0.8, 0,-0.5,1,0.5,0.8,  0,-1,1,1,0.8,      -q,-0.75,0.5,1,0.8, // side of the bottom step
		]
	}
	function genIcons() {
		blockIcons = [null]
		blockIcons.lengths = []
		let texOrder = [1, 2, 3]
		let shadows = [1, 0.4, 0.7]
		let scale = 0.16 / height * inventory.size
		for (let i = 1; i < _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.BLOCK_COUNT; i++) {
			let data = []
			let block = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[i]
			if (block.icon) {
				block = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds[block.icon]]
			}
			for (let j = 11; j >= 0; j--) {
				data.push(-hexagonVerts[j * 3 + 0] * scale)
				data.push(hexagonVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureCoords[_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 0) % 8])
				data.push(_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureCoords[_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureMap[block.textures[texOrder[floor(j / 4)]]]][(j * 2 + 1) % 8])
				data.push(shadows[floor(j / 4)])
			}
			let buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i] = buffer
			blockIcons.lengths[i] = 6 * 3

			data = []
			for (let j = 11; j >= 0; j--) {
				let tex = _js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureCoords[_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureMap[block.textures[texOrder[floor(j / 4)]]]]

				data.push(-slabIconVerts[j * 3 + 0] * scale)
				data.push(slabIconVerts[j * 3 + 1] * scale)
				data.push(0.1666666)
				data.push(tex[(j * 2 + 0) % 8])
				data.push(tex[(j * 2 + 1) % 8])
				data.push(shadows[floor(j / 4)])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | SLAB] = buffer
			blockIcons.lengths[i | SLAB] = 6 * 3

			data = []
			let v = stairIconVerts
			for (let j = 23; j >= 0; j--) {
				let num = floor(j / 8)
				let tex = _js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureCoords[_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureMap[block.textures[texOrder[num]]]]
				let tx = tex[0]
				let ty = tex[1]
				data.push(-v[j * 5 + 0] * scale)
				data.push(v[j * 5 + 1] * scale)
				data.push(0.1666666)
				data.push(tx + v[j * 5 + 2] / 16)
				data.push(ty + v[j * 5 + 3] / 16)
				data.push(shadows[num])
			}
			buffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW)
			blockIcons[i | STAIR] = buffer
			blockIcons.lengths[i | STAIR] = 6 * 6
		}
	}

	//Generate buffers for every block face and store them
	let sideEdgeBuffers
	let indexBuffer

	let matrix = new Float32Array(16) // A temperary matrix that may store random data.
	let projection = new Float32Array(16)
	let defaultModelView = new Float32Array([-10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1])

	let defaultTransformation = new _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.Matrix([-10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1])
	class Camera {
		constructor() {
			this.x = 0
			this.y = 0
			this.z = 0
			this.px = 0
			this.py = 0
			this.pz = 0

			this.rx = 0 // Pitch
			this.ry = 0 // Yaw
			this.prx = 0 // Pitch
			this.pry = 0 // Yaw

			this.currentFov = 0
			this.defaultFov = settings.fov
			this.targetFov = settings.fov
			this.step = 0
			this.lastStep = 0
			this.projection = new Float32Array(5)
			this.transformation = new _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.Matrix()
			this.direction = { x: 1, y: 0, z: 0 } // Normalized direction vector
			this.frustum = [] // The 5 planes of the viewing frustum (there's no far plane)
			for (let i = 0; i < 5; i++) {
				this.frustum.push(new _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.Plane(1, 0, 0))
			}
		}
		FOV(fov, time) {
			if (fov === this.currentFov) return

			if (!fov) {
				fov = this.currentFov + this.step * (now - this.lastStep)
				this.lastStep = now
				if (Math.sign(this.targetFov - this.currentFov) !== Math.sign(this.targetFov - fov)) {
					fov = this.targetFov
				}
			}
			else if (time) {
				this.targetFov = fov
				this.step = (fov - this.currentFov) / time
				this.lastStep = now
				return
			}
			else {
				this.targetFov = fov
			}

			const tang = Math.tan(fov * Math.PI / 360)
			const scale = 1 / tang
			const near = 1
			const far = 1000000
			this.currentFov = fov // Store the state of the projection matrix
			this.nearH = near * tang // This is needed for frustum culling

			this.projection[0] = scale / width * height
			this.projection[1] = scale
			this.projection[2] = -far / (far - near)
			this.projection[3] = -1
			this.projection[4] = -far * near / (far - near)
		}
		transform() {
			let diff = (performance.now() - this.lastUpdate) / 50
			if (diff > 1) diff = 1
			let x = (this.x - this.px) * diff + this.px
			let y = (this.y - this.py) * diff + this.py
			let z = (this.z - this.pz) * diff + this.pz
			this.transformation.copyMatrix(defaultTransformation)
			this.transformation.rotX(this.rx)
			this.transformation.rotY(this.ry)
			this.transformation.translate(-x, -y, -z)
		}
		getMatrix() {
			let proj = this.projection
			let view = this.transformation.elements
			matrix[0]  = proj[0] * view[0]
			matrix[1]  = proj[1] * view[4]
			matrix[2]  = proj[2] * view[8] + proj[3] * view[12]
			matrix[3]  = proj[4] * view[8]
			matrix[4]  = proj[0] * view[1]
			matrix[5]  = proj[1] * view[5]
			matrix[6]  = proj[2] * view[9] + proj[3] * view[13]
			matrix[7]  = proj[4] * view[9]
			matrix[8]  = proj[0] * view[2]
			matrix[9]  = proj[1] * view[6]
			matrix[10] = proj[2] * view[10] + proj[3] * view[14]
			matrix[11] = proj[4] * view[10]
			matrix[12] = proj[0] * view[3]
			matrix[13] = proj[1] * view[7]
			matrix[14] = proj[2] * view[11] + proj[3] * view[15]
			matrix[15] = proj[4] * view[11]
			return matrix
		}
		setDirection() {
			if (this.targetFov !== this.currentFov) {
				this.FOV()
			}
			this.direction.x = -sin(this.ry) * cos(this.rx)
			this.direction.y = sin(this.rx)
			this.direction.z = cos(this.ry) * cos(this.rx)
			this.computeFrustum()
		}
		computeFrustum() {
			let X = vec1
			let dir = this.direction
			X.x = dir.z
			X.y = 0
			X.z = -dir.x
			X.normalize()

			let Y = vec2
			Y.set(dir)
			Y.mult(-1)
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.cross)(Y, X, Y)

			//Near plane
			this.frustum[0].set(dir.x, dir.y, dir.z)

			let aux = vec3
			aux.set(Y)
			aux.mult(this.nearH)
			aux.add(dir)
			aux.normalize()
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.cross)(aux, X, aux)
			this.frustum[1].set(aux.x, aux.y, aux.z)

			aux.set(Y)
			aux.mult(-this.nearH)
			aux.add(dir)
			aux.normalize()
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.cross)(X, aux, aux)
			this.frustum[2].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(-this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.cross)(aux, Y, aux)
			this.frustum[3].set(aux.x, aux.y, aux.z)

			aux.set(X)
			aux.mult(this.nearH * width / height)
			aux.add(dir)
			aux.normalize()
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.cross)(Y, aux, aux)
			this.frustum[4].set(aux.x, aux.y, aux.z)
		}
		canSee(x, y, z, maxY) {
			x -= 0.5
			y -= 0.5
			z -= 0.5
			maxY += 0.5
			let px = 0, py = 0, pz = 0, plane = null
			let cx = p.x, cy = p.y, cz = p.z
			for (let i = 0; i < 5; i++) {
				plane = this.frustum[i]
				px = x + plane.dx
				py = plane.dy ? maxY : y
				pz = z + plane.dz
				if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
					return false
				}
			}
			return true
		}
	}

	function matMult() {
		//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
		let proj = projection
		let view = modelView
		matrix[0] = proj[0] * view[0]
		matrix[1] = proj[0] * view[1]
		matrix[2] = proj[0] * view[2]
		matrix[3] = proj[0] * view[3]
		matrix[4] = proj[5] * view[4]
		matrix[5] = proj[5] * view[5]
		matrix[6] = proj[5] * view[6]
		matrix[7] = proj[5] * view[7]
		matrix[8] = proj[10] * view[8] + proj[11] * view[12]
		matrix[9] = proj[10] * view[9] + proj[11] * view[13]
		matrix[10] = proj[10] * view[10] + proj[11] * view[14]
		matrix[11] = proj[10] * view[11] + proj[11] * view[15]
		matrix[12] = proj[14] * view[8]
		matrix[13] = proj[14] * view[9]
		matrix[14] = proj[14] * view[10]
		matrix[15] = proj[14] * view[11]
	}

	function FOV(fov) {
		let tang = Math.tan(fov * 0.5 * Math.PI / 180)
		let scale = 1 / tang
		let near = 1
		let far = 1000000

		projection[0] = scale / width * height
		projection[5] = scale
		projection[10] = -far / (far - near)
		projection[11] = -1
		projection[14] = -far * near / (far - near)
	}

	function initModelView(camera, x, y, z, rx, ry) {
		if (camera) {
			camera.transform()
			;(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.uniformMatrix)(gl, glCache, "view3d", program3D, "uView", false, camera.getMatrix())
		}
		else {
			(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.copyArr)(defaultModelView, modelView)
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.rotX)(modelView, rx)
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.rotY)(modelView, ry)
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.trans)(modelView, -x, -y, -z)
			matMult()
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.transpose)(matrix)
			;(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.uniformMatrix)(gl, glCache, "view3d", program3D, "uView", false, matrix)
		}
	}

	function rayTrace(x, y, z, shape) {
		let cf, cd = 1e9 //Closest face and distance
		let m //Absolute distance to intersection point
		let ix, iy, iz //Intersection coords
		let minX, minY, minZ, maxX, maxY, maxZ, min, max //Bounds of face coordinates
		let east = p.direction.x < 0
		let top = p.direction.y < 0
		let north = p.direction.z < 0
		let verts = shape.verts
		let faces = verts[0]

		//Top and bottom faces

		if (top) {
			faces = verts[1]
		}
		if (p.direction.y) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				m = (y + face[1] - p.y) / p.direction.y
				ix = m * p.direction.x + p.x
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iz >= z + minZ && iz <= z + maxZ) {
					cd = m //Ray crosses bottom face
					cf = top ? "top" : "bottom"
				}
			}
		}

		//West and East faces
		if (east) {
			faces = verts[4]
		}
		else {
			faces = verts[5]
		}
		if (p.direction.x) {
			for (let face of faces) {
				min = face.min
				minY = min[1]
				minZ = min[2]
				max = face.max
				maxY = max[1]
				maxZ = max[2]
				m = (x + face[0] - p.x) / p.direction.x
				iy = m * p.direction.y + p.y
				iz = m * p.direction.z + p.z
				if (m > 0 && m < cd && iy >= y + minY && iy <= y + maxY && iz >= z + minZ && iz <= z + maxZ) {
					cd = m
					cf = east ? "east" : "west"
				}
			}
		}

		//South and North faces
		if (north) {
			faces = verts[2]
		}
		else {
			faces = verts[3]
		}
		if (p.direction.z) {
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				m = (z + face[2] - p.z) / p.direction.z
				ix = m * p.direction.x + p.x
				iy = m * p.direction.y + p.y
				if (m > 0 && m < cd && ix >= x + minX && ix <= x + maxX && iy >= y + minY && iy <= y + maxY) {
					cd = m
					cf = north ? "north" : "south"
				}
			}
		}
		return [cd, cf]
	}
	function runRayTrace(x, y, z) {
		let block = world.getBlock(x, y, z)
		if (block) {
			let rt = rayTrace(x, y, z, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[block].shape)

			if (rt[1] && rt[0] < hitBox.closest) {
				hitBox.closest = rt[0]
				hitBox.face = rt[1]
				hitBox.pos = [x, y, z]
				hitBox.shape = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[block].shape
			}
		}
	}
	function lookingAt() {
		// Checks blocks in front of the player to see which one they're looking at
		hitBox.pos = null
		hitBox.closest = 1e9

		if (p.spectator) {
			return
		}
		let blockState = world.getBlock(p2.x, p2.y, p2.z)
		if (blockState) {
			hitBox.pos = [p2.x, p2.y, p2.z]
			hitBox.closest = 0
			hitBox.shape = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[blockState].shape
			return
		}

		let pd = p.direction

		let minX = p2.x
		let maxX = 0
		let minY = p2.y
		let maxY = 0
		let minZ = p2.z
		let maxZ = 0

		for (let i = 0; i < reach + 1; i++) {
			if (i > reach) {
				i = reach
			}
			maxX = round(p.x + pd.x * i)
			maxY = round(p.y + pd.y * i)
			maxZ = round(p.z + pd.z * i)
			if (maxX === minX && maxY === minY && maxZ === minZ) {
				continue
			}
			if (minX !== maxX) {
				if (minY !== maxY) {
					if (minZ !== maxZ) {
						runRayTrace(maxX, maxY, maxZ)
					}
					runRayTrace(maxX, maxY, minZ)
				}
				if (minZ !== maxZ) {
					runRayTrace(maxX, minY, maxZ)
				}
				runRayTrace(maxX, minY, minZ)
			}
			if (minY !== maxY) {
				if (minZ !== maxZ) {
					runRayTrace(minX, maxY, maxZ)
				}
				runRayTrace(minX, maxY, minZ)
			}
			if (minZ !== maxZ) {
				runRayTrace(minX, minY, maxZ)
			}
			if (hitBox.pos) {
				return //The ray has collided; it can't possibly find a closer collision now
			}
			minZ = maxZ
			minY = maxY
			minX = maxX
		}
	}
	let inBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.topH
		let ih = h + p.bottomH + p.topH
		let ix = x - w/2 - p.w
		let iw = w + p.w*2
		let iz = z - d/2 - p.w
		let id = d + p.w*2
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id
	}
	let onBox = function(x, y, z, w, h, d) {
		let iy = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(y - h/2 - p.topH)
		let ih = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(h + p.bottomH + p.topH)
		let ix = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(x - w/2 - p.w)
		let iw = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(w + p.w*2)
		let iz = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(z - d/2 - p.w)
		let id = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(d + p.w*2)
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id
	}
	function collided(x, y, z, vx, vy, vz, block) {
		if(p.spectator) {
			return false
		}
		let verts = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[block].shape.verts
		let px = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(p.x - p.w - x)
		let py = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(p.y - p.bottomH - y)
		let pz = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(p.z - p.w - z)
		let pxx = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(p.x + p.w - x)
		let pyy = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(p.y + p.topH - y)
		let pzz = (0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.roundBits)(p.z + p.w - z)
		let minX, minY, minZ, maxX, maxY, maxZ, min, max

		//Top and bottom faces
		let faces = verts[0]
		if (vy <= 0) {
			faces = verts[1]
		}
		if (!vx && !vz) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minZ = min[2]
				max = face.max
				maxX = max[0]
				maxZ = max[2]
				if (face[1] > py && face[1] < pyy && minX < pxx && maxX > px && minZ < pzz && maxZ > pz) {
					col = true
					if (vy <= 0) {
						p.onGround = true
						p.y = round((face[1] + y + p.bottomH) * 10000) / 10000
						p.velocity.y = 0
					}
					else {
						p.y = face[1] + y - p.topH - 0.01
					}
				}
			}
			return col
		}

		//West and East faces
		if (vx < 0) {
			faces = verts[4]
		}
		else if (vx > 0) {
			faces = verts[5]
		}
		if (vx) {
			let col = false
			for (let face of faces) {
				min = face.min
				minZ = min[2]
				minY = min[1]
				max = face.max
				maxZ = max[2]
				maxY = max[1]
				if (face[0] > px && face[0] < pxx && minY < pyy && maxY > py && minZ < pzz && maxZ > pz) {
					if (maxY - py > 0.5 || !p.onGround) {
						p.canStepX = false
						p.x = x + face[0] + (vx < 0 ? p.w : -p.w) * 1.001
					}
					col = true
				}
			}
			return col
		}

		//South and North faces
		if (vz < 0) {
			faces = verts[2]
		}
		else if (vz > 0) {
			faces = verts[3]
		}
		if (vz) {
			let col = false
			for (let face of faces) {
				min = face.min
				minX = min[0]
				minY = min[1]
				max = face.max
				maxX = max[0]
				maxY = max[1]
				if (face[2] > pz && face[2] < pzz && minY < pyy && maxY > py && minX < pxx && maxX > px) {
					if (maxY - py > 0.5 || !p.onGround) {
						p.canStepZ = false
						p.z = z + face[2] + (vz < 0 ? p.w : -p.w) * 1.001
					}
					col = true
				}
			}
			return col
		}
	}
	let contacts = {
		array: [],
		size: 0,
		add: function(x, y, z, block) {
			if (this.size === this.array.length) {
				this.array.push([x, y, z, block])
			}
			else {
				this.array[this.size][0] = x
				this.array[this.size][1] = y
				this.array[this.size][2] = z
				this.array[this.size][3] = block
			}
			this.size++
		},
		clear: function() {
			this.size = 0
		},
	}
	let resolveContactsAndUpdatePosition = function() {
		let mag = p.velocity.mag()
		let steps = Math.ceil(mag)
		const VX = p.velocity.x / steps
		const VY = p.velocity.y / steps
		const VZ = p.velocity.z / steps

		let pminX = floor(p.x - p.w + (p.velocity.x < 0 ? p.velocity.x : 0))
		let pmaxX = ceil(p.x + p.w + (p.velocity.x > 0 ? p.velocity.x : 0))
		let pminY = floor(p.y - p.bottomH + (p.velocity.y < 0 ? p.velocity.y : 0))
		let pmaxY = ceil(p.y + p.topH    + (p.velocity.y > 0 ? p.velocity.y : 0))
		let pminZ = floor(p.z - p.w + (p.velocity.z < 0 ? p.velocity.z : 0))
		let pmaxZ = ceil(p.z + p.w + (p.velocity.z > 0 ? p.velocity.z : 0))
		let block = null

		for (let y = pmaxY; y >= pminY; y--) {
			for (let x = pminX; x <= pmaxX; x++) {
				for (let z = pminZ; z <= pmaxZ; z++) {
					let block = world.getBlock(x, y, z)
					if (_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[block].solid) {
						contacts.add(x, y, z, block)
					}
				}
			}
		}

		let hasCollided = false
		p.px = p.x
		p.py = p.y
		p.pz = p.z
		for (let j = 1; j <= steps && !hasCollided; j++) {
			let px = p.x
			let pz = p.z

			//Check collisions in the Y direction
			p.onGround = false
			p.canStepX = false
			p.canStepZ = false
			p.y += VY
			for (let i = 0; i < contacts.size; i++) {
				block = contacts.array[i]
				if (collided(block[0], block[1], block[2], 0, VY, 0, block[3])) {
					p.velocity.y = 0
					hasCollided = true
					break
				}
			}
			if (p.onGround) {
				p.canStepX = true
				p.canStepZ = true
			}

			var sneakLock = false, sneakSafe = false
			if (p.sneaking) {
				for (let i = 0; i < contacts.size; i++) {
					block = contacts.array[i]
					if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
						sneakLock = true
						break
					}
				}
			}

			//Check collisions in the X direction
			p.x += VX
			for (let i = 0; i < contacts.size; i++) {
				block = contacts.array[i]
				if (collided(block[0], block[1], block[2], VX, 0, 0, block[3])) {
					if (p.canStepX && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					p.velocity.x = 0
					hasCollided = true
					break
				}
				if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
					sneakSafe = true
				}
			}

			if (sneakLock && !sneakSafe) {
				p.x = px
				p.velocity.x = 0
				hasCollided = true
			}
			sneakSafe = false

			//Check collisions in the Z direction
			p.z += VZ
			for (let i = 0; i < contacts.size; i++) {
				block = contacts.array[i]
				if (collided(block[0], block[1], block[2], 0, 0, VZ, block[3])) {
					if (p.canStepZ && !world.getBlock(block[0], block[1] + 1, block[2]) && !world.getBlock(block[0], block[1] + 2, block[2])) {
						continue
					}
					// p.z = p.pz
					p.velocity.z = 0
					hasCollided = true
					break
				}
				if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
					sneakSafe = true
				}
			}

			if (sneakLock && !sneakSafe) {
				p.z = pz
				p.velocity.z = 0
				hasCollided = true
			}
		}
		

		if (!p.flying) {
			let drag = p.onGround ? 0.5 : 0.85
			p.velocity.z += p.velocity.z * drag - p.velocity.z
			p.velocity.x += p.velocity.x * drag - p.velocity.x
		}
		else {
			let drag = 0.9
			p.velocity.z += p.velocity.z * drag - p.velocity.z
			p.velocity.x += p.velocity.x * drag - p.velocity.x
			p.velocity.y += p.velocity.y * 0.8 - p.velocity.y
			if (p.onGround && !p.spectator) {
				p.flying = false
			}
		}

		p.lastUpdate = performance.now()
		contacts.clear()
		lookingAt()
	}
	let runGravity = function() {
		if (p.flying) {
			return
		}

		p.velocity.y += p.gravityStrength
		if(p.velocity.y < -p.maxYVelocity) {
			p.velocity.y = -p.maxYVelocity
		}
		if(p.onGround) {
			if(controlMap.jump.pressed) {
				p.velocity.y = p.jumpSpeed
				p.onGround = false
			}
		}
	}

	function box2(sides, tex) {
		if (blockFill) {
			let i = 0
			for (let side in _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.Block) {
				if (sides & _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.Block[side]) {
					(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.vertexAttribPointer)(gl, glCache, "aVertex", program3D, "aVertex", 3, sideEdgeBuffers[_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.Sides[side]])
					;(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.vertexAttribPointer)(gl, glCache, "aTexture", program3D, "aTexture", 2, texCoordsBuffers[_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureMap[tex[i]]])
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0)
				}
				i++
			}
		}
		if (blockOutlines) {
			(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.vertexAttribPointer)(gl, glCache, "aVertex", program3D, "aVertex", 3, hitBox.shape.buffer)
			;(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.vertexAttribPointer)(gl, glCache, "aTexture", program3D, "aTexture", 2, texCoordsBuffers[_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureMap.hitbox])
			for (let i = 0; i < hitBox.shape.size; i++) {
				gl.drawArrays(gl.LINE_LOOP, i * 4, 4)
			}
		}
	}
	function block2(x, y, z, t, camera) {
		if (camera) {
			camera.transformation.translate(x, y, z)
			;(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.uniformMatrix)(gl, glCache, "view3d", program3D, "uView", false, camera.getMatrix())
		}
		else {
			//copyArr(modelView, matrix)
			(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.trans)(modelView, x, y, z)
			matMult()
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.trans)(modelView, -x, -y, -z)
			;(0,_js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.transpose)(matrix)
			;(0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.uniformMatrix)(gl, glCache, "view3d", program3D, "uView", false, matrix)
		}
		box2(0xff, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[t].textures)
	}

	function changeWorldBlock(t) {
		let pos = hitBox.pos
		if(pos && pos[1] > 0 && pos[1] < maxHeight) {
			let shape = t && _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[t].shape
			if (t && shape.rotate) {
				let pi = Math.PI / 4
				if (p.ry > pi) { // If not north
					if (p.ry < 3 * pi) {
						t |= WEST
					}
					else if (p.ry < 5 * pi) {
						t |= SOUTH
					}
					else if (p.ry < 7 * pi) {
						t |= EAST
					}
				}
			}

			if (t && shape.flip && hitBox.face !== "top" && (hitBox.face === "bottom" || (p.direction.y * hitBox.closest + p.y) % 1 < 0.5)) {
				t |= FLIP
			}

			world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t)
			if (t) {
				p.lastPlace = now
			}
			else {
				p.lastBreak = now
			}
		}
	}
	function newWorldBlock() {
		if(!hitBox.pos || !holding) {
			return
		}
		let pos = hitBox.pos, x= pos[0], y = pos[1], z = pos[2]
		switch(hitBox.face) {
			case "top":
				y += 1
				break
			case "bottom":
				y -= 1
				break
			case "south":
				z -= 1
				break
			case "north":
				z += 1
				break
			case "west":
				x -= 1
				break
			case "east":
				x += 1
				break
		}
		if (!inBox(x, y, z, 1, 1, 1) && !world.getBlock(x, y, z)) {
			pos[0] = x
			pos[1] = y
			pos[2] = z
			changeWorldBlock(holding < 0xff ? holding | blockMode : holding)
		}
	}

	let renderedChunks = 0

	/*
	function interpolateShadows(shadows, x, y) {
		let sx = (shadows[1] - shadows[0]) * x + shadows[0]
		let sx2 = (shadows[3] - shadows[2]) * x + shadows[2]
		return (sx2 - sx) * y + sx
	}
	*/

	let analytics = {
		totalTickTime: 0,
		worstFrameTime: 0,
		totalRenderTime: 0,
		totalFrameTime: 0,
		lastUpdate: 0,
		frames: 1,
		displayedTickTime: "0",
		displayedRenderTime: "0",
		displayedFrameTime: "0",
		displayedwFrameTime: 0,
		fps: 0,
	}
	function chunkDist(c) {
		let dx = p.x - c.x
		let dz = p.z - c.z
		if (dx > 16) {
			dx -= 16
		}
		else if (dx > 0) {
			dx = 0
		}
		if (dz > 16) {
			dz -= 16
		}
		else if (dz > 0) {
			dz = 0
		}
		return Math.sqrt(dx * dx + dz * dz)
	}
	function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
		let dx1 = p.x - c1.x - 8
		let dy1 = p.z - c1.z - 8
		let dx2 = p.x - c2.x - 8
		let dy2 = p.z - c2.z - 8
		return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2)
	}
	function fillReqs(x, z) {
		// Chunks must all be loaded first.
		var done = true
		for (let i = x - 3; i <= x + 3; i++) {
			for (let j = z - 3; j <= z + 3; j++) {
				let chunk = world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
				if (!chunk.generated) {
					world.generateQueue.push(chunk)
					done = false
				}
				if (!chunk.populated && i >= x - 2 && i <= x + 2 && j >= z - 2 && j <= z + 2) {
					world.populateQueue.push(chunk)
					done = false
				}
				if (world.loadFrom.length && !chunk.loaded && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.loadQueue.push(chunk)
					done = false
				}
				else if (!world.loadFrom.length && !chunk.loaded) {
					chunk.loaded = true
				}
				if (!chunk.lit && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.lightingQueue.push(chunk)
					done = false
				}
			}
		}
		return done
	}
	function maxDist(x, z, x2, z2) {
		let ax = abs(x2 - x)
		let az = abs(z2 - z)
		return max(ax, az)
	}
	function renderFilter(chunk) {
		return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= settings.renderDistance
	}

	function debug(message) {
		let ellapsed = performance.now() - debug.start
		if (ellapsed > 30) {
			console.log(message, ellapsed.toFixed(2), "milliseconds")
		}
	}

	let alerts = []
	function chatAlert(msg) {
		alerts.push({
			msg: msg.substr(0, 50),
			born: now
		})
		if (alerts.length > 5) alerts.shift()
		updateHUD = true
	}
	function renderChatAlerts() {
		if (!alerts.length) return
		textSize(20)
		let y = height - 150
		for (let i = alerts.length - 1; i >= 0; i--) {
			let alert = alerts[i]
			text(alert.msg, 50, y)
			y -= 50
		}
		while(alerts.length && now - alerts[0].born > 10000) {
			alerts.shift()
			updateHUD = true
		}
	}

	function chat(msg) {
		let lockScroll = false
		if (chatOutput.scrollTop + chatOutput.clientHeight + 50 > chatOutput.scrollHeight) {
			lockScroll = true
		}
		let div = document.createElement("div")
		div.className = "message"
		div.textContent = msg
		chatOutput.append(div)
		chatAlert(msg)
		if (lockScroll) {
			chatOutput.scroll(0, 10000000)
		}
	}

	function sendChat(msg) {
		if (multiplayer) {
			multiplayer.send(JSON.stringify({
				type: "chat",
				data: msg
			}))
		}
		chat(`${currentUser.username}: ${msg}`)
	}

	let commands = new Map()
	commands.set("ban", args => {
		let username = args.join(" ")
		if (!username) {
			chat(`Please provide a username. Like /ban Willard`)
			return
		}
		if (!window.ban) {
			chat("This is a singleplayer world. There's nobody to ban.")
			return
		}
		window.ban(username)
	})
	commands.set("online", args => {
		if (window.online && multiplayer) {
			window.online()
		} else {
			chat("You're all alone. Sorry.")
		}
	})

	function sendCommand(msg) {
		msg = msg.substr(1)
		let parts = msg.split(" ")
		let cmd = parts.shift()
		if (commands.has(cmd)) commands.get(cmd)(parts)
	}

	var multiplayer = null
	let playerPositions = {}
	let playerEntities = {}
	let playerDistances = []
	let currentUser = { username: "Player" }
	async function loggedIn() {
		let exists = await fetch("https://willard.fun/profile").then(res => res.text()).catch(() => "401")
		if (!exists || exists === "401") {
			if (location.href.startsWith("https://willard.fun")) {
				alert("You're not logged in. Head over to https://willard.fun/login to login or register before connecting to the server.")
			}
			else {
				alert("Multiplayer is currently only available on https://willard.fun/login => https://willard.fun/minekhan")
			}
			return false
		}
		currentUser = JSON.parse(exists)
		return true
	}

	async function initMultiplayer(target) {
		if (multiplayer) return
		let logged = await loggedIn()
		if (!logged) return

		let host = false
		if (!target) {
			target = world.id
			host = true
		}
		multiplayer = new WebSocket("wss://willard.fun/ws?target=" + target)
		multiplayer.onopen = () => {
			multiplayer.send(JSON.stringify({
				type: "connect"
			}))
			if (host) {
				multiplayer.send(JSON.stringify({
					type: "init",
					name: world.name
				}))
			}
			multiplayer.pos = setInterval(() => multiplayer.send(JSON.stringify({
				type: "pos",
				data: {x: p.x, y: p.y, z: p.z, vx: p.velocity.x, vy: p.velocity.y, vz: p.velocity.z}
			})), 500)
		}
		let multiplayerError = ""
		multiplayer.onmessage = msg => {
			let packet = JSON.parse(msg.data)
			if (packet.type === "setBlock") {
				let a = packet.data
				world.setBlock(a[0], a[1], a[2], a[3], false, true)
			}
			else if (packet.type === "genChunk") {
				// TO-DO: generate chunks
			}
			else if (packet.type === "connect") {
				if (host) {
					multiplayer.send(JSON.stringify({
						type: "save",
						data: world.getSaveString()
					}))
				}
				chat(`${packet.author} has joined.`)
			}
			else if (packet.type === "save" && screen === "multiplayer menu") {
				world = new World(true)
				world.loadSave(packet.data)
				changeScene("loading")
			}
			else if (packet.type === "users") {
				chat(packet.data.join(", "))
			}
			else if (packet.type === "ban") {
				chat(packet.data)
			}
			else if (packet.type === "pos") {
				let pos = packet.data
				let name = packet.author
				playerPositions[name] = pos
				if (!playerEntities[name]) playerEntities[name] = new _js_player_js__WEBPACK_IMPORTED_MODULE_19__.Player(pos.x, pos.y, pos.z, pos.vx, pos.vy, pos.vz, abs(name.hashCode()) % 80 + 1, glExtensions, gl, glCache, indexBuffer, world, p)
				let ent = playerEntities[name]
				ent.x = pos.x
				ent.y = pos.y
				ent.z = pos.z
				ent.velx = pos.vx || 0
				ent.vely = pos.vy || 0
				ent.velz = pos.vz || 0
				packet.data.time = now
			}
			else if (packet.type === "error") {
				multiplayerError = packet.data
			}
			else if (packet.type === "dc") {
				chat(`${packet.author} has disconnected.`)
				delete playerPositions[packet.author]
				delete playerEntities[packet.author]
			}
			else if (packet.type === "eval") { // Blocked server-side; Can only be sent directly from the server for announcements and live patches
				try {
					eval(packet.data)
				}
				catch(e) {
					// Do nothing
				}
			}
			else if (packet.type === "chat") {
				chat(`${packet.author}: ${packet.data}`)
			}
		}

		multiplayer.onclose = () => {
			if (!host) {
				alert(`Connection lost! ${multiplayerError}`)
				changeScene("main menu")
			}
			else {
				alert(`Connection lost! ${multiplayerError || "Willard probably restarted the server. You can re-open your world from the pause menu."}`)
			}
			clearInterval(multiplayer.pos)
			multiplayer = null
		}
		multiplayer.onerror = multiplayer.onclose

		window.online = function() {
			multiplayer.send("fetchUsers")
		}

		window.ban = function(username) {
			if (!multiplayer) {
				chat("Not in a multiplayer world.")
				return
			}
			if (!host) {
				chat("You don't have permission to do that.")
				return
			}
			multiplayer.send(JSON.stringify({
				type: "ban",
				data: username || ""
			}))
		}

		window.dists = () => {
			console.log(playerPositions)
			console.log(playerDistances)
			return playerEntities
		}
	}

	async function getWorlds() {
		let logged = await loggedIn()
		if (!logged) return []

		return await fetch("https://willard.fun/minekhan/worlds").then(res => res.json())
	}

	let fogDist = 16
	let frameCount = -3600

	_js_section_js__WEBPACK_IMPORTED_MODULE_16__.emptySection.setWorld(world)
	_js_section_js__WEBPACK_IMPORTED_MODULE_16__.emptySection.setCaves(caves)
	_js_section_js__WEBPACK_IMPORTED_MODULE_16__.fullSection.setWorld(world)
	_js_section_js__WEBPACK_IMPORTED_MODULE_16__.fullSection.setCaves(caves)

	class World {
		constructor(empty) {
			if (!empty) {
				setSeed(Math.random() * 2000000000 | 0)
				p.y = superflat ? 6 : round(_js_random_js__WEBPACK_IMPORTED_MODULE_8__.noiseProfile.noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra
			}

			generatedChunks = 0
			fogDist = 16

			//Initialize the world's arrays
			this.chunks = []
			this.loaded = []
			this.sortedChunks = []
			this.doubleRenderChunks = []
			this.offsetX = 0
			this.offsetZ = 0
			this.lwidth = 0
			this.chunkGenQueue = []
			this.populateQueue = []
			this.generateQueue = []
			this.lightingQueue = []
			this.loadQueue = []
			this.meshQueue = []
			this.loadFrom = []
			this.entities = []
			this.eventQueue = []
			this.lastChunk = ","
		}
		genChunk(chunk) {
			let trueX = chunk.x
			let trueZ = chunk.z

			if (chunk.generated) {
				return false
			}

			let smoothness = generator.smooth
			let hilliness = generator.height
			let gen = 0
			for (let i = 0; i < 16; i++) {
				for (let k = 0; k < 16; k++) {
					gen = superflat ? 4 : round(_js_random_js__WEBPACK_IMPORTED_MODULE_8__.noiseProfile.noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra
					chunk.tops[k * 16 + i] = gen

					chunk.setBlock(i, gen, k, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.grass)
					chunk.setBlock(i, gen - 1, k, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.dirt)
					chunk.setBlock(i, gen - 2, k, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.dirt)
					chunk.setBlock(i, gen - 3, k, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.dirt)
					for (let j = 1; j < gen - 3; j++) {
						chunk.setBlock(i, j, k, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.stone)
					}
					chunk.setBlock(i, 0, k, _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.bedrock)
				}
			}
			chunk.generated = true
		}
		getAdjacentSubchunks(x, y, z, lights) {
			let minChunkX = x - 16 >> 4
			let maxChunkX = x + 16 >> 4
			let minChunkY = y - 16 >> 4
			let maxChunkY = y + 16 >> 4
			let minChunkZ = z - 16 >> 4
			let maxChunkZ = z + 16 >> 4
			let section = null
			let ret = []
			for (x = minChunkX; x <= maxChunkX; x++) {
				for (let y = minChunkY; y <= maxChunkY; y++) {
					for (z = minChunkZ; z <= maxChunkZ; z++) {
						if (y < 0) {
							ret.push(lights ? _js_section_js__WEBPACK_IMPORTED_MODULE_16__.fullSection.light : _js_section_js__WEBPACK_IMPORTED_MODULE_16__.fullSection.blocks)
						}
						else if (this.chunks[x] && this.chunks[x][z]) {
							section = this.chunks[x][z].sections[y] || _js_section_js__WEBPACK_IMPORTED_MODULE_16__.emptySection
							ret.push(lights ? section.light : section.blocks)
						}
						else {
							ret.push(lights ? _js_section_js__WEBPACK_IMPORTED_MODULE_16__.emptySection.light : _js_section_js__WEBPACK_IMPORTED_MODULE_16__.emptySection.blocks)
						}
					}
				}
			}
			return ret
		}
		updateBlock(x, y, z, lazy) {
			let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4]
			if (chunk && chunk.buffer) {
				chunk.updateBlock(x & 15, y, z & 15, this, lazy, screen)
			}
		}
		getChunk(x, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			return this.loaded[X * this.lwidth + Z]
		}
		getWorldBlock(x, y, z) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				return _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.air
			}
			return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15)
		}
		getBlock(x, y, z) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (y > maxHeight) {
				return _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.air
			}
			else if (y < 0) {
				return _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockIds.bedrock
			}
			else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
				return this.getWorldBlock(x, y, z)
			}
			return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15)
		}
		setBlock(x, y, z, blockID, lazy, remote) {
			if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
				this.eventQueue.push([x, y, z, blockID])
				return
			}
			let chunk = this.chunks[x >> 4][z >> 4]
			if (!chunk.buffer && remote) {
				this.eventQueue.push([x, y, z, blockID])
				return
			}

			let xm = x & 15
			let zm = z & 15
			if (blockID) {
				chunk.setBlock(xm, y, zm, blockID, !lazy)
				let data = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[blockID]
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, true, data.lightLevel)
				}
			}
			else {
				let data = _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[chunk.getBlock(xm, y, zm)]
				chunk.deleteBlock(xm, y, zm, !lazy)
				if (!lazy && chunk.buffer && (!data.transparent || data.lightLevel) && screen !== "loading") {
					this.updateLight(x, y, z, false, data.lightLevel)
				}
			}

			if (lazy) {
				return
			}

			if (multiplayer && !remote && screen === "play") {
				multiplayer.send(JSON.stringify({
					type: "setBlock",
					data: [x, y, z, blockID]
				}))
			}

			//Update the 6 adjacent blocks and 1 changed block
			if (xm && xm !== 15 && zm && zm !== 15) {
				chunk.updateBlock(xm - 1, y, zm, this, lazy, screen)
				chunk.updateBlock(xm, y - 1, zm, this, lazy, screen)
				chunk.updateBlock(xm + 1, y, zm, this, lazy, screen)
				chunk.updateBlock(xm, y + 1, zm, this, lazy, screen)
				chunk.updateBlock(xm, y, zm - 1, this, lazy, screen)
				chunk.updateBlock(xm, y, zm + 1, this, lazy, screen)
			}
			else {
				this.updateBlock(x - 1, y, z, lazy, screen)
				this.updateBlock(x + 1, y, z, lazy, screen)
				this.updateBlock(x, y - 1, z, lazy, screen)
				this.updateBlock(x, y + 1, z, lazy, screen)
				this.updateBlock(x, y, z - 1, lazy, screen)
				this.updateBlock(x, y, z + 1, lazy, screen)
			}

			chunk.updateBlock(xm, y, zm, this, lazy, screen)

			// Update the corner chunks so shadows in adjacent chunks update correctly
			if (xm | zm === 0) {
				this.updateBlock(x - 1, y, z - 1, lazy, screen)
			}
			if (xm === 15 && zm === 0) {
				this.updateBlock(x + 1, y, z - 1, lazy, screen)
			}
			if (xm === 0 && zm === 15) {
				this.updateBlock(x - 1, y, z + 1, lazy, screen)
			}
			if (xm & zm === 15) {
				this.updateBlock(x + 1, y, z + 1, lazy, screen)
			}
		}
		getLight(x, y, z, blockLight = 0) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
				return this.chunks[x >> 4][z >> 4].getLight(x & 15, y, z & 15, blockLight)
			}
			return this.loaded[X * this.lwidth + Z].getLight(x & 15, y, z & 15, blockLight)
		}
		setLight(x, y, z, level, block) {
			let X = (x >> 4) + this.offsetX
			let Z = (z >> 4) + this.offsetZ
			if (this.loaded[X * this.lwidth + Z]) {
				return this.loaded[X * this.lwidth + Z].setLight(x & 15, y, z & 15, level, block)
			}
		}
		updateLight(x, y, z, place, blockLight = 0) {
			let chunk = this.getChunk(x, z)
			if (!chunk) return
			let cx = x & 15
			let cz = z & 15
			let center = chunk.getLight(cx, y, cz, 0)
			let blight = chunk.getLight(cx, y, cz, 1)
			let up = this.getLight(x, y+1, z)
			let down = this.getLight(x, y-1, z)
			let north = this.getLight(x, y, z+1)
			let south = this.getLight(x, y, z-1)
			let east = this.getLight(x+1, y, z)
			let west = this.getLight(x-1, y, z)

			let spread = []
			if (!place) { // Block was removed; increase light levels
				if ((up & 15) === 15) {
					for (let i = y; i > 0; i--) {
						if (_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 15)
							spread.push(x, i, z)
						}
						else {
							break
						}
					}
					chunk.spreadLight(spread, 14, true)
				}
				else {
					center = max(up, down, north, south, east, west)
					if (center > 0) center -= 1
					this.setLight(x, y, z, center)
					if (center > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, center - 1, true)
					}
				}

				// Block light levels
				if (!blockLight || blockLight < blight) {
					spread.length = 0
					up = this.getLight(x, y+1, z, 1)
					down = this.getLight(x, y-1, z, 1)
					north = this.getLight(x, y, z+1, 1)
					south = this.getLight(x, y, z-1, 1)
					east = this.getLight(x+1, y, z, 1)
					west = this.getLight(x-1, y, z, 1)
					blight = max(up, down, north, south, east, west)
					if (blight > 0) blight -= 1
					this.setLight(x, y, z, blight, 1)
					if (blight > 1) {
						spread.push(x, y, z)
						chunk.spreadLight(spread, blight - 1, true, 1)
					}
				}
			}
			else if (place && (center !== 0 || blight !== 0)) { // Block was placed; decrease light levels
				let respread = []
				// for (let i = 0; i <= center + 1; i++) respread[i] = []
				for (let i = 0; i <= 15; i++) respread[i] = []
				chunk.setLight(cx, y, cz, 0, 0)
				chunk.setLight(cx, y, cz, 0, 1)
				spread.push(x, y, z)

				// Sky light
				if (center === 15) {
					for (let i = y-1; i > 0; i--) {
						if (_js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.blockData[chunk.getBlock(cx, i, cz)].transparent) {
							chunk.setLight(cx, i, cz, 0)
							spread.push(x, i, z)
						}
						else {
							break
						}
					}
				}
				chunk.unSpreadLight(spread, center - 1, respread)
				chunk.reSpreadLight(respread)

				// Block light
				if (blight) {
					respread.length = 0
					// for (let i = 0; i <= blight + 1; i++) respread[i] = []
					for (let i = 0; i <= 15; i++) respread[i] = []
					spread.length = 0
					spread.push(x, y, z)
					chunk.unSpreadLight(spread, blight - 1, respread, 1)
					chunk.reSpreadLight(respread, 1)
				}
			}
			if (place && blockLight) { // Light block was placed
				this.setLight(x, y, z, blockLight, 1)
				spread.length = 0
				spread.push(x, y, z)
				chunk.spreadLight(spread, blockLight - 1, true, 1)

			}
			else if (!place && blockLight) { // Light block was removed
				this.setLight(x, y, z, 0, 1)
				spread.push(x, y, z)
				let respread = []
				for (let i = 0; i <= blockLight + 1; i++) respread[i] = []
				chunk.unSpreadLight(spread, blockLight - 1, respread, 1)
				chunk.reSpreadLight(respread, 1)
			}
		}
		spawnBlock(x, y, z, blockID) {
			//Sets a block anywhere without causing block updates around it. Only to be used in world gen.

			let chunkX = x >> 4
			let chunkZ = z >> 4
			if (!this.chunks[chunkX]) {
				this.chunks[chunkX] = []
			}
			let chunk = this.chunks[chunkX][chunkZ]
			if (!chunk) {
				chunk = new _js_chunk_js__WEBPACK_IMPORTED_MODULE_17__.Chunk(chunkX * 16, chunkZ * 16, world, glExtensions, gl, glCache, superflat, caves, trees)
				this.chunks[chunkX][chunkZ] = chunk
			}
			if (chunk.buffer) {
				//Only used if spawning a block post-gen
				this.setBlock(x, y, z, blockID, true)
			}
			else if (!chunk.getBlock(x & 15, y, z & 15)) {
				chunk.setBlock(x & 15, y, z & 15, blockID)
			}
		}
		async tick() {
			let maxChunkX = (p.x >> 4) + settings.renderDistance
			let maxChunkZ = (p.z >> 4) + settings.renderDistance
			let chunk = maxChunkX + "," + maxChunkZ
			if (chunk !== this.lastChunk) {
				this.lastChunk = chunk
				this.loadChunks()
				this.chunkGenQueue.sort(sortChunks)
			}

			if (controlMap.breakBlock.pressed && (p.lastBreak < now - 250 || p.autoBreak) && screen === "play") {
				changeWorldBlock(0)
			}
			if (controlMap.placeBlock.pressed && (p.lastPlace < now - 250 || p.autoBuild)) {
				newWorldBlock()
			}

			for (let i = 0; i < this.sortedChunks.length; i++) {
				this.sortedChunks[i].tick()
			}

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.update()
				if (entity.canDespawn) {
					this.entities.splice(i, 1)
				}
			}

			// Make sure there's only 1 "world gen" loop running at a time
			if (this.ticking) return
			this.ticking = true

			let doneWork = true
			while(doneWork && (screen === "play" || screen === "loading")) {
				doneWork = false
				debug.start = performance.now()
				if (this.meshQueue.length) {
					// Update all chunk meshes.
					do {
						this.meshQueue.pop().genMesh(indexBuffer, bigArray)
					} while(this.meshQueue.length)
					doneWork = true
					debug("Meshes")
				}

				if (this.generateQueue.length && !doneWork) {
					let chunk = this.generateQueue.pop()
					this.genChunk(chunk)
					doneWork = true
				}

				if (this.populateQueue.length && !doneWork) {
					let chunk = this.populateQueue[this.populateQueue.length - 1]
					if (!chunk.caves) {
						await chunk.carveCaves()
						debug("Carve caves")
					}
					else if (!chunk.populated) {
						chunk.populate(trees)
						this.populateQueue.pop()
					}
					doneWork = true
				}

				if (this.loadQueue.length && !doneWork) {
					this.loadQueue.pop().load()
					doneWork = true
				}

				if (this.lightingQueue.length && !doneWork) {
					this.lightingQueue.pop().fillLight()
					doneWork = true
				}

				if (this.chunkGenQueue.length && !doneWork) {
					let chunk = this.chunkGenQueue[0]
					if (!fillReqs(chunk.x >> 4, chunk.z >> 4)) {
						// The requirements haven't been filled yet; don't do anything else.
					}
					else if (!chunk.optimized) {
						chunk.optimize(screen)
						debug("Optimize")
					}
					else if (!chunk.buffer) {
						chunk.genMesh(indexBuffer, bigArray)
						debug("Initial mesh")
					}
					else {
						this.chunkGenQueue.shift()
						generatedChunks++
					}
					doneWork = true
				}

				// Yield the main thread to render passes
				if (doneWork) await window.yieldThread()
			}
			this.ticking = false
		}
		render() {
			initModelView(p)
			let skyLight
			if (multiplayer) {
				skyLight = min(max(abs(now % 1200000 - 600000) / 60000 - 3, 0.1), 1)
			}
			else {
				skyLight = min(max(abs(++frameCount % 7200 - 3600) / 360 - 3, 0.1), 1)
			}
			gl.clearColor(sky[0] * skyLight, sky[1] * skyLight, sky[2] * skyLight, 1)
			gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)

			p2.x = round(p.x)
			p2.y = round(p.y)
			p2.z = round(p.z)

			renderedChunks = 0

			let dist = settings.renderDistance * 16
			if (this.chunkGenQueue.length) {
				this.chunkGenQueue.sort(sortChunks)
				let chunk = this.chunkGenQueue[0]
				dist = min(dist, chunkDist(chunk))
			}
			if (dist !== fogDist) {
				if (fogDist < dist - 0.1) fogDist += (dist - fogDist) / 120
				else if (fogDist > dist + 0.1) fogDist += (dist - fogDist) / 30
				else fogDist = dist
			}
			gl.uniform3f(glCache.uPos, p.x, p.y, p.z)
			gl.uniform1f(glCache.uDist, fogDist)
			// this is interesting because uTime is not actually based on time
			// if you are going to change this to use actual time change line 4487 as well
			// since it depends on it
			gl.uniform1f(glCache.uTime, skyLight)

			let c = this.sortedChunks
			let glob = { renderedChunks }
			for (let chunk of c) {
				chunk.render(p, glob)
			}
			if (this.doubleRenderChunks.length) {
				gl.depthMask(false)
				gl.uniform1i(glCache.uTrans, 1)
				for (let chunk of this.doubleRenderChunks) {
					chunk.render(p, glob)
				}
				gl.uniform1i(glCache.uTrans, 0)
				gl.depthMask(true)
			}
			
			renderedChunks = glob.renderedChunks

			gl.uniform3f(glCache.uPos, 0, 0, 0)

			gl.useProgram(programEntity)

			for (let i = this.entities.length - 1; i >= 0; i--) {
				const entity = this.entities[i]
				entity.render()
			}

			if (multiplayer) {
				for (let name in playerEntities) {
					const entity = playerEntities[name]
					entity.update()
					entity.render()
				}
			}

			gl.useProgram(program3D)

			if(hitBox.pos) {
				blockOutlines = true
				blockFill = false
				block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0, p)
				blockOutlines = false
				blockFill = true
			}
		}
		loadChunks() {
			let renderDistance = settings.renderDistance + 3
			let cx = p.x >> 4
			let cz = p.z >> 4
			p.cx = cx
			p.cz = cz
			let minChunkX = cx - renderDistance
			let maxChunkX = cx + renderDistance
			let minChunkZ = cz - renderDistance
			let maxChunkZ = cz + renderDistance

			this.offsetX = -minChunkX
			this.offsetZ = -minChunkZ
			this.lwidth = renderDistance * 2 + 1
			this.chunkGenQueue.length = 0
			this.lightingQueue.length = 0
			this.populateQueue.length = 0
			this.generateQueue.length = 0

			if (this.loaded.length > this.lwidth * this.lwidth) {
				this.loaded.length = this.lwidth * this.lwidth
			}

			let i = 0
			for (let x = minChunkX; x <= maxChunkX; x++) {
				for (let z = minChunkZ; z <= maxChunkZ; z++) {
					let chunk
					if (!this.chunks[x]) {
						this.chunks[x] = []
					}
					if (!this.chunks[x][z]) {
						chunk = new _js_chunk_js__WEBPACK_IMPORTED_MODULE_17__.Chunk(x * 16, z * 16, world, glExtensions, gl, glCache, superflat, caves, trees)
						if (maxDist(cx, cz, x, z) <= settings.renderDistance) {
							this.chunkGenQueue.push(chunk)
						}
						this.chunks[x][z] = chunk
					}
					chunk = this.chunks[x][z]
					if (!chunk.buffer && !this.chunkGenQueue.includes(chunk) && maxDist(cx, cz, x, z) <= settings.renderDistance) {
						this.chunkGenQueue.push(chunk)
					}
					this.loaded[i++] = chunk
				}
			}
			this.sortedChunks.length = 0
			this.doubleRenderChunks.length = 0
			for (let chunk of this.loaded) {
				if (renderFilter(chunk)) {
					this.sortedChunks.push(chunk)
				}
				if (chunk.doubleRender) {
					this.doubleRenderChunks.push(chunk)
				}
			}
			this.sortedChunks = this.loaded.filter(renderFilter)
			this.sortedChunks.sort(sortChunks)
		}
		getSaveString() {
			let edited = []
			for (let x in this.chunks) {
				for (let z in this.chunks[x]) {
					let chunk = this.chunks[x][z]
					if (chunk.edited) {
						for (let y = 0; y < chunk.sections.length; y++) {
							if (chunk.sections[y].edited) {
								edited.push([chunk.sections[y], chunk.cleanSections[y]])
							}
						}
					}
				}
			}

			let pallete = {}
			for (let chunks of edited) {
				let changes = false
				chunks[0].blocks.forEach((id, i) => {
					if (id !== chunks[1][i]) {
						pallete[id] = true
						changes = true
					}
				})
				if (!changes) {
					chunks[0].edited = false
				}
			}

			let blocks = Object.keys(pallete).map(n => Number(n))
			pallete = {}
			blocks.forEach((block, index) => pallete[block] = index)

			let rnd = round
			let options = p.flying | superflat << 1 | p.spectator << 2 | caves << 3 | trees << 4

			let str = world.name + ";" + worldSeed.toString(36) + ";"
				+ rnd(p.x).toString(36) + "," + rnd(p.y).toString(36) + "," + rnd(p.z).toString(36) + ","
				+ (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + "," + options.toString(36) + ";"
				+ version + ";"
				+ blocks.map(b => b.toString(36)).join(",") + ";"

			for (let i = 0; i < edited.length; i++) {
				if (!edited[i][0].edited) {
					continue
				}
				let real = edited[i][0]
				let blocks = real.blocks
				let original = edited[i][1]
				str += (real.x / 16).toString(36) + "," + (real.y / 16).toString(36) + "," + (real.z / 16).toString(36) + ","
				for (let j = 0; j < original.length; j++) {
					if (blocks[j] !== original[j]) {
						str += (pallete[blocks[j]] << 12 | j).toString(36) + ","
					}
				}
				str = str.substr(0, str.length - 1) //Remove trailing comma
				str += ";"
			}
			if (str.match(/;$/)) str = str.substr(0, str.length - 1)
			return str
		}
		loadSave(str) {
			let data = str.split(";")
			if (!str.includes("Alpha")) {
				return this.loadOldSave(str)
			}

			this.name = data.shift()
			setSeed(parseInt(data.shift(), 36))

			let playerData = data.shift().split(",")
			p.x = parseInt(playerData[0], 36)
			p.y = parseInt(playerData[1], 36)
			p.z = parseInt(playerData[2], 36)
			p.rx = parseInt(playerData[3], 36) / 100
			p.ry = parseInt(playerData[4], 36) / 100
			let options = parseInt(playerData[5], 36)
			p.flying = options & 1
			p.spectator = options >> 2 & 1
			superflat = options >> 1 & 1
			caves = options >> 3 & 1
			trees = options >> 4 & 1

			let version = data.shift()
			this.version = version

			// if (version.split(" ")[1].split(".").join("") < 70) {
			// 	alert("This save code is for an older version. 0.7.0 or later is needed")
			// }

			let pallete = data.shift().split(",").map(n => parseInt(n, 36))
			this.loadFrom = []

			for (let i = 0; data.length; i++) {
				let blocks = data.shift().split(",")
				this.loadFrom.push({
					x: parseInt(blocks.shift(), 36),
					y: parseInt(blocks.shift(), 36),
					z: parseInt(blocks.shift(), 36),
					blocks: [],
				})
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36)
					let index = block & 0xffffff
					let pid = block >> 12
					this.loadFrom[i].blocks[index] = pallete[pid]
				}
			}
		}
		loadOldSave(str) {
			let data = str.split(";")
			setSeed(parseInt(data.shift(), 36))
			this.id = now
			this.name = "Old World " + (Math.random() * 1000 | 0)
			let playerData = data.shift().split(",")
			p.x = parseInt(playerData[0], 36)
			p.y = parseInt(playerData[1], 36)
			p.z = parseInt(playerData[2], 36)
			p.rx = parseInt(playerData[3], 36) / 100
			p.ry = parseInt(playerData[4], 36) / 100
			// let editCount = parseInt(data.shift(), 36)
			data.shift()

			this.loadFrom = []

			let coords = data.shift().split(",").map(function(n) {
				return parseInt(n, 36)
			})
			for (let j = 0; j < coords.length; j += 3) {
				this.loadFrom.push({
					x: coords[j],
					y: coords[j + 1],
					z: coords[j + 2],
					blocks: [],
				})
			}

			for (let i = 0; data.length > 0; i++) {
				let blocks = data.shift().split(",")
				for (let j = 0; j < blocks.length; j++) {
					let block = parseInt(blocks[j], 36)
					let index = block >> 8
					let id = block & 0x7f | (block & 0x80) << 1
					this.loadFrom[i].blocks[index] = id
				}
			}
		}
	}

	let controls = function() {
		move.x = 0
		move.z = 0

		if(controlMap.walkForwards.pressed) move.z += p.speed
		if(controlMap.walkBackwards.pressed) move.z -= p.speed
		if(controlMap.strafeLeft.pressed) move.x += p.speed
		if(controlMap.strafeRight.pressed) move.x -= p.speed
		if (p.flying) {
			if(controlMap.jump.pressed) p.velocity.y += 0.1
			if(controlMap.sneak.pressed) p.velocity.y -= 0.1
		}
		if(Key.ArrowLeft) p.ry -= 0.15
		if(Key.ArrowRight) p.ry += 0.15
		if(Key.ArrowUp) p.rx += 0.15
		if(Key.ArrowDown) p.rx -= 0.15

		if (!p.sprinting && controlMap.sprint.pressed && !p.sneaking && controlMap.walkForwards.pressed) {
			p.FOV(settings.fov + 10, 250)
			p.sprinting = true
		}

		if(p.sprinting) {
			move.x *= p.sprintSpeed
			move.z *= p.sprintSpeed
		}
		if(p.flying) {
			move.x *= p.flySpeed
			move.z *= p.flySpeed
		}
		if (!move.x && !move.z) {
			if (p.sprinting) {
				p.FOV(settings.fov, 100)
			}
			p.sprinting = false
		}
		else if(abs(move.x) > 0 && abs(move.z) > 0) {
			move.x *= move.ang
			move.z *= move.ang
		}

		//Update the velocity, rather than the position.
		let co = cos(p.ry)
		let si = sin(p.ry)
		let friction = p.onGround ? 1 : 0.3
		p.velocity.x += (co * move.x - si * move.z) * friction
		p.velocity.z += (si * move.x + co * move.z) * friction

		const TAU = Math.PI * 2
		const PI1_2 = Math.PI / 2
		while(p.ry > TAU) p.ry -= TAU
		while(p.ry < 0)   p.ry += TAU
		if(p.rx > PI1_2)  p.rx = PI1_2
		if(p.rx < -PI1_2) p.rx = -PI1_2
	}

	class Slider {
		constructor(x, y, w, h, scenes, label, min, max, settingName, callback) {
			this.x = x
			this.y = y
			this.h = h
			this.w = Math.max(w, 350)
			this.name = settingName
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.label = label
			this.min = min
			this.max = max
			this.sliding = false
			this.callback = callback
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let current = (settings[this.name] - this.min) / (this.max - this.min)

			// Outline
			ctx.beginPath()
			strokeWeight(2)
			stroke(0)
			fill(85)
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			ctx.stroke()
			ctx.fill()

			// Slider bar
			let value = round(settings[this.name])
			ctx.beginPath()
			fill(130)
			let x = this.x - (this.w - 10) / 2 + (this.w - 10) * current - 5
			ctx.fillRect(x, this.y - this.h / 2, 10, this.h)

			//Label
			fill(255, 255, 255)
			textSize(16)
			ctx.textAlign = 'center'
			text(`${this.label}: ${value}`, this.x, this.y + this.h / 8)
		}
		click() {
			if (!mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (mouseX > this.x - this.w / 2 && mouseX < this.x + this.w / 2 && mouseY > this.y - this.h / 2 && mouseY < this.y + this.h / 2) {
				let current = (mouseX - this.x + this.w / 2) / this.w
				if (current < 0) current = 0
				if (current > 1) current = 1
				this.sliding = true
				settings[this.name] = current * (this.max - this.min) + this.min
				this.callback(current * (this.max - this.min) + this.min)
				this.draw()
			}
		}
		drag() {
			if (!this.sliding || !this.scenes.includes(screen)) {
				return false
			}

			let current = (mouseX - this.x + this.w / 2) / this.w
			if (current < 0) current = 0
			if (current > 1) current = 1
			settings[this.name] = current * (this.max - this.min) + this.min
			this.callback(current * (this.max - this.min) + this.min)
		}
		release() {
			this.sliding = false
		}

		static draw() {
			for (let slider of Slider.all) {
				slider.draw()
			}
		}
		static click() {
			for (let slider of Slider.all) {
				slider.click()
			}
		}
		static release() {
			for (let slider of Slider.all) {
				slider.release()
			}
		}
		static drag() {
			if (mouseDown) {
				for (let slider of Slider.all) {
					slider.drag()
				}
			}
		}
		static add(x, y, w, h, scenes, label, min, max, defaut, callback) {
			Slider.all.push(new Slider(x, y, w, h, scenes, label, min, max, defaut, callback))
		}
	}
	Slider.all = []
	class Button {
		constructor(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			this.x = x
			this.y = y
			this.h = h
			this.w = w
			this.index = 0
			this.disabled = disabled || (() => false)
			this.hoverText = !hoverText || typeof hoverText === "string" ? () => hoverText : hoverText
			this.scenes = Array.isArray(scenes) ? scenes : [scenes]
			this.labels = Array.isArray(labels) ? labels : [labels]
			this.callback = callback
		}

		mouseIsOver() {
			return mouseX >= this.x - this.w / 2 && mouseX <= this.x + this.w / 2 && mouseY >= this.y - this.h / 2 && mouseY <= this.y + this.h / 2
		}
		draw() {
			if (!this.scenes.includes(screen)) {
				return
			}
			let hovering = this.mouseIsOver()
			let disabled = this.disabled()
			let hoverText = this.hoverText()

			// Outline
			ctx.beginPath()
			if (hovering && !disabled) {
				strokeWeight(7)
				stroke(255)
				cursor(HAND)
			}
			else {
				strokeWeight(3)
				stroke(0)
			}
			if (disabled) {
				fill(60)
			}
			else {
				fill(120)
			}
			ctx.rect(this.x - this.w / 2, this.y - this.h / 2, this.w, this.h)
			ctx.stroke()
			ctx.fill()

			//Label
			fill(255)
			textSize(16)
			ctx.textAlign = 'center'
			text(this.labels[this.index], this.x, this.y + this.h / 8)

			if (hovering && hoverText) {
				hoverbox.innerText = hoverText
				hoverbox.classList.remove("hidden")
				if (mouseY < height / 2) {
					hoverbox.style.bottom = ""
					hoverbox.style.top = mouseY + 10 + "px"
				}
				else {
					hoverbox.style.top = ""
					hoverbox.style.bottom = height - mouseY + 10 + "px"
				}
				if (mouseX < width / 2) {
					hoverbox.style.right = ""
					hoverbox.style.left = mouseX + 10 + "px"
				}
				else {
					hoverbox.style.left = ""
					hoverbox.style.right = width - mouseX + 10 + "px"
				}
			}
		}
		click() {
			if (this.disabled() || !mouseDown || !this.scenes.includes(screen)) {
				return false
			}

			if (this.mouseIsOver()) {
				this.index = (this.index + 1) % this.labels.length
				this.callback(this.labels[this.index])
				return true
			}
		}

		static draw() {
			hoverbox.classList.add("hidden")
			for (let button of Button.all) {
				button.draw()
			}
		}
		static click() {
			for (let button of Button.all) {
				if (button.click()) {
					Button.draw()
					break
				}
			}
		}
		static add(x, y, w, h, labels, scenes, callback, disabled, hoverText) {
			Button.all.push(new Button(x, y, w, h, labels, scenes, callback, disabled, hoverText))
		}
	}
	Button.all = []

	function initButtons() {
		Button.all = []
		Slider.all = []
		const nothing = () => false
		const always = () => true
		let survival = false

		// Main menu buttons
		Button.add(width / 2, height / 2 - 20, 400, 40, "Singleplayer", "main menu", () => {
			initWorldsMenu()
			changeScene("loadsave menu")
		})
		Button.add(width / 2, height / 2 + 35, 400, 40, "Multiplayer", "main menu", () => {
			initMultiplayerMenu()
			changeScene("multiplayer menu")
		}, () => !location.href.startsWith("https://willard.fun"), "Please visit https://willard.fun/login to enjoy multiplayer.")
		Button.add(width / 2, height / 2 + 90, 400, 40, "Options", "main menu", () => changeScene("options"))

		// Creation menu buttons
		Button.add(width / 2, 135, 300, 40, ["World Type: Normal", "World Type: Superflat"], "creation menu", r => superflat = r === "World Type: Superflat")
		Button.add(width / 2, 185, 300, 40, ["Trees: On", "Trees: Off"], "creation menu", r => trees = r === "Trees: On", function() {
			if (superflat) {
				this.index = 1
				trees = false
			}
			return superflat
		})
		Button.add(width / 2, 235, 300, 40, ["Caves: On", "Caves: Off"], "creation menu", r => caves = r === "Caves: On", function() {
			if (superflat) {
				this.index = 1
				caves = false
			}
			return superflat
		})
		Button.add(width / 2, 285, 300, 40, ["Game Mode: Creative", "Game Mode: Survival"], "creation menu", r => survival = r === "Game Mode: Survival")
		Button.add(width / 2, 335, 300, 40, "Difficulty: Peaceful", "creation menu", nothing, always, "Coming soon\n\nPlease stop asking for mobs. Adding them will take a very long time. I know a lot of people want them, so just be patient.")
		Button.add(width / 2, height - 90, 300, 40, "Create New World", "creation menu", () => {
			if (survival) {
				window.open("https://www.minecraft.net/en-us/store/minecraft-java-edition", "_blank")
				return
			}
			world = new World()
			world.id = "" + now + (Math.random() * 1000000 | 0)
			let name = boxCenterTop.value || "World"
			let number = ""
			let naming = true
			while(naming) {
				let match = false
				for (let id in worlds) {
					if (worlds[id].name === name + number) {
						match = true
						break
					}
				}
				if (match) {
					number = number ? number + 1 : 1
				}
				else {
					name = name + number
					naming = false
				}
			}
			world.name = name.replace(/;/g, "\u037e") // Greek question mark lol
			win.world = world
			world.loadChunks()
			world.chunkGenQueue.sort(sortChunks)
			changeScene("loading")
		})
		Button.add(width / 2, height - 40, 300, 40, "Cancel", "creation menu", () => changeScene(previousScreen))

		// Loadsave menu buttons
		const selected = () => !selectedWorld || !worlds[selectedWorld]
		let w4 = min(width / 4 - 10, 220)
		let x4 = w4 / 2 + 5
		let w2 = min(width / 2 - 10, 450)
		let x2 = w2 / 2 + 5
		let mid = width / 2
		Button.add(mid - 3 * x4, height - 30, w4, 40, "Edit", "loadsave menu", () => changeScene("editworld"), () => selected() || !worlds[selectedWorld].edited)
		Button.add(mid - x4, height - 30, w4, 40, "Delete", "loadsave menu", () => {
			if (worlds[selectedWorld] && confirm(`Are you sure you want to delete ${worlds[selectedWorld].name}? This will also delete it from the cloud.`)) {
				(0,_js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.deleteFromDB)(selectedWorld)
				window.worlds.removeChild(document.getElementById(selectedWorld))
				delete worlds[selectedWorld]
				fetch(`https://willard.fun/minekhan/saves/${selectedWorld}`, { method: "DELETE" })
				selectedWorld = 0
			}
		}, () => selected() || !worlds[selectedWorld].edited, "Delete the world forever.")
		Button.add(mid + x4, height - 30, w4, 40, "Export", "loadsave menu", () => {
			boxCenterTop.value = worlds[selectedWorld].code
		}, selected, "Export the save code into the text box above for copy/paste.")
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "loadsave menu", () => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "loadsave menu", async () => {
			world = new World(true)
			win.world = world

			let code
			if (!selectedWorld) {
				code = boxCenterTop.value
			}
			else {
				let data = worlds[selectedWorld]
				if (data) {
					world.id = data.id
					world.edited = data.edited
					if (data.code) code = data.code
					else {
						let cloudWorld = await fetch(`https://willard.fun/minekhan/saves/${selectedWorld}`).then(res => res.json())
						code = cloudWorld.code
					}
				}
			}

			if (code) {
				try {
					world.loadSave(code)
					world.id = world.id || "" + now + (Math.random() * 1000000 | 0)
				}
				catch(e) {
					alert("Unable to load save")
					return
				}
				changeScene("loading")
			}
		}, () => !(!selectedWorld && boxCenterTop.value) && !worlds[selectedWorld])
		Button.add(mid + x2, height - 75, w2, 40, "Create New World", "loadsave menu", () => changeScene("creation menu"))

		Button.add(mid, height / 2, w2, 40, "Save", "editworld", () => {
			let w = worlds[selectedWorld]
			w.name = boxCenterTop.value.replace(/;/g, "\u037e")
			let split = w.code.split(";")
			split[0] = w.name
			w.code = split.join(";")
			;(0,_js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.saveToDB)(w.id, w).then(() => {
				initWorldsMenu()
				changeScene("loadsave menu")
			}).catch(e => console.error(e))
		})
		Button.add(mid, height / 2 + 50, w2, 40, "Back", "editworld", () => changeScene(previousScreen))

		// Pause buttons
		Button.add(width / 2, 225, 300, 40, "Resume", "pause", play)
		Button.add(width / 2, 275, 300, 40, "Options", "pause", () => changeScene("options"))
		Button.add(width / 2, 325, 300, 40, "Save", "pause", save, nothing, () => `Save the world to your browser + account. Doesn't work in incognito.\n\nLast saved ${(0,_js_utils_js__WEBPACK_IMPORTED_MODULE_10__.timeString)(now - world.edited)}.`)
		Button.add(width / 2, 375, 300, 40, "Get Save Code", "pause", () => {
			savebox.classList.remove("hidden")
			saveDirections.classList.remove("hidden")
			savebox.value = world.getSaveString()
		})
		Button.add(width / 2, 425, 300, 40, "Open World To Public", "pause", () => {
			initMultiplayer()
		}, () => !!multiplayer || !location.href.startsWith("https://willard.fun"))
		Button.add(width / 2, 475, 300, 40, "Exit Without Saving", "pause", () => {
			savebox.value = world.getSaveString()
			if (multiplayer) {
				multiplayer.close()
			}
			initWorldsMenu()
			changeScene("main menu")
		})

		// Options buttons
		Button.add(width / 2, 455, width / 3, 40, "Back", "options", () => changeScene(previousScreen))

		// Comingsoon menu buttons
		Button.add(width / 2, 395, width / 3, 40, "Back", "comingsoon menu", () => changeScene(previousScreen))

		// Multiplayer buttons
		Button.add(mid + 3 * x4, height - 30, w4, 40, "Cancel", "multiplayer menu", () => changeScene("main menu"))
		Button.add(mid - x2, height - 75, w2, 40, "Play Selected World", "multiplayer menu", () => {
			world = new World()
			win.world = world

			if (selectedWorld) {
				initMultiplayer(selectedWorld)
			}
		}, () => !selectedWorld)

		// Settings Sliders
		Slider.add(width/2, 245, width / 3, 40, "options", "Render Distance", 1, 32, "renderDistance", val => settings.renderDistance = round(val))
		Slider.add(width/2, 305, width / 3, 40, "options", "FOV", 30, 110, "fov", val => {
			p.FOV(val)
			if (world) {
				p.setDirection()
				world.render()
			}
		})
		Slider.add(width/2, 365, width / 3, 40, "options", "Mouse Sensitivity", 30, 400, "mouseSense", val => settings.mouseSense = val)
	}

	function drawIcon(x, y, id) {
		id = id < 0xff ? id | blockMode : id
		x =  x / (3 * height) - 0.1666 * width / height
		y = y / (3 * height) - 0.1666
		initModelView(null, x, y, 0, 0, 0)

		let buffer = blockIcons[id]
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
		gl.vertexAttribPointer(glCache.aVertex, 3, gl.FLOAT, false, 24, 0)
		gl.vertexAttribPointer(glCache.aTexture, 2, gl.FLOAT, false, 24, 12)
		gl.vertexAttribPointer(glCache.aShadow, 1, gl.FLOAT, false, 24, 20)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)
		gl.drawElements(gl.TRIANGLES, blockIcons.lengths[id], gl.UNSIGNED_INT, 0)
	}

	function hotbar() {
		FOV(90)

		for(let i = 0; i < inventory.hotbar.length; i ++) {
			if(inventory.hotbar[i]) {
				let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25
				let y = height - inventory.size
				drawIcon(x, y, inventory.hotbar[i])
			}
		}
	}
	function hud() {
		if (p.spectator) {
			return
		}

		hotbar()

		let s = inventory.size
		let x = width / 2 + 0.5
		let y = height / 2 + 0.5

		// Crosshair
		if (!p.spectator) {
			ctx.lineWidth = 1
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.moveTo(x - 10, y)
			ctx.lineTo(x + 10, y)
			ctx.moveTo(x, y - 10)
			ctx.lineTo(x, y + 10)
			ctx.stroke()
		}

		//Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5

		ctx.strokeStyle = "black"
		ctx.lineWidth = 2
		ctx.beginPath()
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= 9; i++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		ctx.strokeStyle = "white"
		ctx.lineWidth = 2
		ctx.beginPath()

		ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s)

		let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
		+ "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
		+ "Render Time: " + analytics.displayedRenderTime + "ms\n"
		+ "Tick Time: " + analytics.displayedTickTime + "ms\n"
		+ "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
		+ "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
		+ "FPS: " + analytics.fps

		if (p.autoBreak) {
			text("Super breaker enabled", 5, height - 89, 12)
		}
		if (p.autoBuild) {
			text("Hyper builder enabled", 5, height - 101, 12)
		}
		if (multiplayer) {
			playerDistances.length = 0
			let closest = Infinity
			let cname = "Yourself"
			for (let name in playerPositions) {
				let pos = playerPositions[name]
				let distance = sqrt((pos.x - p2.x)*(pos.x - p2.x) + (pos.y - p2.y)*(pos.y - p2.y) + (pos.z - p2.z)*(pos.z - p2.z))
				playerDistances.push({
					name,
					distance
				})
				if (distance < closest) {
					closest = distance
					cname = name
				}
			}
			text(`Closest player: ${cname} (${round(closest)} blocks away)`, 5, height - 113, 12)
		}

		ctx.textAlign = 'right'
		text(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0)
		ctx.textAlign = 'left'
		text(str, 5, height - 77, 12)
	}
	function drawInv() {
		let x = 0
		let y = 0
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13

		gl.clearColor(0, 0, 0, 0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		ctx.fillStyle = "rgb(127, 127, 127)"
		ctx.fillRect(0, 0, canvas.width, canvas.height)
		FOV(90)

		// Draw the grid
		ctx.lineWidth = 1
		ctx.strokeStyle = "black"
		ctx.beginPath()
		for (y = 0; y < 10; y++) {
			ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s)
			ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s)
		}
		y--
		for (x = 0; x < perRow + 1; x++) {
			ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2)
			ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s)
		}

		// Hotbar
		x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25
		y = height - s * 1.5 + 0.5
		ctx.moveTo(x, y)
		ctx.lineTo(x + s * 9, y)
		ctx.moveTo(x, y + s)
		ctx.lineTo(x + s * 9, y + s)
		for(let i = 0; i <= inventory.hotbar.length; i ++) {
			ctx.moveTo(x + i * s, y)
			ctx.lineTo(x + i * s, y + s)
		}
		ctx.stroke()

		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			x += s * overHot
			ctx.lineWidth = 2
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.strokeRect(x, y, s, s)
		}

		//Box highlight in inv
		let overInv = round((mouseY - 50) / s) * perRow + round((mouseX - 50) / s)
		if (overInv >= 0 && overInv < _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.BLOCK_COUNT - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow * s + 50 - s2
			y = (overInv / perRow | 0) * s + 50 - s2
			ctx.lineWidth = 2
			ctx.strokeStyle = "white"
			ctx.beginPath()
			ctx.strokeRect(x, y, s, s)
		}

		if (inventory.holding) {
			drawIcon(mouseX, mouseY, inventory.holding)
		}
		for (let i = 1; i < _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.BLOCK_COUNT; i++) {
			x = (i - 1) % perRow * s + 50
			y = ((i - 1) / perRow | 0) * s + 50
			drawIcon(x, y, i)
		}

		hotbar()
		//hud()
		ctx.drawImage(gl.canvas, 0, 0)
	}
	function clickInv() {
		let s = inventory.size
		let s2 = s / 2
		let perRow = 13
		let over = round((mouseY - 50) / s) * perRow + round((mouseX - 50) / s)
		let x = width / 2 - 9 / 2 * s + 25
		let y = height - s * 1.5
		let overHot = (mouseX - x) / s | 0
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			let temp = inventory.hotbar[overHot]
			inventory.hotbar[overHot] = inventory.holding
			inventory.holding = temp
		}
		else if (over >= 0 && over < _js_blockData_js__WEBPACK_IMPORTED_MODULE_11__.BLOCK_COUNT - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			inventory.holding = over + 1
		}
		else {
			inventory.holding = 0
		}

		drawScreens.inventory()
	}

	let unpauseDelay = 0
	function mmoved(e) {
		let mouseS = settings.mouseSense / 30000
		p.rx -= e.movementY * mouseS
		p.ry += e.movementX * mouseS

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2
		}
	}
	function trackMouse(e) {
		if (screen !== "play") {
			cursor("")
			mouseX = e.x
			mouseY = e.y
			drawScreens[screen]()
			Button.draw()
			Slider.draw()
			Slider.drag()
		}
	}

	// For user controls that react immediately in the event handlers.
	function controlEvent(name, event) {
		if (name === controlMap.cycleBlockShapes.key) {
			blockMode = blockMode === CUBE ? SLAB : blockMode === SLAB ? STAIR : CUBE
			updateHUD = true
		}

		if(screen === "play") {
			if (document.pointerLockElement !== canvas) {
				getPointer()
				p.lastBreak = now
			}
			else {
				if (name === controlMap.breakBlock.key) {
					changeWorldBlock(0)
				}

				// holding = inventory.hotbar[inventory.hotbarSlot]
				if(name === controlMap.placeBlock.key && holding) {
					newWorldBlock()
				}

				if (name === controlMap.pickBlock.key && hitBox.pos) {
					updateHUD = true
					let block = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]) & 0x3ff
					let index = inventory.hotbar.indexOf(block)
					if (index >= 0) {
						inventory.hotbarSlot = index
					}
					else {
						inventory.hotbar[inventory.hotbarSlot] = block
					}
				}

				if(name === controlMap.pause.key) {
					releasePointer()
					changeScene("pause")
				}

				if (name === controlMap.openChat.key) {
					event.preventDefault()
					changeScene("chat")
				}

				if(name === controlMap.superBreaker.key) {
					p.autoBreak = !p.autoBreak
					updateHUD = true
				}

				if(name === controlMap.hyperBuilder.key) {
					p.autoBuild = !p.autoBuild
					updateHUD = true
				}

				if (name === controlMap.jump.key && !p.spectator) {
					if (now < p.lastJump + 400) {
						p.flying = !p.flying
					}
					else {
						p.lastJump = now
					}
				}

				if (name === controlMap.zoom.key) {
					p.FOV(10, 300)
				}

				if (name === controlMap.sneak.key && !p.flying) {
					p.sneaking = true
					if (p.sprinting) {
						p.FOV(settings.fov, 100)
					}
					p.sprinting = false
					p.speed = 0.05
					p.bottomH = 1.32
				}

				if (name === controlMap.toggleSpectator.key) {
					p.spectator = !p.spectator
					p.flying = true
					p.onGround = false
					updateHUD = true
				}

				if (name === controlMap.openInventory.key) {
					changeScene("inventory")
					releasePointer()
				}

				if (name === "Semicolon") {
					releasePointer()
					freezeFrame = true
				}

				if (name === controlMap.dropItem.key) {
					let d = p.direction
					world.entities.push(new _js_item_js__WEBPACK_IMPORTED_MODULE_18__.Item(p.x, p.y, p.z, d.x/4, d.y/4, d.z/4, holding || inventory.hotbar[inventory.hotbarSlot], glExtensions, gl, glCache, indexBuffer, world, p))
				}
			}
		}
		else if (screen === "pause" && name === controlMap.pause.key) {
			play()
		}
		else if (screen === "inventory") {
			if (name === "leftMouse") {
				clickInv()
			}
			if (name === controlMap.openInventory.key) {
				play()
			}
			if (name === controlMap.cycleBlockShapes.key) {
				drawScreens.inventory()
			}
		}
	}
	document.onmousemove = trackMouse
	document.onpointerlockchange = function() {
		if (document.pointerLockElement === canvas) {
			document.onmousemove = mmoved
		}
		else {
			document.onmousemove = trackMouse
			if (screen === "play" && !freezeFrame) {
				changeScene("pause")
				unpauseDelay = now + 1000
			}
		}
		for (let key in Key) {
			Key[key] = false
		}
	}
	canvas.onmousedown = function(e) {
		mouseX = e.x
		mouseY = e.y
		mouseDown = true
		let name
		switch(e.button) {
			case 0:
				if (Key.ControlRight || Key.ControlLeft) name = "rightMouse"
				else name = "leftMouse"
				break
			case 1:
				name = "middleMouse"
				break
			case 2:
				name = "rightMouse"
				break
		}
		Key[name] = true
		controlEvent(name)

		Button.click()
		Slider.click()
	}
	canvas.onmouseup = function(e) {
		let name
		switch(e.button) {
			case 0:
				if (Key.ControlRight || Key.ControlLeft) name = "rightMouse"
				else name = "leftMouse"
				break
			case 1:
				name = "middleMouse"
				break
			case 2:
				name = "rightMouse"
				break
		}
		Key[name] = false
		mouseDown = false
		Slider.release()
	}
	canvas.onkeydown = function(e) {
		let code = e.code
		if (code === "Space" || code === "ArrowDown" || code === "ArrowUp") {
			e.preventDefault()
		}
		if (e.repeat || Key[code]) {
			return
		}
		Key[code] = true

		controlEvent(code, e)

		if (screen === "play" && Number(e.key)) {
			inventory.hotbarSlot = e.key - 1
			holding = inventory.hotbar[inventory.hotbarSlot]
			updateHUD = true
		}
	}
	canvas.onkeyup = function(e) {
		Key[e.code] = false
		if(e.code === "Escape" && (screen === "chat" || screen === "pause" || screen === "inventory" || screen === "options" && previousScreen === "pause") && now > unpauseDelay) {
			play()
		}
		if (screen === "play") {
			if (e.code === controlMap.zoom.key) {
				p.FOV(settings.fov, 300)
			}

			if (e.code === controlMap.sneak.key && p.sneaking) {
				p.sneaking = false
				p.speed = 0.11
				p.bottomH = 1.62
			}
		}
	}
	canvas.onblur = function() {
		for (let key in Key) {
			Key[key] = false
		}
		mouseDown = false
		Slider.release()
	}
	canvas.oncontextmenu = function(e) {
		e.preventDefault()
	}
	window.onbeforeunload = e => {
		if (screen === "play" && Key.control) {
			releasePointer()
			e.preventDefault()
			e.returnValue = "Q is the sprint button; Ctrl + W closes the page."
			return true
		}
	}
	canvas.onwheel = e => {
		e.preventDefault()
		e.stopPropagation()
		if (e.deltaY > 0) {
			inventory.hotbarSlot++
		}
		else if (e.deltaY < 0) {
			inventory.hotbarSlot--
		}
		if (inventory.hotbarSlot > 8) {
			inventory.hotbarSlot = 0
		}
		else if (inventory.hotbarSlot < 0) {
			inventory.hotbarSlot = 8
		}

		updateHUD = true
		holding = inventory.hotbar[inventory.hotbarSlot]
	}
	document.onwheel = () => {} // Shouldn't do anything, but it helps with a Khan Academy bug somewhat
	window.onresize = () => {
		width = window.innerWidth
		height = window.innerHeight
		canvas.height = height
		canvas.width = width
		gl.canvas.height = height
		gl.canvas.width = width
		gl.viewport(0, 0, width, height)
		initButtons()
		initBackgrounds()
		inventory.size = 40 * min(width, height) / 600
		genIcons()
		use3d()
		p.FOV(p.currentFov + 0.0001)

		if (screen === "play") {
			play()
		}
		else {
			drawScreens[screen]()
			Button.draw()
			Slider.draw()
		}
	}
	chatInput.onkeyup = e => {
		if (e.key === "Enter") {
			let msg = chatInput.value.trim()
			if (msg) {
				e.preventDefault()
				e.stopPropagation()
				if (msg.startsWith("/")) {
					sendCommand(msg)
				} else {
					sendChat(msg)
				}
				chatInput.value = ""
			}
			else {
				play()
			}
		}
		else if (e.key === "Escape") {
			e.preventDefault()
			e.stopPropagation()
			play()
			chatInput.value = ""
		}
	}

	function use2d() {
		gl.disableVertexAttribArray(glCache.aTexture)
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aVertex)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.useProgram(program2D)

		gl.enableVertexAttribArray(glCache.aVertex2)
		gl.enableVertexAttribArray(glCache.aTexture2)
		gl.enableVertexAttribArray(glCache.aShadow2)
	}
	function use3d() {
		gl.disableVertexAttribArray(glCache.aTexture2)
		gl.disableVertexAttribArray(glCache.aShadow2)
		gl.disableVertexAttribArray(glCache.aVertex2)
		gl.useProgram(program3D)

		gl.enableVertexAttribArray(glCache.aVertex)
		gl.enableVertexAttribArray(glCache.aTexture)
		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
	}

	let maxLoad = 1
	function startLoad() {
		// Runs when the loading screen is opened; cache the player's position
		p2.x = p.x
		p2.y = p.y
		p2.z = p.z
		maxLoad = world.loadFrom.length + 9
	}
	function initWebgl() {
		if (!win.gl) {
			let canv = document.createElement('canvas')
			canv.width = ctx.canvas.width
			canv.height = ctx.canvas.height
			canv.style.position = "absolute"
			canv.style.zIndex = -1
			canv.style.top = "0px"
			canv.style.left = "0px"
			gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false })
			let ext = gl.getExtension('OES_element_index_uint')
			if (!ext) {
				alert("Please use a supported browser, or update your current browser.")
			}
			gl.viewport(0, 0, canv.width, canv.height)
			gl.enable(gl.DEPTH_TEST)
			gl.enable(gl.BLEND)
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA)
			win.gl = gl
			glExtensions = []
			const availableExtensions = gl.getSupportedExtensions()
			for (let i = 0; i < availableExtensions.length; i++) {
				const extensionName = availableExtensions[i]
				glExtensions[extensionName.replace(/[A-Z]+_/g, "")] = gl.getExtension(extensionName)
			}
		}
		else {
			gl = win.gl
		}

		if (!document.body.contains(gl.canvas)) {
			document.body.append(gl.canvas)
		}

		modelView = new Float32Array(16)
		glCache = {}
		win.glCache = glCache
		program3D = (0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.createProgramObject)(gl, _shaders_blockVertexShader_glsl__WEBPACK_IMPORTED_MODULE_0__["default"], _shaders_blockFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__["default"])
		program2D = (0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.createProgramObject)(gl, _shaders_2dVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], _shaders_2dFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_3__["default"])
		programEntity = (0,_js_glUtils_js__WEBPACK_IMPORTED_MODULE_14__.createProgramObject)(gl, _shaders_entityVertexShader_glsl__WEBPACK_IMPORTED_MODULE_4__["default"], _shaders_entityFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_5__["default"])

		gl.useProgram(program2D)
		glCache.uSampler2 = gl.getUniformLocation(program2D, "uSampler")
		glCache.aTexture2 = gl.getAttribLocation(program2D, "aTexture")
		glCache.aVertex2 = gl.getAttribLocation(program2D, "aVertex")
		glCache.aShadow2 = gl.getAttribLocation(program2D, "aShadow")

		gl.useProgram(programEntity)
		glCache.uSamplerEntity = gl.getUniformLocation(programEntity, "uSampler")
		glCache.uLightLevelEntity = gl.getUniformLocation(programEntity, "uLightLevel")
		glCache.uViewEntity = gl.getUniformLocation(programEntity, "uView")
		glCache.aTextureEntity = gl.getAttribLocation(programEntity, "aTexture")
		glCache.aVertexEntity = gl.getAttribLocation(programEntity, "aVertex")

		gl.useProgram(program3D)
		glCache.uSampler = gl.getUniformLocation(program3D, "uSampler")
		glCache.uPos = gl.getUniformLocation(program3D, "uPos")
		glCache.uDist = gl.getUniformLocation(program3D, "uDist")
		glCache.uTime = gl.getUniformLocation(program3D, "uTime")
		glCache.uSky = gl.getUniformLocation(program3D, "uSky")
		glCache.uTrans = gl.getUniformLocation(program3D, "uTrans")
		glCache.aShadow = gl.getAttribLocation(program3D, "aShadow")
		glCache.aSkylight = gl.getAttribLocation(program3D, "aSkylight")
		glCache.aBlocklight = gl.getAttribLocation(program3D, "aBlocklight")
		glCache.aTexture = gl.getAttribLocation(program3D, "aTexture")
		glCache.aVertex = gl.getAttribLocation(program3D, "aVertex")

		gl.uniform1f(glCache.uDist, 1000)
		gl.uniform3f(glCache.uSky, sky[0], sky[1], sky[2])
		gl.uniform1i(glCache.uTrans, 0)

		//Send the block textures to the GPU
		;(0,_js_texture_js__WEBPACK_IMPORTED_MODULE_15__.initTextures)(gl, glCache)
		genIcons()
		initShapes()

		// These buffers are only used for drawing the main menu blocks
		sideEdgeBuffers = {}
		for (let side in _js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes.cube.verts) {
			let edgeBuffer = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer)
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(_js_shapes_js__WEBPACK_IMPORTED_MODULE_13__.shapes.cube.verts[side][0]), gl.STATIC_DRAW)
			sideEdgeBuffers[side] = edgeBuffer
		}
		texCoordsBuffers = []
		for (let t in _js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureCoords) {
			let buff = gl.createBuffer()
			gl.bindBuffer(gl.ARRAY_BUFFER, buff)
			gl.bufferData(gl.ARRAY_BUFFER, _js_texture_js__WEBPACK_IMPORTED_MODULE_15__.textureCoords[t], gl.STATIC_DRAW)
			texCoordsBuffers.push(buff)
		}

		//Bind the Vertex Array Object (VAO) that will be used to draw everything
		indexBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW)

		//Tell it not to render the insides of blocks
		gl.enable(gl.CULL_FACE)
		gl.cullFace(gl.BACK)

		gl.lineWidth(2)
		blockOutlines = false
		gl.enable(gl.POLYGON_OFFSET_FILL)
		gl.polygonOffset(1, 1)
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
	}
	function initBackgrounds() {
		// Home screen background
		use3d()
		gl.clearColor(sky[0], sky[1], sky[2], 1.0)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		FOV(100)
		const HALF_PI = Math.PI / 2
		initModelView(null, 0, 0.5, 0, -HALF_PI / 25, -HALF_PI / 3)
		gl.disableVertexAttribArray(glCache.aShadow)
		gl.disableVertexAttribArray(glCache.aSkylight)
		gl.disableVertexAttribArray(glCache.aBlocklight)
		gl.vertexAttrib1f(glCache.aShadow, 1.0)
		gl.vertexAttrib1f(glCache.aSkylight, 1.0)
		gl.vertexAttrib1f(glCache.aBlocklight, 1.0)

		{
			const blocks = Int8Array.of(
				7, 4, 1, 7,
				7, 4, 2, 7,
				7, 4, 3, 7,
				7, 4, 4, 7,
				7, 5, 1, 7,
				7, 5, 2, 7,
				7, 5, 3, 7,
				6, 4, 0, 7,
				6, 4, 1, 7,
				6, 4, 2, 7,
				6, 4, 3, 7,
				6, 4, 4, 7,
				6, 5, 0, 7,
				6, 5, 1, 7,
				6, 5, 2, 7,
				6, 5, 3, 7,
				6, 5, 4, 7,
				6, 6, 3, 7,
				6, 6, 4, 7,
				6, 7, 3, 7,
				5, 0, -1, 1,
				5, 0, 0, 1,
				5, 0, 1, 1,
				5, 0, 2, 1,
				5, 1, 2, 29,
				5, 2, 2, 29,
				5, 3, 2, 29,
				5, 4, 2, 29,
				5, 5, 2, 29,
				5, 6, 2, 29,
				5, 4, 0, 7,
				5, 4, 1, 7,
				5, 4, 3, 7,
				5, 4, 4, 7,
				5, 5, 0, 7,
				5, 5, 1, 7,
				5, 5, 3, 7,
				5, 5, 4, 7,
				5, 6, 1, 7,
				5, 6, 3, 7,
				5, 7, 1, 7,
				5, 7, 2, 7,
				5, 7, 3, 7,
				4, -1, -1, 1,
				4, -1, 0, 1,
				4, -1, 1, 1,
				4, -1, 2, 1,
				4, 0, 3, 1,
				4, 0, 4, 1,
				4, 0, 5, 1,
				4, 0, 6, 1,
				4, 0, 7, 1,
				4, 0, 8, 1,
				4, 0, 9, 1,
				4, 0, 10, 1,
				4, 4, 0, 7,
				4, 4, 1, 7,
				4, 4, 2, 7,
				4, 4, 3, 7,
				4, 4, 4, 7,
				4, 5, 0, 7,
				4, 5, 1, 7,
				4, 5, 2, 7,
				4, 5, 3, 7,
				4, 5, 4, 7,
				4, 6, 1, 7,
				4, 6, 2, 7,
				4, 6, 3, 7,
				4, 7, 4, 7,
				3, -1, -1, 1,
				3, -1, 0, 1,
				3, -1, 1, 1,
				3, -1, 2, 1,
				3, -1, 3, 1,
				3, -1, 4, 1,
				3, 0, 5, 1,
				3, 0, 6, 1,
				3, 0, 7, 1,
				3, 0, 8, 1,
				3, 0, 9, 1,
				3, 0, 10, 1,
				3, 4, 1, 7,
				3, 4, 2, 7,
				3, 4, 3, 7,
				3, 4, 4, 7,
				3, 5, 1, 7,
				3, 5, 2, 7,
				3, 5, 3, 7,
				2, -1, -1, 1,
				2, -1, 0, 1,
				2, -1, 1, 1,
				2, -1, 2, 1,
				2, -1, 3, 1,
				2, -1, 4, 1,
				2, -1, 5, 1,
				2, -1, 6, 1,
				2, -1, 7, 1,
				2, 0, 8, 1,
				2, 0, 9, 1,
				2, 0, 10, 1,
				1, -2, -1, 1,
				1, -2, 0, 1,
				1, -2, 1, 1,
				1, -2, 2, 1,
				1, -2, 3, 1,
				1, -1, 4, 1,
				1, -1, 5, 1,
				1, -1, 6, 1,
				1, -1, 7, 1,
				1, -1, 8, 1,
				1, -1, 9, 1,
				1, -1, 10, 1,
				0, -2, -1, 1,
				0, -2, 0, 1,
				0, -2, 1, 1,
				0, -2, 2, 1,
				0, -2, 3, 1,
				0, -2, 4, 1,
				0, -2, 5, 1,
				0, -1, 6, 1,
				0, -1, 7, 1,
				0, -1, 8, 1,
				0, -1, 9, 1,
				0, -1, 10, 1,
				-1, -2, -1, 1,
				-1, -2, 0, 1,
				-1, -2, 1, 1,
				-1, -2, 2, 1,
				-1, -2, 3, 1,
				-1, -2, 4, 1,
				-1, -2, 5, 1,
				-1, -2, 6, 1,
				-1, -2, 7, 1,
				-1, -1, 8, 1,
				-1, -1, 9, 1,
				-1, -1, 10, 1,
				-2, -2, -1, 1,
				-2, -2, 0, 1,
				-2, -2, 1, 1,
				-2, -2, 2, 1,
				-2, -2, 3, 1,
				-2, -2, 4, 1,
				-2, -2, 5, 1,
				-2, -2, 6, 1,
				-2, -2, 7, 1,
				-2, -2, 8, 1,
				-2, -2, 9, 1,
				-2, -1, 10, 1,
				-3, -2, -1, 1,
				-3, -2, 0, 1,
				-3, -2, 1, 1,
				-3, -2, 2, 1,
				-3, -2, 3, 1,
				-3, -2, 4, 1,
				-3, -2, 5, 1,
				-3, -2, 6, 1,
				-3, -2, 7, 1,
				-3, -2, 8, 1,
				-3, -2, 9, 1,
				-3, -2, 10, 1,
				-3, -2, 11, 1,
				-3, -2, 12, 1,
				-4, -2, -1, 1,
				-4, -2, 0, 1,
				-4, -2, 1, 1,
				-4, -2, 2, 1,
				-4, -2, 3, 1,
				-4, -2, 4, 1,
				-4, -2, 5, 1,
				-4, -2, 6, 1,
				-4, -2, 7, 1,
				-4, -2, 8, 1,
				-4, -2, 9, 1,
				-4, -2, 10, 1,
				-4, -2, 11, 1,
				-4, -2, 12, 1,
				-5, -2, -1, 1,
				-5, -2, 0, 1,
				-5, -2, 1, 1,
				-5, -2, 2, 1,
				-5, -2, 3, 1,
				-5, -2, 4, 1,
				-5, -2, 5, 1,
				-5, -2, 6, 1,
				-5, -2, 7, 1,
				-5, -2, 8, 1,
				-5, -2, 9, 1,
				-5, -2, 10, 1,
				-5, -2, 11, 1,
				-5, -2, 12, 1,
				-6, -2, -1, 1,
				-6, -2, 0, 1,
				-6, -2, 1, 1,
				-6, -2, 2, 1,
				-6, -2, 3, 1,
				-6, -2, 4, 1,
				-6, -2, 5, 1,
				-6, -2, 6, 1,
				-6, -2, 7, 1,
				-6, -2, 8, 1,
				-6, -2, 9, 1,
				-6, -2, 10, 1,
				-6, -2, 11, 1,
				-7, -2, 3, 1,
				-7, -2, 4, 1,
				-7, -2, 5, 1,
				-7, -2, 6, 1,
				-7, -2, 7, 1,
				-7, -2, 8, 1,
				-7, -2, 9, 1,
				-8, -2, 2, 1,
				-8, -2, 3, 1,
				-8, -2, 4, 1,
				-8, -2, 5, 1,
				-8, -2, 6, 1,
				-8, -2, 7, 1,
				-8, -2, 8, 1,
			)

			for (let i = 0; i < blocks.length; i += 4) {
				block2(blocks[i + 0], blocks[i + 1], blocks[i + 2], blocks[i + 3])
			}
		}

		gl.enableVertexAttribArray(glCache.aShadow)
		gl.enableVertexAttribArray(glCache.aSkylight)
		gl.enableVertexAttribArray(glCache.aBlocklight)
		let pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		mainbg = ctx.createImageData(width, height)
		let w = width * 4
		for (let i = 0; i < pixels.length; i += 4) {
			let x = i % w
			let y = height - floor(i / w) - 1
			let j = y * w + x
			mainbg.data[j] = pixels[i]
			mainbg.data[j + 1] = pixels[i + 1]
			mainbg.data[j + 2] = pixels[i + 2]
			mainbg.data[j + 3] = pixels[i + 3]
		}

		// Dirt background
		use2d()
		let aspect = width / height
		let stack = height / 96
		let bright = 0.4
		if (dirtBuffer) {
			gl.deleteBuffer(dirtBuffer)
		}
		dirtBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, dirtBuffer)
		let bgCoords = new Float32Array([
			-1, -1, 0, stack, bright,
			1, -1, stack * aspect, stack, bright,
			1, 1, stack * aspect, 0, bright,
			-1, 1, 0, 0, bright
		])
		gl.bufferData(gl.ARRAY_BUFFER, bgCoords, gl.STATIC_DRAW)
		gl.uniform1i(glCache.uSampler2, 1)
		gl.clearColor(0, 0, 0, 1)
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
		gl.vertexAttribPointer(glCache.aVertex2, 2, gl.FLOAT, false, 20, 0)
		gl.vertexAttribPointer(glCache.aTexture2, 2, gl.FLOAT, false, 20, 8)
		gl.vertexAttribPointer(glCache.aShadow2, 1, gl.FLOAT, false, 20, 16)
		gl.drawArrays(gl.TRIANGLE_FAN, 0, 4)
		pixels = new Uint8Array(width * height * 4)
		gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels)
		dirtbg = ctx.createImageData(width, height)
		dirtbg.data.set(pixels)
	}
	function initPlayer() {
		p = new Camera()
		p.speed = 0.11
		p.velocity = new _js_3Dutils_js__WEBPACK_IMPORTED_MODULE_9__.PVector(0, 0, 0)
		p.pos = new Float32Array(3)
		p.sprintSpeed = 1.5
		p.flySpeed = 3.75
		p.x = 8
		p.y = superflat ? 6 : 70
		p.z = 8
		p.w = 3 / 8
		p.bottomH = 1.62
		p.topH = 0.18
		p.onGround = false
		p.jumpSpeed = 0.45
		p.sprinting = false
		p.maxYVelocity = 1.5
		p.gravityStrength = -0.091
		p.lastUpdate = performance.now()
		p.lastBreak = now
		p.lastPlace = now
		p.lastJump = now
		p.autoBreak = false
		p.autoBuild = false
		p.flying = false
		p.sneaking = false
		p.spectator = false

		win.player = p
		win.p2 = p2
	}

	function sanitize(text) {
		const el = document.createElement('div')
		el.textContent = text
		return el.innerHTML
	}

	function initWorldsMenu() {
		while (window.worlds.firstChild) {
			window.worlds.removeChild(window.worlds.firstChild)
		}
		selectedWorld = 0
		window.boxCenterTop.value = ""

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		function addWorld(name, version, size, id, edited, cloud) {
			let div = document.createElement("div")
			div.className = "world"
			div.onclick = () => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + sanitize(name) + "</strong>" + br

			if (edited){
				let str = new Date(edited).toLocaleDateString(undefined, {
					year: "numeric",
					month: "short",
					day: "numeric",
					hour: "numeric",
					minute: "2-digit"
				})
				div.innerHTML += str + br
			}
			div.innerHTML += version + br
			if (cloud) div.innerHTML += `Cloud Save (${size.toLocaleString()} bytes)`
			else div.innerHTML += `${size.toLocaleString()} bytes used`

			window.worlds.appendChild(div)
		}

		worlds = {}
		if (loadString) {
			try {
				let tempWorld = new World(true)
				tempWorld.loadSave(loadString)
				addWorld(`${tempWorld.name} (Pre-loaded)`, tempWorld.version, loadString.length, now)
				worlds[now] = {
					code: loadString,
					id: now
				}
			}
			catch(e) {
				console.log("Unable to load hardcoded save.")
				console.error(e)
			}
		}
		(0,_js_indexDB_js__WEBPACK_IMPORTED_MODULE_12__.loadFromDB)().then(async res => {
			if(res && res.length) {
				let index = res.findIndex(obj => obj.id === "settings")
				if (index >= 0) {
					Object.assign(settings, res[index].data) // Stored data overrides any hardcoded settings
					p.FOV(settings.fov)
					res.splice(index, 1)
				}
			}

			if (res && res.length) {
				res = res.map(d => d.data).filter(d => d && d.code).sort((a, b) => b.edited - a.edited)
				for (let data of res) {
					addWorld(data.name, data.version, data.code.length + 60, data.id, data.edited, false)
					data.cloud = false
					worlds[data.id] = data
				}
			}

			let cloudSaves = await fetch('https://willard.fun/minekhan/saves').then(res => res.json())
			if (Array.isArray(cloudSaves) && cloudSaves.length) {
				for (let data of cloudSaves) {
					if (worlds[data.id] && worlds[data.id].edited >= data.edited) continue

					addWorld(data.name, data.version, data.size + 60, data.id, data.edited, true)
					data.cloud = true
					worlds[data.id] = data
				}
			}

			window.worlds.onclick = Button.draw
			window.boxCenterTop.onkeyup = Button.draw
		}).catch(e => console.error(e))

		superflat = false
		trees = true
		caves = true
	}

	async function initMultiplayerMenu() {
		while (window.worlds.firstChild) {
			window.worlds.removeChild(window.worlds.firstChild)
		}
		selectedWorld = 0
		window.boxCenterTop.value = ""

		const deselect = () => {
			let elem = document.getElementsByClassName("selected")
			if (elem && elem[0]) {
				elem[0].classList.remove("selected")
			}
		}

		let servers = await getWorlds()

		function addWorld(name, host, online, id) {
			let div = document.createElement("div")
			div.className = "world"
			div.onclick = () => {
				deselect()
				div.classList.add("selected")
				selectedWorld = id
			}
			let br = "<br>"
			div.id = id
			div.innerHTML = "<strong>" + sanitize(name) + "</strong>" + br

			div.innerHTML += "Hosted by " + sanitize(host) + br
			div.innerHTML += online + " players online" + br

			window.worlds.appendChild(div)
		}

		worlds = {}

		for (let data of servers) {
			addWorld(data.name, data.host, data.online, data.target)
			worlds[data.target] = data
		}
		window.worlds.onclick = Button.draw
		window.boxCenterTop.onkeyup = Button.draw
	}

	function initEverything() {
		console.log("Initializing world.")

		generatedChunks = 0

		initPlayer()
		initWebgl()

		if (win.location.origin === "https://www.kasandbox.org" && (loadString || MineKhan.toString().length !== 183240)) {
			// Prevent Ctrl F
			message.innerHTML = '.oot lanigiro eht tuo kcehc ot>rb<erus eb ,siht ekil uoy fI>rb<.dralliW yb >a/<nahKeniM>"wen_"=tegrat "8676731005517465/cm/sc/gro.ymedacanahk.www//:sptth"=ferh a< fo>rb<ffo-nips a si margorp sihT'.split("").reverse().join("")
		}

		initBackgrounds()

		drawScreens[screen]()
		Button.draw()
		Slider.draw()

		p.FOV(settings.fov)
		initWorldsMenu()
		initButtons()

		// See if a user followed a link here.
		var urlParams = new URLSearchParams(window.location.search)
		if (urlParams.has("target")) {
			changeScene("multiplayer menu")
			initMultiplayer(urlParams.get("target"))
		}

		if (window.parent.tickid) window.clearTimeout(window.parent.tickid)
		tickLoop()
	}

	// Define all the scene draw functions
	(function() {
		function title() {
			let title = "MINEKHAN"
			let subtext = "JAVASCRIPT EDITION"
			let font = "VT323,monospace"
			strokeWeight(1)
			ctx.textAlign = 'center'

			ctx.font = "bold 120px " + font
			fill(30)
			text(title, width / 2, 158)
			fill(40)
			text(title, width / 2, 155)
			ctx.font = "bold 121px " + font
			fill(50)
			text(title, width / 2, 152)
			fill(70)
			text(title, width / 2, 150)
			fill(90)
			ctx.font = "bold 122px " + font
			text(title, width / 2, 148)
			fill(110)
			text(title, width / 2, 145)

			ctx.font = "bold 32px " + font
			fill(50)
			text(subtext, width / 2-1, 180)
			text(subtext, width / 2+1, 180)
			text(subtext, width / 2, 179)
			text(subtext, width / 2, 181)
			ctx.font = "bold 32px " + font
			fill(150)
			text(subtext, width / 2, 180)
		}
		const clear = () => ctx.clearRect(0, 0, canvas.width, canvas.height)
		const dirt = () => ctx.putImageData(dirtbg, 0, 0)

		drawScreens["main menu"] = () => {
			ctx.putImageData(mainbg, 0, 0)
			title()
			fill(220)
			ctx.font = "20px VT323"
			ctx.textAlign = 'left'
			text("Minecraft " + version, width - (width - 2), height - 2)
		}

		drawScreens.play = () => {
			if (updateHUD) {
				clear()
				gl.clearColor(0, 0, 0, 0)
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT)
				hud()
				ctx.drawImage(gl.canvas, 0, 0)
				updateHUD = false
				freezeFrame = false
				renderChatAlerts()
				textSize(10)
				gl.clearColor(sky[0], sky[1], sky[2], 1.0)
			}
			let renderStart = performance.now()
			p.setDirection()
			world.render()
			analytics.totalRenderTime += performance.now() - renderStart
		}

		drawScreens.loading = () => {
			// This is really stupid, but it basically works by teleporting the player around to each chunk I'd like to load.
			// If chunks loaded from a save aren't generated, they're deleted from the save, so this loads them all.

			let sub = maxLoad - world.loadFrom.length - 9
			let standing = true
			if (world.loadFrom.length) {
				let load = world.loadFrom[0]
				p.x = load.x * 16
				p.y = load.y * 16
				p.z = load.z * 16
				standing = false
			}
			else {
				p.x = p2.x
				p.y = p2.y
				p.z = p2.z

				let cx = p.x >> 4
				let cz = p.z >> 4

				for (let x = cx - 1; x <= cx + 1; x++) {
					for (let z = cz - 1; z <= cz + 1; z++) {
						if (!world.chunks[x] || !world.chunks[x][z] || !world.chunks[x][z].buffer) {
							standing = false
						}
						else {
							sub++
						}
					}
				}
			}

			if (standing) {
				play()
				return
			}

			world.tick()

			let progress = round(100 * sub / maxLoad)
			dirt()
			fill(255)
			textSize(30)
			ctx.textAlign = "center"
			text(`Loading... ${progress}% complete (${sub} / ${maxLoad})`, width / 2, height / 2)
		}

		drawScreens.inventory = drawInv

		drawScreens.pause = () => {
			strokeWeight(1)
			clear()
			ctx.drawImage(gl.canvas, 0, 0)

			textSize(60)
			fill(0, 0, 0)
			ctx.textAlign = 'center'
			text("Paused", width / 2, 60)
		}

		drawScreens.options = () => {
			clear()
		}
		drawScreens["creation menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Create New World", width / 2, 20)
		}
		drawScreens["loadsave menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Select World", width / 2, 20)
		}
		drawScreens.editworld = dirt
		drawScreens["multiplayer menu"] = () => {
			dirt()
			ctx.textAlign = 'center'
			textSize(20)
			fill(255)
			text("Select Server", width / 2, 20)
		}
	})()

	// Give the font time to load and redraw the homescreen
	setTimeout(() => {
		drawScreens[screen]()
		Button.draw()
		Slider.draw()
	}, 100)

	function tickLoop() {
		window.parent.tickid = window.setTimeout(tickLoop, 50) // 20 TPS

		if (world && screen === "play") {
			controls()
			runGravity()
			resolveContactsAndUpdatePosition()
			// if (p.y < 6.12) {
			// 	console.log(p.y)
			// }

			let tickStart = performance.now()
			world.tick()
			analytics.ticks++
			analytics.totalTickTime += performance.now() - tickStart
		}
	}

	function renderLoop() {
		now = Date.now()
		let frameStart = performance.now()
		if (!gl) {
			initEverything()
			releasePointer()
		}

		if (screen === "play" || screen === "loading") {
			try {
				drawScreens[screen]()
			}
			catch(e) {
				console.error(e)
			}
		}

		if (now - analytics.lastUpdate > 500 && analytics.frames) {
			analytics.displayedTickTime = (analytics.totalTickTime / analytics.ticks).toFixed(1)
			analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1)
			analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1)
			analytics.fps = round(analytics.frames * 1000 / (now - analytics.lastUpdate))
			analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1)
			analytics.frames = 0
			analytics.totalRenderTime = 0
			analytics.totalTickTime = 0
			analytics.ticks = 0
			analytics.totalFrameTime = 0
			analytics.worstFrameTime = 0
			analytics.lastUpdate = now
			updateHUD = true
		}

		analytics.frames++
		analytics.totalFrameTime += performance.now() - frameStart
		analytics.worstFrameTime = max(performance.now() - frameStart, analytics.worstFrameTime)
		win.raf = requestAnimationFrame(renderLoop)
	}
	return renderLoop
}

window.onload = async function() {
	var init = await MineKhan()
	if (window.parent.raf) {
		window.cancelAnimationFrame(window.parent.raf)
		console.log("Canceled", window.parent.raf)
	}
	init()
}

})();

/******/ })()
;</script></body>
</html>

<!-- function hcyl(bottom, height, radius, id) {
	let radsq = radius * radius
	let innerRadsq = (radius - 1.2) * (radius - 1.2)
	height += bottom
	for (let x = -radius; x <= radius; x++) {
		for (let y = bottom; y < height; y++) {
			for (let z = -radius; z <= radius; z++) {
				let d = x * x + z * z
				if (d < radsq && d >= innerRadsq) {
					world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
				}
			}
		}
	}
}

function cyl(bottom, height, radius, id) {
	let radsq = radius * radius
	height += bottom
	for (let x = -radius; x <= radius; x++) {
		for (let y = bottom; y < height; y++) {
			for (let z = -radius; z <= radius; z++) {
				let d = x * x + z * z
				if (d < radsq) {
					world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
				}
			}
		}
	}
}

function sphereoid(w, h, d, id) {
	let w2 = w * w
	let h2 = h * h
	let d2 = d * d
	let w3 = (w - 1.5) * (w - 1.5)
	let h3 = (h - 1.5) * (h - 1.5)
	let d3 = (d - 1.5) * (d - 1.5)

	for (let y = -h; y < h; y++) {
		for (let x = -w; x <= w; x++) {
			for (let z = -d; z <= d; z++) {
				let n = x * x / w2 + y * y / h2 + z * z / d2
				let n2 = x * x / w3 + y * y / h3 + z * z / d3
				if (n < 1 && n2 >= 1) {
					world.setBlock(p2.x + x, p2.y + y, p2.z + z, id)
				}
			}
		}
	}
}

function sleep(ms) {
	return new Promise(resolve => setTimeout(() => resolve(), ms))
}

async function asphereoid(w, h, d, id) {
	let px = p2.x
	let py = p2.y
	let pz = p2.z
	let w2 = w * w
	let h2 = h * h
	let d2 = d * d
	let w3 = (w - 1.5) * (w - 1.5)
	let h3 = (h - 1.5) * (h - 1.5)
	let d3 = (d - 1.5) * (d - 1.5)

	for (let y = -h; y < h; y++) {
		for (let x = -w; x <= w; x++) {
			for (let z = -d; z <= d; z++) {
				let n = x * x / w2 + y * y / h2 + z * z / d2
				let n2 = x * x / w3 + y * y / h3 + z * z / d3
				if (n < 1 && n2 >= 1) {
					world.setBlock(px + x, py + y, pz + z, id)
					await sleep(10)
				}
			}
		}
	}
}
-->