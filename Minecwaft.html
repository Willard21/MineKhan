<!DOCTYPE html>
<!-- @Minecraft version Alpha 0.6
** If it doesn't load, google "how to enable WebGL on <name of your browser>" (note internet explorer probably won't work no matter what)

To save your progress, copy the save code you can get in the pause options, and paste it into "loadString" string just below these comments (around line 112), then save it as a spin-off.
Old saves may break in future updates, so if you're attached to your build, don't update without double checking that it works first.

	Controls:

 * Right-click (or ctrl click for mac users) - place block
 * Left-click - remove block
 * Middle-click - pick block
 * Q - sprint
 * W - Walk forward
 * S - Walk backward
 * A - Walk left
 * D - Walk right
 * E - Open inventory
 * B - Toggle super Breaker
 * Z - Zoom
 * L - Toggle Spectator mode
 * Enter - Toggle slab mode
 * X - Quake Pro FOV (Z to return to normal)
 * Arrow Keys - look around
 * P or Esc - pause/unpause
 * 1-9 navigate hotbar
 * Spacebar - jump
 * Double jump - toggle flight
 * Shift (flying) - fly down
 * Space (flying) - fly up
 * Delete - Forced restart (wipes the world and changes seeds)
 * T - Reload textures
 * ; (semicolon) - Release the pointer without pausing (for screenshots)

	Notes and accreditation:
 * I, Willard, made this program and have published it at https://www.khanacademy.org/cs/mc/5647155001376768 as an original program (technically a Minecraft ripoff, but original code).
If it's published elsewhere by anyone other than myself, then it must be done so as a spin-off, or else be flagged for plagiarism. As long as I've written at least 50% of
the code in this, I'd very much prefer that nobody else copy/paste it anywhere.

 * This program originated as a spin-off of ScusCraft, which is a P3D Minecraft program with a 4 block render distance. I started out just optimizing it, but it... got a little bit out of hand.
 * I ended up with a program 3x the size of the original that used all sorts of disallowed functionality for the PJS environment.
 * I ported it to the web environment where all this stuff is allowed to make sure it followed the guidelines. All future updates will be to this version.
 * ScusCraft can be found here: https://www.khanacademy.org/computer-programming/scuscraft-3d/5145400332058624
 * My original spin-off can be found here: https://www.khanacademy.org/computer-programming/high-performance-minecraft/5330738124357632
 * While porting the code, I copied the PJS source code for a few of their helper functions from here: https://raw.githubusercontent.com/Khan/processing-js/master/processing.js
 * The textures and name are obviously stolen from real Minecraft, and are the property of Mojang and Microsoft with whom I have no association.
 * The real Minecraft game can be bought and downloaded at https://www.minecraft.net/en-us/

 * If anything doesn't work right, let me know in the comments and I'll try to fix it. Any errors in your Javascript console would be useful.

 * Render distance is measured in 16x16 chunks (same as real Minecraft).

 * There's nowhere to offload chunks to, so they're kept in memory until you restart. So don't explore too far or memory usage will grow until it crashes unrecoverably.

 * Adding new (cube shaped) blocks is super easy, so if there's any you want added, just let me know!


	To-Do:
 * A lot. Check out the GitHub repo if you'd like to collaborate on this. Must use Discord.
 * https://github.com/Willard21/MineKhan


	How it works:

The graphics in this project are done using WebGL, which is a web implementation of OpenGL ES 2.
It allows us to write shader programs that run right on the GPU, which means it can run as fast as any C++ game.
The infamous P3D mode in Processing.js uses WebGL behind the scenes, but it does it so inefficiently that it might as well not even being using the GPU.

To properly utilize WebGL like this program does, you need to make efficient use of Vertext Buffer Objects (VBOs).
A VBO is an array that contains a whole bunch of vertices. Since WebGL can only render triangles and lines, these vertices are stored in multiples of 3.
A vertex doesn't only include its world coordinates, though. It also includes its texture coordinates, and any other data you want the shaders to manipulate.
In my case, every vertex has an X, Y, Z, textureX, textureY, and shadowIntensity. So 6 values for every block vertex in the world.

A program can only draw 1 VBO per draw call. Since the texture data is attached to the vertex data, you can't switch textures between vertices.
That means you either have to make seperate draw calls for each texture, or only use 1 texture. I do the latter.
I make a single 256x256 pixel texture, and store each of the 16x16 block textures in a section of that big texture, and store the coordinates to it.
Then when I'm preparing my VBO, I send the texture coordinates along with the block coordinates so the shader knows how to map the 256x256 pixel texture onto the 16x16 pixel block face.

I do this once for each chunk in the world, and store those VBOs so I can draw them every frame. If a block is edited in a chunk, then that VBO is replaced.
Drawing a chunk after the VBO has been created is as simple as binding the buffer and calling "gl.drawArrays" once per chunk. The GPU takes care of the rest.

I also use what's called Vertex Array Objects (VAOs) to re-use shared vertices. Since the GPU expects triangles, and I want to draw squares, I need to draw 2 triangles (6 vertices) per square.
That means 2 of them are being re-used. The VAO lets me tell the GPU to use the cached vertex data instead of looking for a new one, which offers a small inprovement to GPU performance.
This isn't entirely necessary, but it's considered best practice. Some OpenGL ES implementations require it, but WebGL 1 does not. I think WebGL 2 does, but that's not as well supported.
-->

<html>
	<head>
		<meta charset="utf-8">
		<title>MineKhan</title>
	</head>
	<link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
	<style>
		body {
			overflow: hidden; /* Hide scrollbars */
		}
	</style>
	<body>
	<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
	<textarea id="savebox" hidden="true" spellcheck="false" style="position: absolute; top: 10px; left: 10px; z-index: 1;"></textarea>
	<p id="savedirections" hidden="true" style="position: absolute; top: 40px; left: 10px; z-index: 1; background-color: rgba(255, 255, 255, 0.3);">
		To save your world, copy/paste the saveString<br>
		from this box into the code on line 112.<br>
		var loadString = "Your Code Here";<br>
		Then save the program as a Spin-off.
	</p>
	<p id="message" hidden="true" style="position: absolute; top: 10px; right: 10px; z-index: 1; text-align: right; background-color: rgba(255, 255, 255, 0.3);"></p>
	<script>
		var superflat = false;
		// Code edits will erase the world.
		// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
		var loadString = "";
	</script>
	<script type="application/javascript">
var canvas = document.getElementById("overlay");
var ctx = canvas.getContext("2d");
var savebox = document.getElementById("savebox");
var saveDirections = document.getElementById("savedirections");
var message = document.getElementById("message");
ctx.canvas.width  = window.innerWidth;
ctx.canvas.height = window.innerHeight;

/* Set this text editor to max width by copying this into the JS console:
document.getElementsByClassName("_1chbfei")[0].setAttribute('style', 'max-width: 100vw !important');
*/

var MathGlob = Math;

function init() {
	let Math = MathGlob;
	let setPixel, getPixels;
	let textures = {
		grassTop: function(n) {
			let r = 0, g = 0, b = 0, d = 0;
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					d = Math.random() * 0.25 + 0.65;
					r = 0x54 * d;
					g = 0xa0 * d;
					b = 0x48 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
		grassSide: function(n) {
			let r = 0, g = 0, b = 0, d = 0;
			let pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");
			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i+1], pix[i+2], pix[i+3]);
			}
			for (let x = 0; x < 16; x++) {
				let m = Math.random() * 4 + 1;
				for (let y = 0; y < m; y++) {
					d = Math.random() * 0.25 + 0.65;
					r = 0x54 * d;
					g = 0xa0 * d;
					b = 0x48 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
		leaves: function(n) {
			let r = 0, g = 0, b = 0, a = 0;
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		oakPlanks: function(n) {
			let r = 0;
			for (let y = 0; y < 16; y++) {
				let a = (y & 3) === 3 ? 0.7 : 1;
				for (let x = 0; x < 16; x++) {
					let mid = x === 8 && (y & 7) > 3 && a === 1 ? 0.85 : 1;
					let rit = x === 15 && (y & 7) < 3 && a === 1 ? 0.85 : 1;
					r = (Math.random() * 0.1 + 0.9) * a * mid * rit;
					setPixel(n, x, y, 190 * r, 154 * r, 96 * r);
				}
			}
		},
		hitbox: function(n) {
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					setPixel(n, x, y, 0, 0, 0, 255);
				}
			}
		},
		dirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
		stone: "0g0g40sywflr0wb8hdr0zdjj0f13tzldr3333211210112222221212222220012121001110111222222233232233222111122111212333312223222222211010131223331331112222110010112211122233323223332222212232223332233332021211001212211122222332222233232111232112200101332112211122111321122222222233332222221123322122",
		logSide: "0g0g60fl1ssf0l5j1fj0qftm2n0wa7mdb14cs7wf16az8xr3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		logTop: "0g0g90l5j1fj0qftm2n0wa7mdb0z2esxr15quebj189da7z1cpma671f7ppfj1hzyayn1012101120110111077776768667777017334454555544811738877776777471164766666666756107576445544674601646636666466471165764655656756116576465464674610657646666566460164764434556756116576666666674610757767777787460175454444444447117776676686677711011101120110211",
		bedrock: "0g0g509gy58f0e7f7r30o8fd330rkrev31627mkf3111124324211212133434341443012110110111412224232433202422111112014111121134433112221221102211014432344323443410222122211011213234421122344344442110121213211143334134410144431102221123442334402111321134111112343420211101234433211211234421121011044312301123",
		glass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
		cobblestone: "0g0g60muaccf0r0pekf0un11q711vr5rz1a8mosf1ef1r0f2144011454313543145330554330132314342143342101321132113232134310021354131154443152453321033543234313433211243215332233213541231321542213533311021543232233121341323231101221044532211235411035532354215434213323154331432332113244323212332143111311232121135432",
		mossyCobble: "0g0gb0muaccf0mupnnj0p38xdr0r0pekf0rbmj9b0un11q70w1wkxr0y07svz11vr5rz1a8mosf1ef1r0f4199211276438a9619a8812764813858398951644251118533852182851464110531183233866642a176895308948428981498852118851988111851664158385117641484642305126244558824124185442111155214698112124761318998127651764653885847488164588511858685851588531841183352111338a984",
		stoneBricks: "0g0g70p2gyyn0rkrev30tj2nlr0xf9ou70zdjj0f12psrnj17g8flr5666666666665550645455555444445065454444445534406434554345434330632334544334324053244333345324302222222222222220110011000111111166666650566666663555544065455554544544306435354445544320634344454444343053345433332322305443344322222220222222221111110000111111",
		mossyStoneBricks: "0g0gc0mupnnj0p2gyyn0p38xdr0rbmj9b0rkrev30tj2nlr0w1wkxr0xf9ou70y07svz0zdjj0f12psrnj17g8flrab3668863b88a680b9a28683a9999332ba926363996a2931b9792a679a979721b737793993697591a72397773632297075225752332277924410441110000444886bbba1abbbb6883aaaa991ba9aaaa6a99a9971b97a7a399aa99351b797992a99997371a689a97777573371a897799755223791722757754000041110004400",
		bricks: "0g0g90vz62nz0yhavi712oqn7j13rinsv173m8lb193f4zj1b1w1rz1d7u7sv1j1u51b7742888777458777443513444435144410060033100503112256522225565222887747458777474214444315133333151341110600133105522225565522225677458887474588774435344444153444110511331106133325565222225652224777474287774745144444353444441501111106011111065222225655222566",
		coalOre: "0g0g70ehg7wf0hjr9j30j7xaf30sywflr0wb8hdr0zdjj0f13tzldr6556544543445666554536666553335454331453344511556665655105655644455443346545645556553215542143464552111065105555433556663334466661156543215455645565354100056665354514334663354455555666634106655443366412111054665105556005455554456665566544455555554655555566",
		ironOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1cpl2bj1gbvabj1o4exa71qwyvb33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217510131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167666421332542223442122221123332233211122222221322222233",
		goldOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1x01czj1y6gem71z13ncv1z141z33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217610131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167655421332642223442122221123332233211122222221322222233",
		diamondOre: "0g0g80h634zj0sagdtr0sywflr0wb8hdr0zdjj0f13tzldr1845xbz1ndl24f5445433432334555443425555442224343221342233461445554544604544533344332235434534445442764437632353447611054104444322445552223355556145432764344534454243600045554243413223552243344444555523605544332255367611043554604445004344443345554455433344444443544444455",
		redstoneOre: "0g0g90sywflr0wb8hdr0zdjj0f13oi67z13tzldr15wexa71b68mbj1f24cfz1yr4gsf4224211210112444221204444220002121005120011285224442422832422411122110014212412224220862218610141227655342532222100224440001144448524210862122412242021633324442021251001440021122222444401834422110044168655321442832224332122221124442244211122222221422222244",
		lapisOre: "0g0ga04hvenz04hvl6n04ihywv066fd3306r2ozj08z4sfz0sywflr0wb8hdr0zdjj0f13tzldr9889877876778999886669999886668787454386777813889889926329989977788776679867978889866428862576797861242398238888723679978767799993189872643386678998687222236258686627661237725788300799668893588779906612366339998700381039799887783339899877788888899888888899",
		emeraldOre: "0g0g7004swsf06mdmv30sywflr0wb8hdr0zdjj0f13tzldr1ohjdhb5445432232334555443445615442334343223310333422445555225555546133344361324555104445441061243255353445551054434444332232552323355555545461442244534444441053615224243433223310361344444556155551044223455103322553261334455444344441045554455433344554443544444455",
		coalBlock: "0g0g501e50xr03md24f05ul3b308mtq0v0bf3ri73322122002210012222121000210123321000122000022221001243222202210001233222100210020222221000001220132211001122222022210122343221002110123322210000012123221103200212122210002211232102112210012230002113432123322000123420023221000123210012221001222212212221000",
		ironBlock: "0g0gb1dawbnj1fj5rlr1hrdssf1m7r1mn1nlyvwf1pa4wsf1qe8xdr1s2ey9r1t6iyv31tqkz5r1ver01r32233333333222232aaaaa9998777772277777777777777105555555666444402aaaaaa999777771277777777777777105555566664444402aa9999977777771277777777777777105555555566644402aaaaaa999977771277777777777777105555556666444402aaaa9999777777127777777777777712222222112111111",
		goldBlock: "0g0g91kr8um71mphb0f1w77ain1xakkqn1ypvwu71yr43jz1yzk7pb1z0cef31z10mwv2222332223333221285577888776688125664877623324812564877462224471374777462264467137777462267762302877444667762330287444664462232037444664466222613744664466662461364667766666742032667762262776203267762332446261334462332666224132322332662264701101100011001100",
		diamondBlock: "0g0g90434min061d2in0h634zj0l2fpxb0sagdtr0vckf0f1845xbz1ndl24f1z141z33333223332222331378866777664477138445766432235713845766543335561265666543345546126666543346643203766555446643220376555445543323026555445544333412655445544443541245446644444653023446643343664302346643223554341225543223444335123233223443345601101100011001100",
		redstoneBlock: "0g0g50vx660v153407319j36671gh49a71runlz34444444444444444433433222334333443342202222232344332311001120234443211012011244443210000000042344302100000011134421100000000122442231000000111344324110210111234432110004001224443321101001110344322211111122224443124211022323443334433223333344444444444444444",
		lapisBlock: "0g0gd05lqqkf06zt0xr07js8hr07tw35r084kzr308e6ein08e99fj08yjpq708ys8ov0an2j270c0w4cf0dp94hr0fdf5kv98999989cb848484878b78736733677197b8867767623765967877377863366597687666378a63759a77776636a7736197a767676236763596763666a6233625c636636376632775c633687363332371963237873676327186672236338763619763722332677630877633332336667143766633633367708111111610220000",
		emeraldBlock: "0g0g606lfrb306mdmv307ei5fj07xmdbz0iaro5b10c5ptr0000000000000002055555454551144305000000200002430404555411114243050500000002425305050555445212130405054411421203040405451142120305040411020202130404041122120213042105410112420301212222222242030405510000441213012222222222224301011001110014532333333333333332",
		tntTop: "0g0g704qh5a70nyecxr13jyl8f14a4flr1d4tukf1otd8u71szz8jj5665566556655665622462246224622462136210012300234431403344004433566006655660566562246204121402246211120000231023443341000111403356651000000506656211020001140224621360200120112344331031140344335661560500611665621462146124612462236223622362234433443344334433",
		tntSides: "0g0ga07ipw5b0fbhzwf14a4flr1d4tukf1gwtvcv1ldqupr1otd8u71pk09vj1szz8jj1z141z38863886388638863663266326632663266326632663266326632663266326632663266326632663295775577755777799711071550711059745055115157177795717717115505479750571550550759444444444444444433223322332233226632663266326632663266326632663266326632663266323332333233323332",
		tntBottom: "0g0g413jyl8f14a4flr1d4tukf1otd8u72332233223322332300130013001300130013001300130011111111111111111233223322332233230013001300130013001300130013001111111111111111123322332233223323001300130013001300130013001300111111111111111112332233223322332300130013001300130013001300130011111111111111111",
		acaciaLogSide: "0g0g60ma181r0oi99fj0pcavi70t8nim70y9464f139ktmn3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		acaciaLogTop: "0g0gb0j7rlz30kvxmgv0ma2nen0o889hb0t8nim713rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf432332211231433449999898a889999329556676777766a2395aa999989996910869888888889782197986677668968318688588886886932879868778789784487986876868968448798688887886833869866567789782287988888888968219799899999a96811976766666666691099988988a8899933412233444322114",
		acaciaPlanks: "0g0g711t8qgv13rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466656666535455554333434332654433334444335300122100012110006556655366646566445533433555544443345432554333330110012221010000",
		birchLogSide: "0g0g80f1fcov0qqliwv1gxap6n1o60u7z1ptrf271uar6db1uum5mn1z141z36643366634663366346666777634443677744367666636777732100136777737366321101377631211336344363331001266344677766532343777777334556376336775577775777764455577766336336777766634477636777767777577634436633667553210026677763443100000133377761132116331677764336336",
		birchLogTop: "0g0ga0mk6h3316m5am719xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm71tgjy7z1z141z39818811001809889966665657556666816223343444433718627766665666360153655555555645106465334433563580535525555355368154653544545645995465354353563599546535555455358853653323445645115465555555563510646656666676350064343333333336016665565575566688901188999811009",
		birchPlanks: "0g0g717znmrj19xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm75456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		darkOakLogSide: "0g0g60besef30dcwlbz0e6y70f0hj7ev30klcs8v0oho0e73143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		darkOakLogTop: "0g0gb08ml79b0auqebj0dcmqdb0e6y70f0f117gf0g4r4730h8wirj0hj7ev30kb0idb0lz2akf0n393wf741441100140744779999898a889999419225565666655a1492aa999989995903859888888889681096985566558958408588288885885941869858668689687786985865858958778698588886885844859855256689681186988888888958109699899999a95800965655555555590399988988a8899944701144777411007",
		darkOakPlanks: "0g0g70bejy0v0dcmqdb0g4r4730h8wirj0kb0idb0lz2akf0n393wf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		jungleLogSide: "0g0g90h96cxr0htdywv0m9k4xr0ne277j0orqc5b0rkbldr0sxvim70wunksf0ys83cv4688422222666444444114414441001111137510011441866644668842422224146644411143573444422235311010006646442222444886101000466412222444688411068844441122575311222100755444666664355741100112241201661144866643341111623533422111444644111004661664444664122244442222",
		jungleLogTop: "0g0g90h96cxr0htdywv0rkbldr0ys83cv160fym7188mku71batekf1f77h1b1h5ei2n3212210011213223377776768667777217444454555544812748877776777470164766666666756107576445544674620646646666466472165764655656756336576465464674633657646666566462264764444556756106576666666674600757767777787460175454444444447117776676686677722310122333211013",
		junglePlanks: "0g0g70sxkd1b0xdxkov160fym7188mku71batekf1f77h1b1h5ei2n5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		spruceLogSide: "0g0g60csc9vj0cskpof0dmmb5r0geuxof0lf4i670nnb4sf3243304330342431325130513034233130113051323223314031323131302341423130315131324343234232514232431323411343433243130343143341314332053314314141433325331331424303333431303132430332343130533053235233414051303313532343324132333343243340323224334324234232332431",
		spruceLogTop: "0g0g80ix87pb0nnb4sf0p1n6db0qzu7zz0v5xypr0xy569r106bshr11ueyv31012101120110111066665657556666016223343444433711627766665666361153655555555645106465334433563501535525555355361154653533545645115465353353563510546535555455350153653323445645115465555555563510646656666676350164343333333336116665565575566611011101120110211",
		sprucePlanks: "0g0g80nnb4sf0p1n6db0qzu7zz0v5xypr0xe36rj0xy569r106bshr11ueyv36567777767777762665523566655663356665643333556622112210011010010673777737776553656653532355666653356555266655333001121000011121067765577777777636566665333535332765533335555336300122100012110007367766377737677556633533665655553356532665333330110012221010000",
		sand: "0g0g61m6x62n1nb9nnj1opn5dr1r80f7j1scbi0v1u0izgf4223213232132313122121130142502432011422222121122331213133132122125213232322122321223332123122121421151211022121212212212111242112322310131232124212221120212231202321232232012311223212331112121213132145321123323230232323221223235332323203223232332321223232",
		gravel: "0g0g80rufq4f0vqwlbz0zxiprz125i9rz15rvcan1627mkf1d0twqn1dackxr0341152512122521522122312102333522103133522351352232321522512322132741122210253202140133526552213104226515530122553253522311225353521223310256122311652152322132123553102521325022533562113225212132222537415525331025232422215235323311243310351274122232321212",
		blackConcrete: "0g0g40149on3028826702882yn028dp8f1330112022012232303130022112212111032203010022012122012222321221011223213030101033110011212233120230013131003200032022012002002112233122202312230200102211312102222122132011021201223320211021220121122122321331201102120210001220112022023302312210123220102110",
		blackWool: "0g0gf0149on3028826702882yn028dp8f03cc2rj03cc3jz03chptr04gg3cv04glqf305kk3y705kpr0f06oo4jj07ss54v08ww5q70a106bj46348b45ab13993299eebb7742570367bc77dc97bcbbdeb996bc768c47cc96ec9749bb115953bb31314c414641672547eebb8879bea7eeb966eebacc45bca9ccbb35ca4657528733577b117949ee7beeccbbecbacb799839349966bb445911796611cd318b9bee92badecb9717bc77cedc97c99beb559b6424c946cd76ac44bc",
		blueConcrete: "0g0g30c98pof0c98qgv0c9ecqn1000001101000201011001000101120101211111010200000001000110100100220110011001121111001100100100010200102101101000000011110001101010101011020111110000000101121111101100100100010110111010210111001101000100000111110100101111000120000010100000110001200110010002",
		blueWool: "0g0gj0c98pof0c98qgv0c9ecqn0c9edj30ddcr270ddidbz0ddie4f0ehgrnj0ehgsfz0ehmepr0ehmfi70flkt1b0flqfb30flqg3j0flw2db0flw35r0gpugov0gq02yn0gqbd3335237c44ac12992289iidc6632460256de67ge96cebbhic985ce657e46ee85ie9648cc114942cc21214e413541562436iidc7769dia6iic955iicaee34cea9eecb24ea4546427622466d116949ii7biieecciecaed699728249955cb344911695511eg217c9bii92bahiec9617be67eigf86e99cid449b5324e935eh65ae34de",
		brownConcrete: "0g0g30pl5gqn0qp3u9r0qp9hbz0211211202222221222122211211122121011102222222212211200222112101121111211111222121222122122221201212121222112122222221220222222122221201121212022122122110221211122221211011221212121010121011111212122221121221222212122112112112211010222111121211220222221122",
		brownWool: "0g0gi0qp3u9r0qp9hbz0rt7uv30rtdh4v0sxbunz0sxbvgf0u1a8zj0u1fv9b0v5e8sf0v5e9kv0v5jvun0w9i9dr0xdgmwv0xdm9z30yhkni70yhq9rz0zloo3j0zluadb35228d45bd12aa219bhhed7721570257ef77gfa7dfccghdb95df758f47ff95hfb749dd115a52dd21214f413541571526hhed887aehb7hhda55hhdbff25dfbbffdc25fb4557518722576e117b4bhh7chhffddhfdbfe7ab82924bb55dc245b116b5511fg218dachhb1cbghfda717cf77fhgg97fabdhe55ac5214fa25fg75bf24ef",
		cyanConcrete: "0g0g305objsv05obklb05oh6v31112010122111202100121222111122012212211101111202102221210222122211111211221111011021102021212212220211021022022201210110010212210211110202101010201110112020221222112102111202212110222110211221001010211001221212202222122111221102211100222112011211120220211",
		cyanWool: "0g0ge05obklb05oh6v305omt4v05omtxb05osg7305oy2gv05p3pj305p9bsv05p9clb05peyv305pkl4v05pklxb05pq87305pq8zj242269347912662167dda95521450145ab55cb659b88cd97649b546b35bb64db7536991146419921113b312431451424dda96656ad75dd9644dd97bb249b77bb9814b73445416521454a115737dd58ddbb99db97ba56762623774498234711474411bc116968dd7187cdb965158b55bdcc65b679da44684213b624bc547b23ab",
		grayConcrete: "0g0g20ehlvr30flk9a70000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000001000000010000",
		grayWool: "0g0gd0ehlvr30flk9a70flpvjz0flpwcf0flvim70gptwxr0gpzjzz0htxxj30hu3jsv0hu3klb0iy1y4f0iy7ke70iy7l6n333359337803663157cca85531350135ab55cb658b88cc87539b545b35bb53ca7535990036329930103b303330350335cc995556ac75cc8633cc87ba339b77ba8813a73435305532355a005737cc58ccab88cb87ba56753533773498333700574300ac205968cc7087cca865058b55bccc55b679ca33684313a634bc537a33ab",
		greenConcrete: "0g0g20k2mku70k2s73z0001000100111100101010100101101101101100111010010111001001011000100001100011000100101010110101111010000001011001001000100001010110101110010011010000101011110000010110101000000001010000110101011101000111110011101010011000111100001100011000000111101001101100",
		greenWool: "0g0gh0k2mku70k2s6bj0k2s73z0l6qjun0l6w64f0l71rlr0mb054v0mb5qm70mb5ren0nf9qf30nffcov0ojdq7z0ojjbpb0ojoxz30pnnbi70pnsxrz0rw0y6746447c45ab1499419aggcb8841580168ce88ee98bebbfgba96ce867e48ee96gda849cc125953cc41114e424642681546ggcc7789cga8ggb966ggbaed45ceaaedbb15da4658517843586c21894agg8bggdebbgebaec89a749449966cb445a116a6621de327c9bgga1bafgdb9828be88egee98e9acgc559b6414d946ef86ad44ce",
		lightBlueConcrete: "0g0g3090ti4f090z4e70a4xipr2120111111121222222121122112211121121211112221221111102221122212112021111111122111112111112121211222221111122121212121112021122112211121211211111121220111212121111121222001122211222221022122111011221111111021211221211211121112212111111122121111211112222111",
		lightBlueWool: "0g0gq090z4e70a4xipr0a534zj0a58r9b0b974sf0b9crun0b9ie4f0cdgrnj0cdmepr0cds0zj0dhqein0dhw0sf0dhw1kv0em01dr0em5nnj0fq9o8v0fqfain0gudou70gujb3z0hyhon30hynawv0hynbpb0j2lp8f0j2rbi70k6pptr0latpmn7b57fm89ik26ff63fippnkdd739d04benodepogdkojjppkifblodcfo8doofbpoie8fml21af95mm62428o817b81bd397cppmlffefnpidppkgbbppkioo79loiiookj4aoi8cad93fd55adcn22dh8ippejppookkpokiondfif6f68hhbcmj78ai22cicb22op51fmfjppi3jippokfd2ejoeeoppofdofilpn9agjc738og7copebio78no",
		lightGrayConcrete: "0g0g20yjgg730yjggzj1000110001001010100010000000011101100010001001011010001100101010001000000000000010100000000100010100000000001010100010001000000000100000110000100001100000011101110001001011001001001001011000000000011001001001001010000000010000000010100110000000001000001001",
		lightGrayWool: "0g0gi0yjgg730yjggzj0znkgsf0znkhkv10rohdr10roi6711vshz311vsirj11vy5tr12zwjcv12zwk5b1440jy7144670f1584kjj1584lbz16c8l4v16c8lxb17gclq745339e55bd1399329bhhfd7732570257ff78hfa7dfcchhdb95df769f57ff95hfb759ed115953ee31215f514551572537hhed9979fhb7hhda55hhdbff35dfbbgfdc25fb5657529733577f117b5bhh8chhfgddhfdbgf79b93935bb56ec355b117b6511fh319e9chhb2cbhhfd9718cf78fhhg97f9bdhf55ac6325fa36fh75bf35ff",
		limeConcrete: "0g0g30ppd5a70ppirjz0qth5331121111111100111111111110111110111010211100110111211111211101111112111111111111101110111011110211011011110111110102111110100111000110112112110211112112112111212111111111111111011111011100101111111111212111111111112010011011221111111110111120011110111101111",
		limeWool: "0g0gg0ppirjz0qth5330qtmrcv0rxl4vz0rxqr5r0t1p4ov0t1uqyn0u5t4hr0u5yqrj0v9x4an0va2qkf0we143j0xi53wf0ym3hfj0ym94hr10uh5of35237c44bb1299228affcb6632460257cd67ed96bdbbefba85bd657d46dd85fca748cb104942cc21214d403540562435ffcb7779cfb6ffb955ffbbdc34bdbaecbb24cb4546427622465c01694aff7bffcebbfdbbec69a728249955cb344a105a5501ce207c9bffa2bbefcb9607bd77dfee86d9abfc449b5324c935de75bc34cd",
		magentaConcrete: "0g0g419jw2rj1anugan1ao02kf1ao03cv2233313332221332333333233213322333223332331233333313323103121223222131233211303233130230322231223302323103002220333103232232223333313231221331233333231232212303302330122232333333332123320111033031332321233232303322232223332223231233212323332233222231230323",
		magentaWool: "0g0gs1ao02kf1ao03cv1brygvz1bs435r1bs43y71cw2hhb1cw83r31cw84jj1e06i2n1e0c4cf1e0c54v1f4ainz1f4g4xr1f4g5q71g8ej9b1g8k5j31g8k6bj1hcijun1hco64f1hco6wv1igmkfz1igs6pr1igs7i71jkw7b31jkw83j1kp08ov1lt49a71mxdwxr6945dl77ij14ff43ehrrmjba537a039cmoacqogajojjqrjhe9koa9do7booe9rnhc7elk118f74ll41317o7169719a275arrmkddcfmribrrjg99rrjion57koihonjj38ni798a72db448bam11bh7hrrcjrrnojjrojiomafhd4e47hh99lj578h11ah9911nq41dlfjrrh2jiqrnjfa1cjoccorqpebofhkrm78gj9537ng59oqc9in57mo",
		orangeConcrete: "0g0g21p59iwv1q97wfz1011110111101111111011111110000111101110100111111110011111011001001101110110111111111110111111011111101110111111110111111111111111011110111101111011101101101111010010111111110110101110010011101111111010101001101111111011111110111111111001111111101111111111",
		orangeWool: "0g0gm1q97wfz1rdbw8v1rdbx1b1rdhjb31shfwu71shfxmn1tljxfj1tljy7z1tlpkhr1upnytb1uptl331uptlvj1vtrzen1vtxlof1vtxmgv1wy1m9r1wy1n271wy79bz1wycwe71wyijgf1wyo5q71wytssf46239f55de02aa219dllhe8731570268hi79kib7eieelled96fi779i58ii96lhd859ff005a52ff20205i504650671537llgf998ahld8lleb66lledih35fiddihee25hd5757519822587h008c5dll9ellhieeliedih7ad92925cc67fe355d007d7600hk209faelld1edllhea709ei89ilkj98iadflh55be7315hb37il86dh35hi",
		pinkConcrete: "0g0g31ltks8v1mxj5rz1mxj6kf1122212121112211111211211211122112111221111111121211212111122211111112112121112111111111111112111212221121111111212211112101110212211211122111211112212111211110211211211211111111121212221211121111112212211121211111211212211111111111121112111211212122122111",
		pinkWool: "0g0gv1mxj6kf1o1hk3j1o1n6db1p5r6yn1q9v6rj1q9v7jz1rdz7cv1re4uf31si37y71si8u7z1tm78jj1tmcutb1tmcvlr1uqgven1uqmigv1uqs4qn1vuqj271vuw5bz1vuw64f1vv1se71vv7fgf1vvd1q71vvd2in1vviosf1vvipkv1vvobun1vvocn31vvtywv1vvzlz31vw588v1vw591b6a46em78jk25gg53fjuuokdc638c03adoqcesqhckqkktukjfalqcbeq7dqqfaupjd7fml219g83mm52327q716a71ac386buunleedgoujduukhaauukjqp68lqjjrpkk39pj7b9c83ed439dbo12di7juuekuuprkkuqkjrocgje5f57iiabmk679j22bjba12ps31emgkuuj3kjtupkgc1ekqdequssfdqgjluo89hkb637ph6bqtdajp67oq",
		purpleConcrete: "0g0g40qo16v30rrzke70rrzl6n0rs57gf3222322033323333333312320220233231302222232332333202332233033330333322320012333323333330233022223332223332223232323303323233332332021220323110033223333322032332312323332322322202232223033232221223233023333332022233332332233232023333233223032323332323323332",
		purpleWool: "0g0gm0rrzl6n0rs57gf0sw3kzj0sw3lrz0u01zb30u07lkv0u07mdb0v45zwf0w84dfj0w84e7z0xc8e0v0xc8etb0yg6scf0ygcem70zkasxr10o96gv10o979b10oetj311sd72711sd7un12wh8fz154uxhb47349e45ce13aa32acllfe8742570279fh79jhb7ehddkleca7eh779h48hha7lgc94aee116a52ee31214h414741771547llfe999aflc8lleb77llechg45ehcchged26gc4767519832687f118c4cll9dllgheelhechf7ac93a34cc77ed446c117c7711gj219eadllc1dcklgea719dh99hljia8hacelf56bd7424gb47hk97cg44fh",
		redConcrete: "0g0g112voa9r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		redWool: "0g0gd12voa9r13zmnsv153l1bz167jev3167p14v17bnenz18fls7319jprzz1ano5j31ano6bj1brmjun1brs64f1f3yku7241258227712662157cc9754212401459b45bb647b77bc77548b445b25bb54ca7525881036218821112b202420441224cc8855569c75cc7644cc77ba228b77ba7713a724342155113549015627cc57ccab77cb77b946752522664487223711474401ab105867cc7177bca764057b55bcbb55b678c923674212a624bb547a229b",
		whiteConcrete: "0g0g31ktui9r1ku04jj1lxyi2n1121212211221121111221111121122111211111121112111212112211111211212222111111221112211112101110211111122211211211111111212221111112212121212222111121122211111111222111111112121222121111111111211121221112221111121222121112212122111221211212111121221211221212",
		whiteWool: "0g0gn1lxyi2n1lxyiv31ly454v1n22inz1n22jgf1n285q71o66j9b1o66k1r1o6c6bj1paajun1qeekfz1ricyrj1riil1b1smgykf1smmlmn1tqkz5r1tqqm7z1uuozr31uuumtb1vyt0cf1vyynen1x2x0xr1y711j37a56dj89hi26ee63egmmliba639a04acllacmlfailiimmigeajlaadl8blleamlgc8ejj219e94jj62429l817a81aa396ammkjddcelmhbmmifaammihll69jlhgllii49lh8a9a93db549bal12bg8gmmcimmlliimlihllaegd6e68ggaaji689g22agaa12lm41djeimmg3ihmmliea1cilcclmmmeblegjml99fia638lf6almcahl68ll",
		yellowConcrete: "0g0g41to1w5b1us09of1us5vy71us5wqn2111111122222221232021021213122222211020112110121211022201012212122222312211221122213110202011133121132211112221221211211111112120231210211111201132001211212111211102220222021102211223011100222121202222222132111211111112111112021121120222221222011012122121",
		yellowWool: "0g0gj1us5vy71usbj0f1vw9wjj1vwfitb1vwfjlr1vwl5vj1vwl6nz1vwqsxr1x0p6gv1x0utj31x10fsv1x10glb1x163nj1y54h6n1y5a48v1y5a51b1y5frb31y5fs3j1y5lf5r45239e44bc0299219biiec7731470158eg78hga7cgcchicb95dg759g47gg95ifb849ed005942ee20104g404540571436iied9989eib7iica55iicbgf34dgbbgfcc15fb4557419722576e007b4bii8ciifgccigcbge79b92924bb55ec345b006b5500fh209e9ciib1cbhifc9708cg88gihh97g9bdie45ac5314fa35gh85bf34eg",
		bookshelf: "0g0gt03fxnnj04laqdb0a0ot1b0b6j6db0c8r6db0deww730df88ov0egz6rj0gpo9330ht5kov0k20av30nf40zj0pnc1dr0qoh8fz0sy416n0w8kcn30wc5n9b0yicu0v11vb08v11vskcf13z03jz16atkvz17fehvj1as1ce71czhmv31e50qv31g6nvgf1gbtpfj1ks44qnommllhlllmmmmlmoo44477444772534oo799kk999ni9637olkffqk99gpjk631lsqffqk64gnik631soqfdqf6gcngf651ookd9kf3c7igf350mlorrsssroorrroolollmmhmllmmmllhoo77227cb7427724ooqk763gck99cb97olpj063gckq4gc10hsqk063a8fqkgcpjsoqf065a87kqgc10omkfe35ccefkcb03oorrsssroorrrrooo",
		netherBricks: "0g0g706o77cv08w9lhb0b4bzlr0dcedq70fkb4sf0gof6670iwn6kf0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		redNetherBricks: "0g0g70c7i51b0efew3j0fjiwov0ive1a70nbiubj0svgd1b0v3ir5r0000000000000000556515666555165532340433333405333432133223321333000111000001110015666544155545540543333306433333143333221433243211000001110000014416641644164414330433063304330423143314321333140111011101110111464414666644166433330433344303333322033333330333",
		netherQuartzOre: "0g0gc0hs27zz0m7vq4f0m81d6n0ncb0u70rsft330u2845b0v4m7sv10p0npb1bug2671e4e1vj1n1fv9b1smb9xb1312426644044643344320246610442164643068a921424676466baa866314246766ba8674662643166895678a8544641466565ba95146866310289856642b9742469b814466ab862467ba624646b952364a950268665602426852108b61623214642649a9164941364667689238976124667423804646442246624630246644",
		netherrack: "0g0g70hs27zz0m7vq4f0m81d6n0ncb0u70rsft330v4m7sv10p0npb1312425544044543344320245210442154543012432142456545423545531424565424566455254315431566554244541452054554214565531024541154246642454221445541452456540245455112354554025655200242254210254102321454254122154541354556512234565124556423204545442245524530245544",
		netherWartBlock: "0g0g60of09vj0suze9r0xana4f1539r7j1brbain1g7rcvz0122001222532010222235202110022112111222202202320122201003202242042220021211122103224300222201201022220122252002210210211223102220000221222200222022221132210202012201104100222102201012211021042230122022012022212012022002220222202202220234022205220322022302",
		quartzBlockBottom: "0g0g31sm5mv31tq9ngf1tqfbb32222221111000222121111000002222111100000012222110000001122221110001111000110000011100000110000011111222200001111222222211111111222211000112222220110012222222211222222222210000022222211000000222222110110112222111100112222221100101122222111101222222222210000",
		quartzBlockSide: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzBlockTop: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov5555555555555555543333222224444153322222234444304222223344433330423333222332222153322222332222215333444422223330544444433333333054433222334444405332234444444430544444444432222154444433222222405444332332334440533322334444443042323344444333311100011111110000",
		quartzPillar: "0g0g41qe37y71sm5mv31tqfbb31uujcov0202031312130212020302130313031202131313120313020313130213031313131303120302121313020312031203131302131313020303120313031303130312130303131303120213131302131212131312130202120313021213120302031302120313031303130202130303131303120313031213120212131302121202",
		quartzPillarTop: "0g0g51p9z6kf1qe37y71sm5mv31tqfbb31uujcov1021223242413020222122211221122002223434434322223123443344443211113412222221431242442344443244222243242222424423423324244142441222442424324234143244242211423322224423334432442421341222222143111123444444443213222234444443222002211222122112221203142423220200",
		chiseledQuartzBlock: "0g0g61p9z6kf1qe37y71sm5mv31tq9ngf1tqfbb31uujcov0444404333022440043331222204444003322111000444300222223004443331023011101110022103315544432202200110441100220000554444144033344544433204314444440111230011441101054044444432154104400110111004401444454005544440133321100004443002323155440333300444414444132220",
		chiseledQuartzBlockTop: "0g0g51p9z6kf1qe37y71tq9ngf1tqfbb31uujcov0334314232133420021100022000112002044203204421200204120420412021020113032020003102233304212233200000000421110000323433442223344422222222222222220000001321000001044343142143222104011204214110201302130420313020120234032023403002111003201100400222314222133420",
		chiseledStoneBricks: "0g0g70oigd8f0qqoef30sz21vj0xf6vpb0yjgikf11vskcf17g711b6666655666566562644424444224444054110000111123205206665566561530640654434442154064064322334315405205430005421630540632000643062052054300053206306215435655420630641644545432053064163232322215406421110000011530556655666655543053343234433232202000000000000000",
		smoothStone: "0g0g70wb8hdr0yjgikf12zwkxr17gcnb318kgnwf1asop331d0wq9r1011002200220121054556666553445204334454444555501666455566655442255444545666645006555555554343412556664665545550243343443434466116656545555455620555554566656661054544334454454215555666665566622444566454433452165445556555455104456665566544401022112221000121",
		soulSand: "0g0g60egz94v0ht5n270k181z30oho3jz0sxyiv30xeekfz3130033202100434433135531100234004241451321012411423432542212230032442154212211332234104322433212002314322315332220023322345513032322211233445304302332013540423202342330242132302341043213032020354044321232020431445421112202350345131123302354202432103212415",
		glowstone: "0g0g80u1fugv0v5phbz10pn01r11uj6db1kqv1tr1x1ncov1y6jzlr1y711j35420045440276423654011240346654024032201131054033034542017510033014766405664136502566552454236751004554020132450531024010352320465230213276501576442654346640335420454220452013000320356304012311354016754036520357660354215764034654201003242013154216521100013",
		andesite: "0g0g60sywflr0wb8hdr0yjgikf11vsl4v17gcnb31asolxb2114332104423221245323445330122411334410122443224410133445433231235442223333211433323243210013432324542104543333423310154332333433114143343224533143342221154333332321101544332201331254422332333443443233212331543333334533112233301244323223541321322323234432",
		diorite: "0g0g60xfchz311vskcf19of1fj1gd8su71ktouf31smgykf1222352233524355201322135345543151355101325543235255312553213225351243153532255245355541332335235332455214554102243123234555521232203255443244250155213551234541244310134335513055510144221512352542543554223223212343125454353242115521455321245235554124421255",
		granite: "0g0ga0l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n1qczoxr7434244344046445431548244224422341444335249241464143446145532344234232113754334244255342143347242445524442555322424474302155243346344255522344245535242552464245557314243844212555415442024425030323244424324439435524312355344448553215435547245544733324244425",
		polishedAndesite: "0g0g90oilzi70sz23gf0v7a3270yjgjcv10ru60v11vyakf11w3ugv19okmwv1e4v30f7878888888788785843334442443134084444443376644307416763343446440844442456433334083344333424433318444634666554320833433332123444184562444466776608434433443344540844667633366444081444444664466208466654333134760844433334465334083333664444334406100000000110000",
		polishedDiorite: "0g0g80qqu0ov0xfi5tr11vy6m71asubcv1f94t1b1jpkttr1o60w731ri7bpb7776677777666774764556657643564166764466577434506565333565454441675334576435457176544567733456607566767655346450744765756564534063556655467534516566544565544761664334655465666075673555775644517557654375466340745654576435744072445566545654512101110001100110",
		polishedGranite: "0g0g90l56fi70plgu0v0yhw0sf1424tmn17eb8cf1aqna4f1e3al8f1e3x7un1jnje2n8888786866866565843344345444334374744554442446418444243334553342844444453344443262343344443734428345543644444431844444423445544263422344554433636444433443344442734444444464334284473344244442318455444445543341633443264434455264443444334447412111001110111100",
	};

	let blockData = [
		{
			name: "air",
			id: 0,
			textures: [],
			transparent: true,
			shadow: false,
		},
		{
			name: "grass",
			textures: [ "dirt", "grassTop", "grassSide" ],
		},
		{ name: "dirt" },
		{ name: "stone" },
		{ name: "bedrock" },
		{ name: "sand" },
		{ name: "gravel" },
		{
			name: "leaves",
			transparent: true,
		},
		{
			name: "glass",
			transparent: true,
			shadow: false,
		},
		{ name: "cobblestone" },
		{ name: "mossyCobble" },
		{ name: "stoneBricks" },
		{ name: "mossyStoneBricks" },
		{ name: "bricks" },
		{ name: "coalOre" },
		{ name: "ironOre" },
		{ name: "goldOre" },
		{ name: "diamondOre" },
		{ name: "redstoneOre" },
		{ name: "lapisOre" },
		{ name: "emeraldOre" },
		{ name: "coalBlock" },
		{ name: "ironBlock" },
		{ name: "goldBlock" },
		{ name: "diamondBlock" },
		{ name: "redstoneBlock" },
		{ name: "lapisBlock" },
		{ name: "emeraldBlock" },
		// { // I swear, if y'all don't stop asking about TNT every 5 minutes!
		// 	 name: "tnt",
		// 	 textures: ["tntBottom", "tntTop", "tntSides"]
		// },
		{ name: "oakPlanks" },
		{
			name: "oakLog",
			textures: [ "logTop", "logSide" ],
		},
		{ name: "acaciaPlanks" },
		{
			name: "acaciaLog",
			textures: [ "acaciaLogTop", "acaciaLogSide" ],
		},
		{ name: "birchPlanks" },
		{
			name: "birchLog",
			textures: [ "birchLogTop", "birchLogSide" ],
		},
		{ name: "darkOakPlanks" },
		{
			name: "darkOakLog",
			textures: [ "darkOakLogTop", "darkOakLogSide" ],
		},
		{ name: "junglePlanks" },
		{
			name: "jungleLog",
			textures: [ "jungleLogTop", "jungleLogSide" ],
		},
		{ name: "sprucePlanks" },
		{
			name: "spruceLog",
			textures: [ "spruceLogTop", "spruceLogSide" ],
		},
		{ name: "whiteWool" },
		{ name: "orangeWool" },
		{ name: "magentaWool" },
		{ name: "lightBlueWool" },
		{ name: "yellowWool" },
		{ name: "limeWool" },
		{ name: "pinkWool" },
		{ name: "grayWool" },
		{ name: "lightGrayWool" },
		{ name: "cyanWool" },
		{ name: "purpleWool" },
		{ name: "blueWool" },
		{ name: "brownWool" },
		{ name: "greenWool" },
		{ name: "redWool" },
		{ name: "blackWool" },
		{ name: "whiteConcrete" },
		{ name: "orangeConcrete" },
		{ name: "magentaConcrete" },
		{ name: "lightBlueConcrete" },
		{ name: "yellowConcrete" },
		{ name: "limeConcrete" },
		{ name: "pinkConcrete" },
		{ name: "grayConcrete" },
		{ name: "lightGrayConcrete" },
		{ name: "cyanConcrete" },
		{ name: "purpleConcrete" },
		{ name: "blueConcrete" },
		{ name: "brownConcrete" },
		{ name: "greenConcrete" },
		{ name: "redConcrete" },
		{ name: "blackConcrete" },
		{
			name: "bookshelf",
			textures: [ "oakPlanks", "bookshelf" ]
		},
		{ name: "netherrack" },
		{ name: "soulSand" },
		{ name: "glowstone" },
		{ name: "netherWartBlock" },
		{ name: "netherBricks" },
		{ name: "redNetherBricks" },
		{ name: "netherQuartzOre" },
		{
			name: "quartzBlock",
			textures: ["quartzBlockBottom", "quartzBlockTop", "quartzBlockSide"]
		},
		{
			name: "quartzPillar",
			textures: ["quartzPillarTop", "quartzPillar"]
		},
		{
			name: "chiseledQuartzBlock",
			textures: ["chiseledQuartzBlock", "chiseledQuartzBlockTop"]
		},
		{ name: "chiseledStoneBricks" },
		{ name: "smoothStone" },
		{ name: "andesite" },
		{ name: "polishedAndesite" },
		{ name: "diorite" },
		{ name: "polishedDiorite" },
		{ name: "granite" },
		{ name: "polishedGranite" },
	];

	//Set defaults on blockData
	(function() {
		for (let i = 1; i < blockData.length; i++) {
			let data = blockData[i];
			data.id = i;

			if (!data.textures) {
				data.textures = [ data.name, data.name, data.name, data.name, data.name, data.name ];
			} else if (typeof data.textures === "string") {
				let texture = data.textures;
				data.textures = [ texture, texture, texture, texture, texture, texture ];
			} else if (data.textures.length === 3) {
				data.textures[3] = data.textures[2];
				data.textures[4] = data.textures[2];
				data.textures[5] = data.textures[2];
			} else if (data.textures.length === 2) {
			// Top and bottom are the first texture, sides are the second.
				data.textures[2] = data.textures[1];
				data.textures[3] = data.textures[2];
				data.textures[4] = data.textures[2];
				data.textures[5] = data.textures[2];
				data.textures[1] = data.textures[0];
			}

			data.transparent = data.transparent || false;
			data.shadow = data.shadow !== undefined ? data.shadow : true;
		}
	})();

	let win = window.parent;
	let doc = document;
	let console = win.console;
	let world;

	let newFloat32Array = function(arr) {
		return new Float32Array(arr);
	};
	let newInt32Array = function(arr) {
		return new Int32Array(arr);
	};
	let newUint32Array = function(arr) {
		return new Uint32Array(arr);
	};
	let newUint8Array = function(arr) {
		return new Uint8Array(arr);
	};

	let seedHash;
	let hash = (function() {
		let seed = Math.random() * 2100000000 | 0;
		let PRIME32_2 = 1883677709;
		let PRIME32_3 = 2034071983;
		let PRIME32_4 = 668265263;
		let PRIME32_5 = 374761393;

		seedHash = function(s) {
			seed = s | 0;
		};

		return function(x, y) {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += Math.imul(x, PRIME32_3);
			h32 = Math.imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += Math.imul(y, PRIME32_3);
			h32 = Math.imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};
	})();
	let worldSeed;

	//The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls
	let currentRandom = null;
	function Marsaglia(i1, i2) {
	// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c
		let z = (i1 | 0) || 362436069, w = i2 || hash(521288629, z) * 2147483647 | 0;

		let nextInt = function() {
			z=36969*(z&65535)+(z>>>16) & 0xFFFFFFFF;
			w=18000*(w&65535)+(w>>>16) & 0xFFFFFFFF;
			return ((z&0xFFFF)<<16 | w&0xFFFF) & 0xFFFFFFFF;
		};

		this.nextDouble = function() {
			let i = nextInt() / 4294967296;
			return i < 0 ? 1 + i : i;
		};
		this.nextInt = nextInt;
	}
	let randomSeed = function(seed) {
		currentRandom = (new Marsaglia(seed)).nextDouble;
	}
	let random = function(min, max) {
		if (!max) {
			if (min) {
				max = min;
				min = 0;
			} else {
				min = 0;
				max = 1;
			}
		}
		return currentRandom() * (max - min) + min;
	}
	let noiseProfile = { generator: undefined, octaves: 4, fallout: 0.5, seed: undefined };
	function PerlinNoise(seed) {
		let rnd = seed !== undefined ? new Marsaglia(seed) : Marsaglia.createRandomized();
		let i, j;
		// http://www.noisemachine.com/talk1/17b.html
		// http://mrl.nyu.edu/~perlin/noise/
		// generate permutation
		let perm = new Uint8Array(512);
		for(i=0;i<256;++i) {
			perm[i] = i;
		}
		for(i=0;i<256;++i) {
			let t = perm[j = rnd.nextInt() & 0xFF]; perm[j] = perm[i]; perm[i] = t;
		}
		// copy to avoid taking mod in perm[0];
		for(i=0;i<256;++i) {
			perm[i + 256] = perm[i];
		}

		function grad3d(i,x,y,z) {
			let h = i & 15; // convert into 12 gradient directions
			let u = h<8 ? x : y,
				v = h<4 ? y : h===12||h===14 ? x : z;
			return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);
		}

		function grad2d(i,x,y) {
			let v = (i & 1) === 0 ? x : y;
			return (i&2) === 0 ? -v : v;
		}

		function grad1d(i,x) {
			return (i&1) === 0 ? -x : x;
		}

		function lerp(t,a,b) {
			return a + t * (b - a);
		}

		this.noise3d = function(x, y, z) {
			let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
			x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
			let fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;
			let p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,
				p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;
			return lerp(fz,
				lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),
					lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),
				lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),
					lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));
		};

		this.noise2d = function(x, y) {
			let X = Math.floor(x)&255, Y = Math.floor(y)&255;
			x -= Math.floor(x); y -= Math.floor(y);
			let fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;
			let p0 = perm[X]+Y, p1 = perm[X + 1] + Y;
			return lerp(fy,
				lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),
				lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));
		};

		this.noise1d = function(x) {
			let X = Math.floor(x)&255;
			x -= Math.floor(x);
			let fx = (3-2*x)*x*x;
			return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));
		};
	}
	let noiseSeed = function(seed) {
		noiseProfile.seed = seed;
		noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
	};
	let noise = function(x, y, z) {
		let generator = noiseProfile.generator;
		let effect = 1, k = 1, sum = 0;
		for(let i = 0; i < noiseProfile.octaves; ++i) {
			effect *= noiseProfile.fallout;
			switch (arguments.length) {
				case 1:
					sum += effect * (1 + generator.noise1d(k*x))/2; break;
				case 2:
					sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;
				case 3:
					sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;
			}
			k *= 2;
		}
		return sum;
	};

	let caveNoise;
	// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
	function openSimplexNoise(clientSeed) {
		const SQ4 = 2;
		const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) };
		const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) };
		const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) };
		const NORM_3D = 1.0 / 206.0;
		const SQUISH_3D = 1 / 3;
		const STRETCH_3D = -1 / 6;
		var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011");
		const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70");
		var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) };
		var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131");
		const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a };
		const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} };

		function shuffleSeed(seed,count){
			seed = seed * 1664525 + 1013904223 | 0;
			count -= 1;
			return count > 0 ? shuffleSeed(seed, count) : seed;
		}
		const types = {
			_3D : {
				base : base3D,
				squish : SQUISH_3D,
				dimensions : 3,
				pD : p3D,
				lookup : lookupPairs3D,
			}
		};

		function createContribution(type, baseSet, index) {
			var i = 0;
			const multiplier = baseSet[index ++];
			const c = { next : undefined };
			while(i < type.dimensions) {
				const axis = ("xyzw")[i];
				c[axis + "sb"] = baseSet[index + i];
				c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish;
			}
			return c;
		}

		function createLookupPairs(lookupArray, contributions){
			var i;
			const a = lookupArray();
			const res = new Map();
			for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
			return res;
		}

		function createContributionArray(type) {
			const conts = [];
			const d = type.dimensions;
			const baseStep = d * d;
			var k, i = 0;
			while (i < type.pD.length) {
				const baseSet = type.base[type.pD[i]];
				let previous, current;
				k = 0;
				do {
					current = createContribution(type, baseSet, k);
					if (!previous) { conts[i / baseStep] = current; }
					else { previous.next = current; }
					previous = current;
					k += d + 1;
				} while(k < baseSet.length);

				current.next = createContribution(type, type.pD, i + 1);
				if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
				if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
				i += baseStep;
			}
			const result = [conts, createLookupPairs(type.lookup, conts)];
			type.base = undefined;
			type.lookup = undefined;
			return result;
		}

		let temp = createContributionArray(types._3D);
		const contributions3D = temp[0], lookup3D = temp[1];
		const perm = new Uint8Array(256);
		const perm3D = new Uint8Array(256);
		const source = new Uint8Array(setOf(256));
		var seed = shuffleSeed(clientSeed, 3);
		doFor(256, function(i) {
			i = 255 - i;
			seed = shuffleSeed(seed, 1);
			var r = (seed + 31) % (i + 1);
			r += r < 0 ? i + 1 : 0;
			perm[i] = source[r];
			perm3D[i] = (perm[i] % 24) * 3;
			source[r] = source[i];
		});
		base3D = undefined;
		lookupPairs3D = undefined;
		p3D = undefined;

		return function(x, y, z) {
			const pD = perm3D;
			const p = perm;
			const g = gradients3D;
			const stretchOffset = (x + y + z) * STRETCH_3D;
			const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset;
			const xsb = Math.floor(xs), ysb = Math.floor(ys), zsb = Math.floor(zs);
			const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D;
			const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset);
			const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb;
			const inSum = xins + yins + zins;
			var c = lookup3D.get(
				(yins - zins + 1) |
				((xins - yins + 1) << 1) |
				((xins - zins + 1) << 2) |
				(inSum << 3) |
				((inSum + zins) << 5) |
				((inSum + yins) << 7) |
				((inSum + xins) << 9)
			);
			var i, value = 0;
			while (c !== undefined) {
				const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz;
				let attn = 2 - dx * dx - dy * dy - dz * dz;
				if (attn > 0) {
					i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF];
					attn *= attn;
					value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz);
				}
				c = c.next;
			}
			return value * NORM_3D + 0.5;
		}
	}

	let PVector = function(x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.set = function(x, y, z) {
			if (y === undefined) {
				this.x = x.x;
				this.y = x.y;
				this.z = x.z;
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}
		this.normalize = function() {
			let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
			this.x /= mag;
			this.y /= mag;
			this.z /= mag;
		}
		this.add = function(v) {
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
		}
		this.mult = function(m) {
			this.x *= m;
			this.y *= m;
			this.z *= m;
		}
	}
	let fill = function(r, g, b) {
		if (g === undefined) {
			g = r;
			b = r;
		}
		ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let stroke = function(r, g, b) {
		if (g === undefined) {
			g = r;
			b = r;
		}
		ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let line = function(x1, y1, x2, y2) {
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
	}
	function fastText(txt, x, y, h) {
		h = h || 0;

		let lines = txt.split("\n");
		for (let i = 0; i < lines.length; i++) {
			ctx.fillText(lines[i], x, y + h * i);
		}
	}
	function textSize(size) {
		ctx.font = size + 'px Monospace';
	}
	let text = fastText;
	let strokeWeight = function(num) {
		ctx.lineWidth = num;
	}
	let ARROW = "arrow";
	let HAND = "pointer";
	let CROSS = "crosshair";
	let cursor = function(type) {
		canvas.style.cursor = type;
	}
	randomSeed(Math.random() * 10000000 | 0);

	//globals
	//{
	let fov = 70; // Field of view in degrees
	let version = "Alpha 0.6";
	let reach = 5; // Max distance player can place or break blocks

	let blockIds = {};
	blockData.forEach(function(block) {
		blockIds[block.name] = block.id;
	});

	let currentFov, targetFov, fovTime;
	let renderDistance = 4;
	let locked = true;
	let generatedChunks;
	let mouseX, mouseY;
	let width = window.innerWidth;
	let height = window.innerHeight;
	let generator = {
		height: 80, // Height of the hills
		smooth: 0.01, // Smoothness of the terrain
		extra: 30, // Extra height added to the world.
		caveSize: 0.00 // Redefined right above where it's used
	};
	let maxHeight = 255;
	let blockOutlines = false;
	let blockFill = true;
	let updateHUD = true;
	const SLAB = 1;
	const CUBE = 0;
	let blockMode = CUBE;
	let textureMap;
	let textureCoords;
	let texCoordsBuffers;
	let bigArray = win.bigArray || newFloat32Array(200000);
	win.bigArray = bigArray;

	let screen;
	let hitBox = {};
	let holding = 0;
	let Key = {};
	let modelView = win.modelView || newFloat32Array(16);
	win.modelView = modelView;
	let glCache;
	let nearH;
	let freezeFrame = 0;
	let p;
	let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector();
	let move = {
		x: 0,
		y: 0,
		z: 0,
		ang: Math.sqrt(0.5),
	};
	let p2 = {
		x: 0,
		y: 0,
		z: 0,
	};
	let place;
	let inventory = {
		hotbar: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
		main: [],
		hotbarSlot: 0,
		size: 40,
		holding: 0,
	};

	//}


	function play() {
		screen = "play";
		getPointer();
		fill(255, 255, 255);
		textSize(10);
		p.lastBreak = Date.now();
		updateHUD = true;
		gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
		savebox.hidden = true;
		saveDirections.hidden = true;
		message.hidden = true;
	}

	let gl;
	function getPointer() {
		if (canvas.requestPointerLock) {
			canvas.requestPointerLock();
		}
	}
	function releasePointer() {
		if (doc.exitPointerLock) {
			doc.exitPointerLock();
		}
	}


	let Block = {
		top: 0x4,
		bottom: 0x8,
		north: 0x20,
		south: 0x10,
		east: 0x2,
		west: 0x1,
	};
	let Sides = {
		top: 0,
		bottom: 1,
		north: 2,
		south: 3,
		east: 4,
		west: 5,
	};

	//GLSL Shader code
	//{
	let vertexShaderSrc3D = ""
	+ "varying float vShadow;"
	+ "attribute vec3 aVertex;"
	+ "attribute vec2 aTexture;"
	+ "attribute float aShadow;"
	+ "varying   vec2 vTexture;"
	+ "uniform vec4 uColor;"
	+ "uniform mat4 uView;"
	+ "uniform mat4 uProjection;"
	+ "uniform bool uEdge;"

	+ "void main(void) {"
	+ "  vTexture = aTexture;"
	+ "  vShadow = aShadow > 0.0 ? aShadow : 1.0;"
	+ "  gl_Position = uView * vec4( aVertex, 1.0 );"

	//"  vShadow = 1.0;"+// - gl_Position.z / 10000.0;" +
	+ "}";

	let fragmentShaderSrc3D = ""
	+ "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
	+ "  precision highp float;\n"
	+ "#else\n"
	+ "  precision mediump float;\n"
	+ "#endif\n"

	+ "varying float vShadow;"

	+ "uniform sampler2D uSampler;"
	+ "varying vec2 vTexture;"

	+ "void main(void){"
	+ "  vec4 color = texture2D(uSampler, vTexture);"
	+ "  gl_FragColor = vec4(color.rgb * vShadow, color.a);"
	+ "  if (gl_FragColor.a == 0.0) discard;"
	+ "}";
	//}

	let createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {
		let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);
		curContext.shaderSource(vertexShaderObject, vetexShaderSource);
		curContext.compileShader(vertexShaderObject);
		if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(vertexShaderObject);
		}

		let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);
		curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);
		curContext.compileShader(fragmentShaderObject);
		if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(fragmentShaderObject);
		}

		let programObject = curContext.createProgram();
		curContext.attachShader(programObject, vertexShaderObject);
		curContext.attachShader(programObject, fragmentShaderObject);
		curContext.linkProgram(programObject);
		if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
			throw "Error linking shaders.";
		}

		return programObject;
	};

	let programObject3D;
	let baseTextureVertices = [
		[ 1, 0, 0, 0, 0, 1, 1, 1 ],
		[ 1, 0, 0, 0, 0, 1, 1, 1 ],
		[ 1, 0, 0, 0, 0, 1, 1, 1 ],
		[ 1, 0, 0, 0, 0, 1, 1, 1 ],
		[ 0, 1, 0, 0, 1, 0, 1, 1 ],
		[ 0, 1, 0, 0, 1, 0, 1, 1 ]
	]
	let shapes = {
		cube: {
			verts: [
				[[ -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5 ]], //top
				[[ -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5 ]], //bottom
				[[  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5 ]], //north
				[[ -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5 ]], //south
				[[  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5 ]], //east
				[[ -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5 ]]  //west
			],
			texVerts: [],
			buffer: null,
			size: 6
		},
		slab: {
			verts: [
				[[ -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5 ]], //top
				[[ -0.5,  0.0, -0.5, -0.5,  0.0,  0.5,  0.5,  0.0,  0.5,  0.5,  0.0, -0.5 ]], //bottom
				[[  0.5,  0.0,  0.5, -0.5,  0.0,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5 ]], //north
				[[ -0.5,  0.0, -0.5,  0.5,  0.0, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5 ]], //south
				[[  0.5,  0.0, -0.5,  0.5,  0.0,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5 ]], //east
				[[ -0.5,  0.0,  0.5, -0.5,  0.0, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5 ]]  //west
			],
			texVerts: [],
			buffer: null,
			size: 6
		}
	};
	function initShapes() {
		function mapCoords(verts, index, obj, x, y, z) {
			let cx = 0;
			let cy = 0;
			let n = 0;
			let texArrayOuter = [];
			let baseArr = shapes.cube.verts[index][0];
			const texWidth = 1 / 16;
			const abs = Math.abs;
			verts[index].forEach(function(arr) {
				let texArr = []
				for (let i = 0, j = 0; i < arr.length;) {
					if (x) cx = abs(baseTextureVertices[index][j++] - abs(baseArr[i] - arr[i])) * texWidth;
					i++;
					if (y) cy = abs(baseTextureVertices[index][j++] - abs(baseArr[i] - arr[i])) * texWidth;
					i++;
					if (z) {
						n = abs(baseTextureVertices[index][j++] - abs(baseArr[i] - arr[i])) * texWidth;
						if (y) cx = n;
						else cy = n;
					}
					i++
					texArr.push(cx, cy);
				}
				texArrayOuter.push(texArr);
			})
			obj.texVerts.push(texArrayOuter);
		}

		for (let shape in shapes) {
			let obj = shapes[shape];
			let verts = obj.verts;

			mapCoords(verts, 0, obj, true, false, true);
			mapCoords(verts, 1, obj, true, false, true);
			mapCoords(verts, 2, obj, true, true, false);
			mapCoords(verts, 3, obj, true, true, false);
			mapCoords(verts, 4, obj, false, true, true);
			mapCoords(verts, 5, obj, false, true, true);

			obj.buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, obj.buffer);
			gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(verts.flat(2)), gl.STATIC_DRAW);
		}
	}
	let indexOrder;
	(function() {
		let arr = [];
		for (let i = 0; i < 40000; i++) {
			arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4);
		}
		indexOrder = newUint32Array(arr);
	})();

	let hexagonVerts;
	let slabIconVerts;
	let blockIcons;
	(function() {
		let side = Math.sqrt(3) / 2;
		hexagonVerts = newFloat32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		]);
		slabIconVerts = newFloat32Array([
			0, 0.5, 1, side, 0, 1, 0, -0.5, 1, -side, 0, 1,
			0, -0.5, 1, side, 0, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0, 1, 0, -0.5, 1, 0, -1, 1, -side, -0.5, 1,
		]);
	})();
	function genIcons() {
		blockIcons = [null];
		let texOrder = [ 1, 2, 3 ];
		let shadows = [ 1, 0.7, 0.4 ];
		let scale = 0.16 / height * inventory.size;
		for (let i = 1; i < blockData.length; i++) {
			let data = [];
			let block = blockData[i];
			for (let j = 0; j < 12; j++) {
				data.push(hexagonVerts[j * 3 + 0] * scale);
				data.push(hexagonVerts[j * 3 + 1] * scale);
				data.push(0.1666666);
				data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 0) % 8]);
				data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 1) % 8]);
				data.push(shadows[Math.floor(j / 4)]);
			}
			let buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(data), gl.STATIC_DRAW);
			blockIcons[i] = buffer;

			data = [];
			for (let j = 0; j < 12; j++) {
				data.push(slabIconVerts[j * 3 + 0] * scale);
				data.push(slabIconVerts[j * 3 + 1] * scale);
				data.push(0.1666666);
				data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 0) % 8]);
				data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 1) % 8]);
				data.push(shadows[Math.floor(j / 4)]);
			}
			buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(data), gl.STATIC_DRAW);
			blockIcons[i | 128] = buffer;
		}
	}

	function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
		let vrLocation = glCache.locations[cacheId];
		if(vrLocation === undefined) {
			vrLocation = gl.getUniformLocation(programObj, vrName);
			glCache.locations[cacheId] = vrLocation;
		}
		gl.uniformMatrix4fv(vrLocation, transpose, matrix);
	}
	function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
		let vrLocation = glCache.locations[cacheId];
		if(vrLocation === undefined) {
			vrLocation = gl.getAttribLocation(programObj, vrName);
			glCache.locations[cacheId] = vrLocation;
		}
		if (vrLocation !== -1) {
			gl.enableVertexAttribArray(vrLocation);
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
			gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0);

		}
	}

	//Generate buffers for every block face and store them
	let sideEdgeBuffers;
	let indexBuffer;

	/** Matrix and Vector transformation methods **/
	//{
	let matrix = newFloat32Array(16);
	let projection = win.projection || newFloat32Array(16);
	win.projection = projection;
	function trans(matrix, x, y, z) {
		let a = matrix;
		a[3] += a[0] * x + a[1] * y + a[2] * z;
		a[7] += a[4] * x + a[5] * y + a[6] * z;
		a[11] += a[8] * x + a[9] * y + a[10] * z;
		a[15] += a[12] * x + a[13] * y + a[14] * z;
	}
	function rotX(matrix, angle) {
	// source = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
		let elems = matrix;
		let c = Math.cos(angle);
		let s = Math.sin(angle);
		let t = elems[1];
		elems[1] = t * c + elems[2] * s;
		elems[2] = t * -s + elems[2] * c;
		t = elems[5];
		elems[5] = t * c + elems[6] * s;
		elems[6] = t * -s + elems[6] * c;
		t = elems[9];
		elems[9] = t * c + elems[10] * s;
		elems[10] = t * -s + elems[10] * c;
		t = elems[13];
		elems[13] = t * c + elems[14] * s;
		elems[14] = t * -s + elems[14] * c;
	}
	function rotY(matrix, angle) {
	//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
		let c = Math.cos(angle);
		let s = Math.sin(angle);
		let elems = matrix;
		let t = elems[0];
		elems[0] = t * c + elems[2] * -s;
		elems[2] = t * s + elems[2] * c;
		t = elems[4];
		elems[4] = t * c + elems[6] * -s;
		elems[6] = t * s + elems[6] * c;
		t = elems[8];
		elems[8] = t * c + elems[10] * -s;
		elems[10] = t * s + elems[10] * c;
		t = elems[12];
		elems[12] = t * c + elems[14] * -s;
		elems[14] = t * s + elems[14] * c;
	}
	function transpose(matrix) {
		let temp = matrix[4];
		matrix[4] = matrix[1];
		matrix[1] = temp;

		temp = matrix[8];
		matrix[8] = matrix[2];
		matrix[2] = temp;

		temp = matrix[6];
		matrix[6] = matrix[9];
		matrix[9] = temp;

		temp = matrix[3];
		matrix[3] = matrix[12];
		matrix[12] = temp;

		temp = matrix[7];
		matrix[7] = matrix[13];
		matrix[13] = temp;

		temp = matrix[11];
		matrix[11] = matrix[14];
		matrix[14] = temp;
	}
	function matMult() {
	//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
		let proj = projection;
		let view = modelView;
		matrix[0] = proj[0] * view[0];
		matrix[1] = proj[0] * view[1];
		matrix[2] = proj[0] * view[2];
		matrix[3] = proj[0] * view[3];
		matrix[4] = proj[5] * view[4];
		matrix[5] = proj[5] * view[5];
		matrix[6] = proj[5] * view[6];
		matrix[7] = proj[5] * view[7];
		matrix[8] = proj[10] * view[8] + proj[11] * view[12];
		matrix[9] = proj[10] * view[9] + proj[11] * view[13];
		matrix[10] = proj[10] * view[10] + proj[11] * view[14];
		matrix[11] = proj[10] * view[11] + proj[11] * view[15];
		matrix[12] = proj[14] * view[8];
		matrix[13] = proj[14] * view[9];
		matrix[14] = proj[14] * view[10];
		matrix[15] = proj[14] * view[11];
	}
	function copyArr(a, b) {
		for (let i = 0; i < a.length; i++) {
			b[i] = a[i];
		}
	}
	function FOV(fov) {
		let tang = Math.tan(fov * 0.5 * Math.PI / 180);
		let scale = 1 / tang;
		let near = 1;
		let far = 1000000;
		currentFov = fov;
		nearH = near * tang;

		projection[0] = scale / width * height;
		projection[5] = scale;
		projection[10] = -far / (far - near);
		projection[11] = -1;
		projection[14] = -far * near / (far - near);

	// Set the projecction matrix in the shader
	// copyArr(projection, matrix);
	// transpose(matrix);
	// uniformMatrix("projection3d", programObject3D, "uProjection", false, matrix);
	}
	function cross(v1, v2, result) {
		let x = v1.x,
			y = v1.y,
			z = v1.z,
			x2 = v2.x,
			y2 = v2.y,
			z2 = v2.z;
		result.x = y * z2 - y2 * z;
		result.y = z * x2 - z2 * x;
		result.z = x * y2 - x2 * y;
	}
	//}

	function Plane(nx, ny, nz) {
		this.dx = nx > 0 ? 16 : 0;
		this.dy = ny > 0;
		this.dz = nz > 0 ? 16 : 0;

		// Normal vector
		this.nx = nx;
		this.ny = ny;
		this.nz = nz;
	}
	Plane.prototype.set = Plane;
	function computeFrustum() {
		let X = vec1;
		X.x = p.direction.z;
		X.y = 0
		X.z = -p.direction.x;
		X.normalize();

		let Y = vec2;
		Y.set(p.direction);
		Y.mult(-1);
		cross(Y, X, Y);

		//Near plane (hoisted to outside the render loop to improve performance)
		// var x = p.x + p.direction.x;
		// var y = p.y + p.direction.y;
		// var z = p.z + p.direction.z;
		// p.frustum[0].set(x, y, z, p.direction.x, p.direction.y, p.direction.z);

		let aux = vec3;
		aux.set(Y);
		aux.mult(nearH);
		aux.add(p.direction);
		aux.normalize();
		cross(aux, X, aux);
		p.frustum[0].set(aux.x, aux.y, aux.z);

		aux.set(Y);
		aux.mult(-nearH);
		aux.add(p.direction);
		aux.normalize();
		cross(X, aux, aux);
		p.frustum[1].set(aux.x, aux.y, aux.z);

		aux.set(X);
		aux.mult(-nearH * width / height);
		aux.add(p.direction);
		aux.normalize();
		cross(aux, Y, aux);
		p.frustum[2].set(aux.x, aux.y, aux.z);

		aux.set(X);
		aux.mult(nearH * width / height);
		aux.add(p.direction);
		aux.normalize();
		cross(Y, aux, aux);
		p.frustum[3].set(aux.x, aux.y, aux.z);
	}
	let chunkVisible = function(x, y, z, maxY) {
		x -= 0.5;
		y -= 0.5;
		z -= 0.5;
		maxY += 0.5;
		let px = 0, py = 0, pz = 0, plane = null;
		let cx = p.x, cy = p.y, cz = p.z;
		for (let i = 0; i < 4; i++) {
			plane = p.frustum[i];
			px = x + plane.dx;
			py = plane.dy ? maxY : y;
			pz = z + plane.dz;
			if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
				return false;
			}
		}
		return true;
	};

	let defaultModelView = newFloat32Array([ -10,0,0,0,0,10,0,0,0,0,-10,0,0,0,0,1 ]);
	let initModelView = function(x, y, z, rx, ry) {
		copyArr(defaultModelView, modelView);
		rotX(modelView, rx);
		rotY(modelView, ry);
		trans(modelView, -x, -y, -z);
		matMult();
		transpose(matrix);
		uniformMatrix("view3d", programObject3D, "uView", false, matrix);
	};
	let tex;

	function getFaces(x, y, z) {
		return p.x < x - 0.5
	| (p.x > x + 0.5) << 1
	| (p.y < y - 0.5) << 2
	| (p.y > y + 0.5) << 3
	| (p.z < z - 0.5) << 4
	| (p.z > z + 0.5) << 5;
	}
	function rayTrace(x, y, z, sides) {
		x -= 0.5;
		y -= 0.5;
		z -= 0.5;

		let cf, cd = 1e9; //Closest face and distance
		let m; //Absolute distance to intersection point
		let ix, iy, iz; //Intersection coords

		//Top and bottom faces
		if (Block.top & sides && p.direction.y) {
			m = (y - p.y) / p.direction.y;
			ix = m * p.direction.x + p.x;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iz >= z && iz <= z + 1) {
				cd = m; //Ray crosses top face
				cf = "top";
			}
		}
		y += 1;
		if (Block.bottom & sides && p.direction.y) {
			m = (y - p.y) / p.direction.y;
			ix = m * p.direction.x + p.x;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iz >= z && iz <= z + 1) {
				cd = m;
				cf = "bottom";
			}
		}
		y -= 1;

		//West and East faces
		if (Block.west & sides && p.direction.x) {
			m = (x - p.x) / p.direction.x;
			iy = m * p.direction.y + p.y;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && iy >= y && iy <= y + 1 && iz >= z && iz <= z + 1) {
				cd = m;
				cf = "west";
			}
		}
		x += 1;
		if (Block.east & sides && p.direction.x) {
			m = (x - p.x) / p.direction.x;
			iy = m * p.direction.y + p.y;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && iy >= y && iy <= y + 1 && iz >= z && iz <= z + 1) {
				cd = m;
				cf = "east";
			}
		}
		x -= 1;

		//South and North faces
		if (Block.south & sides && p.direction.z) {
			m = (z - p.z) / p.direction.z;
			ix = m * p.direction.x + p.x;
			iy = m * p.direction.y + p.y;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iy >= y && iy <= y + 1) {
				cd = m;
				cf = "south";
			}
		}
		z += 1;
		if (Block.north & sides && p.direction.z) {
			m = (z - p.z) / p.direction.z;
			ix = m * p.direction.x + p.x;
			iy = m * p.direction.y + p.y;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iy >= y && iy <= y + 1) {
				cd = m;
				cf = "north";
			}
		}
		return [ cd, cf ];
	}
	function runRayTrace(x, y, z, faces) {
		let block = world.getBlock(x, y, z);
		if (block) {
			let rt = rayTrace(x, y, z, faces);

			if (rt[1] && rt[0] < hitBox.closest) {
				hitBox.closest = rt[0];
				hitBox.face = rt[1];
				hitBox.pos = [ x, y, z ];
			}
		}
	}
	function lookingAt() {
		// Checks blocks in front of the player to see which one they're looking at
		hitBox.pos = null;
		hitBox.closest = 1e9;

		if (p.spectator) {
			return;
		}
		if (world.getBlock(p2.x, p2.y, p2.z)) {
			hitBox.pos = [ p2.x, p2.y, p2.z ];
			hitBox.closest = 0;
			return;
		}

		let pd = p.direction;

		// Target block
		let tx = Math.round(pd.x * reach + p.x);
		let ty = Math.round(pd.y * reach + p.y);
		let tz = Math.round(pd.z * reach + p.z);

		let minX = p2.x;
		let maxX = 0;
		let minY = p2.y;
		let maxY = 0;
		let minZ = p2.z;
		let maxZ = 0;
		let faces = getFaces(tx, ty, tz);

		for (let i = 0; i < reach + 1; i++) {
			if (i > reach) {
				i = reach;
			}
			maxX = Math.round(p.x + pd.x * i);
			maxY = Math.round(p.y + pd.y * i);
			maxZ = Math.round(p.z + pd.z * i);
			if (maxX === minX && maxY === minY && maxZ === minZ) {
				continue;
			}
			if (minX !== maxX) {
				if (minY !== maxY) {
					if (minZ !== maxZ) {
						runRayTrace(maxX, maxY, maxZ, faces);
					}
					runRayTrace(maxX, maxY, minZ, faces);
				}
				if (minZ !== maxZ) {
					runRayTrace(maxX, minY, maxZ, faces);
				}
				runRayTrace(maxX, minY, minZ, faces);
			}
			if (minY !== maxY) {
				if (minZ !== maxZ) {
					runRayTrace(minX, maxY, maxZ, faces);
				}
				runRayTrace(minX, maxY, minZ, faces);
			}
			if (minZ !== maxZ) {
				runRayTrace(minX, minY, maxZ, faces);
			}
			if (hitBox.pos) {
				return; //The ray has collided; it can't possibly find a closer collision now
			}
			minZ = maxZ;
			minY = maxY;
			minX = maxX;
		}
	}
	let inBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.topH;
		let ih = h + p.bottomH + p.topH;
		let ix = x - w/2 - p.w;
		let iw = w + p.w*2;
		let iz = z - d/2 - p.w;
		let id = d + p.w*2;
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id;
	};
	let onBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.topH;
		let ih = h + p.bottomH + p.topH;
		let ix = x - w/2 - p.w;
		let iw = w + p.w*2;
		let iz = z - d/2 - p.w;
		let id = d + p.w*2;
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y <= iy + ih && p.z < iz + id;
	};
	let boxCollision = function(x, y, z, w, h, d, vx, vy, vz, dt) {
		if(!p.spectator && inBox(x, y, z, w, h, d)) {
			if(vx) {
				p.x -= p.velocity.x * dt;
				p.velocity.x = 0;
			} else if(vz) {
				p.z -= p.velocity.z * dt;
				p.velocity.z = 0;
			} else if(vy > 0) {
				p.y -= p.velocity.y * dt;
				p.velocity.y = 0;
			} else {
				p.y = y - h/2 - p.topH + (h + p.bottomH + p.topH); // y + h/2 + p.bottomH;
				p.onGround = true;
				p.velocity.y = 0;
			}
		}
	};
	let contacts = {
		array: [],
		size: 0,
		add: function(x, y, z) {

			if (this.size === this.array.length) {
				this.array.push([ x, y, z ]);
			} else {
				this.array[this.size][0] = x;
				this.array[this.size][1] = y;
				this.array[this.size][2] = z;
			}
			this.size++;
		},
		clear: function() {
			this.size = 0;
		},
	};
	let resolveContactsAndUpdatePosition = function() {
		let minX = p2.x - 1;
		let maxX = p2.x + 1;
		let minY = p2.y - 2;
		let maxY = p2.y + 1;
		let minZ = p2.z - 1;
		let maxZ = p2.z + 1;
		let wrld = world;
		let cont = contacts;
		let block = null;
		let player = p;

		for (let x = minX; x <= maxX; x++) {
			for (let y = minY; y <= maxY; y++) {
				for (let z = minZ; z <= maxZ; z++) {
					if (wrld.getBlock(x, y, z)) {
						cont.add(x, y, z);
					}
				}
			}
		}

		let dt = (win.performance.now() - p.lastUpdate) / 33;
		dt = dt > 2 ? 2 : dt;

		//console.log(p.onGround || !p.flying && p.y === p.previousY);

		p.previousX = p.x;
		p.previousY = p.y;
		p.previousZ = p.z;

		var sneakLock = false, sneakSafe = false;
		if (p.sneaking) {
			for (let i = 0; i < contacts.size; i++) {
				block = cont.array[i];
				if (onBox(block[0], block[1], block[2], 1, 1, 1)) {
					sneakLock = true;
					break;
				}
			}
		}

		//Check collisions in the X direction
		player.x += player.velocity.x * dt;
		for (let i = 0; i < contacts.size; i++) {
			block = cont.array[i];
			boxCollision(block[0], block[1], block[2], 1, 1, 1, player.velocity.x, 0, 0, dt);
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true;
			}
		}

		if (sneakLock && !sneakSafe) {
			p.x = p.previousX;
			p.velocity.x = 0;
		}
		sneakSafe = false;

		//Check collisions in the Z direction
		player.z += player.velocity.z * dt;
		for (let i = 0; i < contacts.size; i++) {
			block = cont.array[i];
			boxCollision(block[0], block[1], block[2], 1, 1, 1, 0, 0, player.velocity.z, dt);
			if (sneakLock && onBox(block[0], block[1], block[2], 1, 1, 1)) {
				sneakSafe = true;
			}
		}

		if (sneakLock && !sneakSafe) {
			p.z = p.previousZ;
			p.velocity.z = 0;
		}

		//Check collisions in the Y direction
		p.onGround = false;
		player.y += player.velocity.y * dt;
		for (let i = 0; i < contacts.size; i++) {
			block = cont.array[i];
			boxCollision(block[0], block[1], block[2], 1, 1, 1, 0, player.velocity.y, 0, dt);
		}

		if (!p.flying) {
			let drag = p.onGround ? 0.5 : 0.85;
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
		} else {
			let drag = 0.9;
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
			p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y) * dt;
			if (p.onGround && !p.spectator) {
				p.flying = false;
			}
		}

		p.lastUpdate = win.performance.now();
		contacts.clear();
		lookingAt();
		if (hitBox.pos) {
			let block = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]);
			hitBox.shape = (block & 0b10000000) ? "slab" : "cube";
		}
	};
	let runGravity = function() {
		if (p.flying) {
			return;
		}
		let dt = (win.performance.now() - p.lastUpdate) / 33;
		dt = dt > 2 ? 2 : dt;
		if(p.onGround) {
			if(Key[" "]) {
				p.velocity.y = p.jumpSpeed;
				p.onGround = false;
			} else {
				p.velocity.y = 0;
			}
		} else {
			p.velocity.y += p.gravityStength * dt;
			if(p.velocity.y < -p.maxYVelocity) {
				p.velocity.y = -p.maxYVelocity;
			}
		}
	};

	function box2(sides, tex) {
		if (blockFill) {
			let i = 0;
			for (let side in Block) {
				if (sides & Block[side]) {
					vertexAttribPointer("aVertex", programObject3D, "aVertex", 3, sideEdgeBuffers[Sides[side]]);
					vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]]);
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0);
				}
				i++;
			}
		}
		if (blockOutlines) {
			vertexAttribPointer("aVertex", programObject3D, "aVertex", 3, shapes[hitBox.shape].buffer);
			vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox]);
			for (let i = 0; i < shapes[hitBox.shape].size; i++) {
				gl.drawArrays(gl.LINE_LOOP, i * 4, 4);
			}
		}
	}
	function block2(x, y, z, t) {
		copyArr(modelView, matrix);
		trans(modelView, x, y, z);
		matMult();
		trans(modelView, -x, -y, -z);
		transpose(matrix);
		uniformMatrix("view3d", programObject3D, "uView", false, matrix);
		box2(0xff, blockData[t].textures);
	}

	let changeWorldBlock = function(t) {
		let pos = hitBox.pos;
		if(pos && pos[1] > 0 && pos[1] < maxHeight) {
			world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t);
			if (t) {
				p.lastPlace = Date.now();
			} else {
				p.lastBreak = Date.now();
			}
		}
	};
	let newWorldBlock = function() {
		if(!hitBox.pos || !holding) {
			return;
		}
		let pos = hitBox.pos, x= pos[0], y = pos[1], z = pos[2];
		switch(hitBox.face) {
			case "top":
				y -= 1;
				break;
			case "bottom":
				y += 1;
				break;
			case "south":
				z -= 1;
				break;
			case "north":
				z += 1;
				break;
			case "west":
				x -= 1;
				break;
			case "east":
				x += 1;
				break;
		}
		if (!inBox(x, y, z, 1, 1, 1) && !world.getBlock(x, y, z)) {
			pos[0] = x;
			pos[1] = y;
			pos[2] = z;
			changeWorldBlock(holding | blockMode << 7);
		}
	};

	let sphere;
	(function() {
		let blocks = [];
		let radius = 3.5;
		let radsq = radius * radius;
		for (let i = -radius; i <= radius; i++) {
			for (let j = -radius; j <= radius; j++) {
				for (let k = -radius; k <= radius; k++) {
					if (i*i + j*j + k*k < radsq) {
						blocks.push(i|0, j|0, k|0);
					}
				}
			}
		}
		sphere = new Int8Array(blocks);
	})();
	generator.caveSize = 0.0055;
	function isCave(x, y, z) {
		let smooth = 0.02;
		let cave1 = Math.abs(0.5 - caveNoise(x * smooth, y * smooth, z * smooth)) < generator.caveSize;
		let cave2 = Math.abs(0.5 - caveNoise(y * smooth, z * smooth, x * smooth)) < generator.caveSize;
		return (cave1 && cave2);
	}
	function carveSphere(x, y, z) {
		if (y > 3) {
			for (let i = 0; i < sphere.length; i += 3) {
				world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true);
			}
		}
	}

	let renderedChunks = 0;
	function getBlock(x, y, z, blocks) {
		return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)] & 127;
	}
	function getBlock2(x, y, z, blocks) {
		return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)] & 0xff;
	}
	function hideFace(x, y, z, blocks, type, func) {
		let block = func.call(world, x, y, z, blocks);
		let data = blockData[block & 127]
		if (!block || block !== type && data.transparent || data.transparent && data.shadow || (block & 128)) {
			return 1;
		}
		return 0;
	}
	let getShadows = {
		shade: [ 1, 0.85, 0.7, 0.6, 0.3 ],
		top: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z-1, block)].shadow,
				blockData[getBlock(x, y-1, z-1, block)].shadow,
				blockData[getBlock(x+1, y-1, z-1, block)].shadow,
				blockData[getBlock(x-1, y-1, z, block)].shadow,
				blockData[getBlock(x, y-1, z, block)].shadow,
				blockData[getBlock(x+1, y-1, z, block)].shadow,
				blockData[getBlock(x-1, y-1, z+1, block)].shadow,
				blockData[getBlock(x, y-1, z+1, block)].shadow,
				blockData[getBlock(x+1, y-1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8,
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8,
			];
		},
		bottom: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y+1, z-1, block)].shadow,
				blockData[getBlock(x, y+1, z-1, block)].shadow,
				blockData[getBlock(x+1, y+1, z-1, block)].shadow,
				blockData[getBlock(x-1, y+1, z, block)].shadow,
				blockData[getBlock(x, y+1, z, block)].shadow,
				blockData[getBlock(x+1, y+1, z, block)].shadow,
				blockData[getBlock(x-1, y+1, z+1, block)].shadow,
				blockData[getBlock(x, y+1, z+1, block)].shadow,
				blockData[getBlock(x+1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
			];
		},
		north: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z+1, block)].shadow,
				blockData[getBlock(x, y-1, z+1, block)].shadow,
				blockData[getBlock(x+1, y-1, z+1, block)].shadow,
				blockData[getBlock(x-1, y, z+1, block)].shadow,
				blockData[getBlock(x, y, z+1, block)].shadow,
				blockData[getBlock(x+1, y, z+1, block)].shadow,
				blockData[getBlock(x-1, y+1, z+1, block)].shadow,
				blockData[getBlock(x, y+1, z+1, block)].shadow,
				blockData[getBlock(x+1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
			];
		},
		south: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z-1, block)].shadow,
				blockData[getBlock(x-1, y, z-1, block)].shadow,
				blockData[getBlock(x-1, y+1, z-1, block)].shadow,
				blockData[getBlock(x, y-1, z-1, block)].shadow,
				blockData[getBlock(x, y, z-1, block)].shadow,
				blockData[getBlock(x, y+1, z-1, block)].shadow,
				blockData[getBlock(x+1, y-1, z-1, block)].shadow,
				blockData[getBlock(x+1, y, z-1, block)].shadow,
				blockData[getBlock(x+1, y+1, z-1, block)].shadow,
			];
			return [
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
			];
		},
		east: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x+1, y-1, z-1, block)].shadow,
				blockData[getBlock(x+1, y, z-1, block)].shadow,
				blockData[getBlock(x+1, y+1, z-1, block)].shadow,
				blockData[getBlock(x+1, y-1, z, block)].shadow,
				blockData[getBlock(x+1, y, z, block)].shadow,
				blockData[getBlock(x+1, y+1, z, block)].shadow,
				blockData[getBlock(x+1, y-1, z+1, block)].shadow,
				blockData[getBlock(x+1, y, z+1, block)].shadow,
				blockData[getBlock(x+1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8,
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8,
			];
		},
		west: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z-1, block)].shadow,
				blockData[getBlock(x-1, y, z-1, block)].shadow,
				blockData[getBlock(x-1, y+1, z-1, block)].shadow,
				blockData[getBlock(x-1, y-1, z, block)].shadow,
				blockData[getBlock(x-1, y, z, block)].shadow,
				blockData[getBlock(x-1, y+1, z, block)].shadow,
				blockData[getBlock(x-1, y-1, z+1, block)].shadow,
				blockData[getBlock(x-1, y, z+1, block)].shadow,
				blockData[getBlock(x-1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8,
				this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8,
				this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8,
				this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8,
			];
		},
	};

	/** Section Class **/
	//{
	function Section(x, y, z, size, chunk) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.size = size;
		this.arraySize = size * size * size;
		this.blocks = newInt32Array(this.arraySize);
		this.renderData = [];
		this.renderLength = 0;
		this.faces = 0;
		this.hasVisibleBlocks = false;
		this.chunk = chunk;
		this.edited = false;
		this.caves = false;
	}
	Section.prototype.getBlock = function(x, y, z) {
		let s = this.size;
		return this.blocks[x * s * s + y * s + z] & 0xff;
	};
	Section.prototype.setBlock = function(x, y, z, blockID, hidden) {
		let s = this.size;
		this.blocks[x * s * s + y * s + z] = !hidden << 31 | blockID;
	};
	Section.prototype.deleteBlock = function(x, y, z) {
		let s = this.size;
		let data = this.blocks[x * s * s + y * s + z];
		let index = this.renderData.indexOf(data);
		if (index >= 0 && index < this.renderLength) {
			this.renderData.splice(index, 1);
			this.renderLength--;
			this.hasVisibleBlocks = !!this.renderLength;
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk);
			}
		}
		this.blocks[x * s * s + y * s + z] = blockIds.air;
	};
	Section.prototype.optimize = function(world) {
		let visible = false;
		let pos = 0;
		let xx = this.x;
		let yy = this.y;
		let zz = this.z;
		let blockData = 0;
		let blockType = 0;
		let index = 0;
		let s = this.size;
		let blocks = this.blocks;
		this.hasVisibleBlocks = false;
		this.renderLength = 0;
		let localBlocks = world.getAdjacentSubchunks(xx, yy, zz);

		//Check all the blocks in the subchunk to see if they're visible.
		for (let i = 0; i < s; i++) {
			for (let j = 0; j < s; j++) {
				for (let k = 0; k < s; k++, index++) {
					blockData = blocks[index];
					if (blockData >= 0) {
						continue;
					}
					blockType = blockData & 0xff;
					// x = i + xx;
					// y = j + yy;
					// z = k + zz;
					visible = hideFace(i-1, j, k, localBlocks, blockType, getBlock2)
					| hideFace(i+1, j, k, localBlocks, blockType, getBlock2) << 1
					| hideFace(i, j-1, k, localBlocks, blockType, getBlock2) << 2
					| hideFace(i, j+1, k, localBlocks, blockType, getBlock2) << 3
					| hideFace(i, j, k-1, localBlocks, blockType, getBlock2) << 4
					| hideFace(i, j, k+1, localBlocks, blockType, getBlock2) << 5;
					if (visible) {
						pos = (i | j << 4 | k << 8) << 16;
						blockData = 1 << 31 | pos | visible << 8 | blockType;
						this.renderData[this.renderLength++] = blockData;
						blocks[index] = blockData;
						this.hasVisibleBlocks = true;
					} else {
						blocks[index] = blockType;
					}
				}
			}
		}
	};
	Section.prototype.updateBlock = function(x, y, z, world) {
		let i = x;
		let j = y;
		let k = z;
		let s = this.size;
		x += this.x;
		y += this.y;
		z += this.z;
		let blockData = this.blocks[i * s * s + j * s + k];
		let blockType = blockData & 0xff;
		let visible = blockType && hideFace(x-1, y, z, 0, blockType, world.getBlock)
		| hideFace(x+1, y, z, 0, blockType, world.getBlock) << 1
		| hideFace(x, y-1, z, 0, blockType, world.getBlock) << 2
		| hideFace(x, y+1, z, 0, blockType, world.getBlock) << 3
		| hideFace(x, y, z-1, 0, blockType, world.getBlock) << 4
		| hideFace(x, y, z+1, 0, blockType, world.getBlock) << 5;
		let pos = (i | j << 4 | k << 8) << 16;
		let index = blockData < 0 ? this.renderData.indexOf(blockData) : -1;

		if ((index < 0 || index >= this.renderLength) && !visible) {
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk);
			}
			return;
		}
		if (!visible) {
			this.renderData.splice(index, 1);
			this.blocks[i * s * s + j * s + k] = blockType; //Toggle invisible bit
			this.renderLength--;
			this.hasVisibleBlocks = !!this.renderLength;
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk);
			}
			this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
			this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
			return;
		}
		if (visible && (index < 0 || index >= this.renderLength)) {
			index = this.renderLength++;
			this.hasVisibleBlocks = true;
		}
		this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
		this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
		this.renderData[index] = 1 << 31 | pos | visible << 8 | blockData & 0xff;
		this.blocks[i * s * s + j * s + k] = this.renderData[index];
		if (!world.meshQueue.includes(this.chunk)) {
			world.meshQueue.push(this.chunk);
		}
	};
	Section.prototype.genMesh = function(barray, index) {
		if (!this.renderLength) {
			return index;
		}
		let length = this.renderLength;
		let rData = this.renderData;
		let x = 0, y = 0, z = 0, loc = 0, data = 0, sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0, verts = null, texVerts = null, texShapeVerts = null, tx = 0, ty = 0;
		let wx = this.x, wy = this.y, wz = this.z;
		let blocks = world.getAdjacentSubchunks(wx, wy, wz);

		let shadows = null;
		let blockSides = Object.keys(Block);
		let side = "";
		let shapeVerts = null;
		let shapeTexVerts = null;
		for (let i = 0; i < length; i++) {
			data = rData[i];
			tex = blockData[data & 127].textures;
			sides = data >> 8 & 0x3f;
			loc = data >> 16;
			x = loc & 15;
			y = loc >> 4 & 15;
			z = loc >> 8 & 15;

			x2 = x + this.x;
			y2 = y + this.y;
			z2 = z + this.z;

			if (data & 128) {
				shapeVerts = shapes.slab.verts;
				shapeTexVerts = shapes.slab.texVerts;
			} else {
				shapeVerts = shapes.cube.verts;
				shapeTexVerts = shapes.cube.texVerts;
			}

			let texNum = 0;
			for (let n = 0; n < 6; n++) {
				side = blockSides[n];
				if (sides & Block[side]) {
					shadows = getShadows[side](x, y, z, blocks);
					verts = shapeVerts[Sides[side]][0];
					texVerts = textureCoords[textureMap[tex[texNum]]];
					tx = texVerts[2];
					ty = texVerts[3];
					texShapeVerts = shapeTexVerts[n][0];

					barray[index] = verts[0] + x2;
					barray[index+1] = verts[1] + y2;
					barray[index+2] = verts[2] + z2;
					barray[index+3] = tx + texShapeVerts[0];
					barray[index+4] = ty + texShapeVerts[1];
					barray[index+5] = shadows[0];

					barray[index+6] = verts[3] + x2;
					barray[index+7] = verts[4] + y2;
					barray[index+8] = verts[5] + z2;
					barray[index+9] = tx + texShapeVerts[2];
					barray[index+10] = ty + texShapeVerts[3];
					barray[index+11] = shadows[1];

					barray[index+12] = verts[6] + x2;
					barray[index+13] = verts[7] + y2;
					barray[index+14] = verts[8] + z2;
					barray[index+15] = tx + texShapeVerts[4];
					barray[index+16] = ty + texShapeVerts[5];
					barray[index+17] = shadows[2];

					barray[index+18] = verts[9] + x2;
					barray[index+19] = verts[10] + y2;
					barray[index+20] = verts[11] + z2;
					barray[index+21] = tx + texShapeVerts[6];
					barray[index+22] = ty + texShapeVerts[7];
					barray[index+23] = shadows[3];
					index += 24;
				}
				texNum++;
			}
		}
		return index;
	};
	Section.prototype.carveCaves = function() {
		let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16;
		for (let x = this.x, xx = 0; x < wx; x++, xx++) {
			for (let z = this.z, zz = 0; z < wz; z++, zz++) {
				wy = this.chunk.tops[zz * 16 + xx];
				for (let y = this.y; y < wy; y++) {
					if (isCave(x, y, z)) {
						carveSphere(x, y, z);
					}
				}
			}
		}
		this.caves = true;
	}
	Section.prototype.tick = function() {
		for (let i = 0; i < 3; i++) {
			let rnd = Math.random() * this.blocks.length | 0;
			if ((this.blocks[rnd] & 255) === blockIds.grass) {
				// Spread grass

				let x = (rnd >> 8) + this.x;
				let y = (rnd >> 4 & 15) + this.y;
				let z = (rnd & 15) + this.z;
				if (!blockData[world.getBlock(x, y + 1, z) & 127].transparent) {
					world.setBlock(x, y, z, blockIds.air, false);
					world.setBlock(x, y, z, blockIds.dirt, false);
					return;
				}

				let rnd2 = Math.random() * 27 | 0;
				let x2 = rnd2 % 3 - 1;
				rnd2 = (rnd2 - x2 - 1) / 3;
				let y2 = rnd2 % 3 - 1;
				rnd2 = (rnd2 - y2 - 1) / 3;
				z += rnd2 - 1;
				x += x2;
				y += y2;

				if (world.getBlock(x, y, z) === blockIds.dirt && world.getBlock(x, y + 1, z) === blockIds.air) {
					world.setBlock(x, y, z, blockIds.air, false);
					world.setBlock(x, y, z, blockIds.grass, false);
				}
			}
		}
	};
	//}
	function newSection(x, y, z, size, chunk) {
		let section = Object.create(Section.prototype);
		Section.apply(section, [ x, y, z, size, chunk ]);
		return section;
	}
	let emptySection = newSection(0, 0, 0, 16);
	let fullSection = newSection(0, 0, 0, 16);
	fullSection.blocks.fill(blockIds.bedrock);

	/** Chunk Class **/
	//{
	function Chunk(x, z) {
		this.x = x;
		this.z = z;
		this.maxY = 0;
		this.minY = 255;
		this.sections = [];
		this.cleanSections = [];
		this.tops = new Uint8Array(16 * 16); // Store the heighest block at every (x,z) coordinate
		this.optimized = false;
		this.generated = false; //Terrain
		this.populated = superflat; //Trees
		this.lazy = false;
		this.edited = false;
		this.caves = superflat;
	}
	Chunk.prototype.getBlock = function(x, y, z) {
		let s = y >> 4;
		return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0;
	};
	Chunk.prototype.setBlock = function(x, y, z, blockID, hidden, user) {
		if (!this.sections[y >> 4]) {
			do {
				this.sections.push(newSection(this.x, this.sections.length * 16, this.z, 16, this));
			} while (!this.sections[y >> 4]);
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice();
			this.sections[y >> 4].edited = true;
			this.edited = true;
		}
		this.sections[y >> 4].setBlock(x, y & 15, z, blockID, hidden);
	};
	Chunk.prototype.optimize = function(world) {
		for (let i = 0; i < this.sections.length; i++) {
			this.sections[i].optimize(world);
		}
		if (!world.meshQueue.includes(this)) {
			world.meshQueue.push(this);
		}
		this.optimized = true;
	};
	Chunk.prototype.render = function() {
		if (!this.buffer) {
			return;
		}
		if (chunkVisible(this.x, this.minY, this.z, this.maxY)) {
			renderedChunks++;
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
			gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
			gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
			gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0);
		}
	};
	Chunk.prototype.updateBlock = function(x, y, z, world, lazy) {
		if (this.buffer) {
			this.lazy = lazy;
			if (this.sections.length > y >> 4) {
				this.sections[y >> 4].updateBlock(x, y & 15, z, world);
			}
		}
	};
	Chunk.prototype.deleteBlock = function(x, y, z, user) {
		if (!this.sections[y >> 4]) {
			return;
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice();
			this.sections[y >> 4].edited = true;
			this.edited = true;
		}
		this.sections[y >> 4].deleteBlock(x, y & 15, z);
		this.minY = y < this.minY ? y : this.minY;
		this.maxY = y > this.maxY ? y : this.maxY;
		// if (y === this.tops[z * 16 + x]) {
		// 	while(--y && !this.getBlock(x, y, z)) {}
		// 	this.tops[z * 16 + x] = y;
		// }
	};
	Chunk.prototype.carveCaves = function() {
		for (let i = 0; i < this.sections.length; i++) {
			if (!this.sections[i].caves) {
				this.sections[i].carveCaves();
				if (i + 1 >= this.sections.length) {
					this.caves = true;
				}
				return;
			}
		}
	};
	Chunk.prototype.populate = function() {
		randomSeed(hash(this.x, this.z) * 210000000);
		let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false;

		for (let i = 0; i < 16; i++) {
			for (let k = 0; k < 16; k++) {
				wx = this.x + i;
				wz = this.z + k;
				ground = this.tops[k * 16 + i];
				if (random() < 0.005 && this.getBlock(i, ground, k)) {

					top = ground + Math.floor(4.5 + random(2.5));
					rand = Math.floor(random(4096));
					let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog;

					//Center
					for (let j = ground + 1; j <= top; j++) {
						this.setBlock(i, j, k, tree);
					}
					this.setBlock(i, top + 1, k, blockIds.leaves);
					this.setBlock(i, ground, k, blockIds.dirt);

					//Bottom leaves
					for (let x = -2; x <= 2; x++) {
						for (let z = -2; z <= 2; z++) {
							if (x || z) {
								if ((x * z & 7) === 4) {
									place = rand & 1;
									rand >>>= 1;
									if (place) {
										world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
									}
								} else {
									world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
								}
							}
						}
					}

					//2nd layer leaves
					for (let x = -2; x <= 2; x++) {
						for (let z = -2; z <= 2; z++) {
							if (x || z) {
								if ((x * z & 7) === 4) {
									place = rand & 1;
									rand >>>= 1;
									if (place) {
										world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
									}
								} else {
									world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
								}
							}
						}
					}

					//3rd layer leaves
					for (let x = -1; x <= 1; x++) {
						for (let z = -1; z <= 1; z++) {
							if (x || z) {
								if (x & z) {
									place = rand & 1;
									rand >>>= 1;
									if (place) {
										world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
									}
								} else {
									world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
								}
							}
						}
					}

					//Top leaves
					world.spawnBlock(wx + 1, top + 1, wz, blockIds.leaves);
					world.spawnBlock(wx, top + 1, wz - 1, blockIds.leaves);
					world.spawnBlock(wx, top + 1, wz + 1, blockIds.leaves);
					world.spawnBlock(wx - 1, top + 1, wz, blockIds.leaves);
				}

				// Blocks of each per chunk in Minecraft
				// Coal: 185.5
				// Iron: 111.5
				// Gold: 10.4
				// Redstone: 29.1
				// Diamond: 3.7
				// Lapis: 4.1
				ground -= 4;

				if (random() < 3.7 / 256) {
					let y = random() * 16 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre);
					}
				}

				if (random() < 111.5 / 256) {
					let y = random() * 64 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre);
					}
				}

				if (random() < 185.5 / 256) {
					let y = random() * ground | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre);
					}
				}

				if (random() < 10.4 / 256) {
					let y = random() * 32 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre);
					}
				}

				if (random() < 29.1 / 256) {
					let y = random() * 16 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre);
					}
				}

				if (random() < 4.1 / 256) {
					let y = random() * 32 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre);
					}
				}
			}
		}

		this.populated = true;
	};
	Chunk.prototype.genMesh = function() {
		let start = win.performance.now();
		let barray = bigArray;
		let index = 0;
		let g = gl;
		for (let i = 0; i < this.sections.length; i++) {
			index = this.sections[i].genMesh(barray, index);
		}
		let arrayDone = win.performance.now();

		if (!this.buffer) {
			this.buffer = g.createBuffer();
		}
		let data = barray.slice(0, index);
		let maxY = 0;
		let minY = 255;
		let y = 0;
		for (let i = 1; i < data.length; i += 6) {
			y = data[i]
			maxY = Math.max(maxY, y);
			minY = Math.min(minY, y);
		}
		this.maxY = maxY;
		this.minY = minY;
		this.faces = data.length / 24;
		g.bindBuffer(g.ARRAY_BUFFER, this.buffer);
		g.bufferData(g.ARRAY_BUFFER, data, g.DYNAMIC_DRAW);
		this.lazy = false;
	};
	Chunk.prototype.tick = function() {
		if (this.edited) {
			for (let i = 0; i < this.sections.length; i++) {
				if (this.sections[i].edited) {
					this.sections[i].tick();
				}
			}
		}
	};
	Chunk.prototype.load = function() {
		let chunkX = this.x >> 4;
		let chunkZ = this.z >> 4;
		let load = null;
		
		for (let i = 0; i < world.loadFrom.length; i++) {
			load = world.loadFrom[i];
			if (load.x === chunkX && load.z === chunkZ) {
				let y = load.y * 16;
				for (let j in load.blocks) {
					world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j]);
				}
				world.loadFrom.splice(i--, 1);
			}
		}
	}
	//}
	function newChunk(x, z) {
		let chunk = Object.create(Chunk.prototype);
		Chunk.call(chunk, x, z);
		return chunk;
	}

	let analytics = {
		totalTickTime: 0,
		worstFrameTime: 0,
		totalRenderTime: 0,
		totalFrameTime: 0,
		lastUpdate: 0,
		frames: 1,
		displayedTickTime: "0",
		displayedRenderTime: "0",
		displayedFrameTime: "0",
		displayedwFrameTime: 0,
		fps: 0,
	};
	function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
		let dx1 = p.x - c1.x - 8;
		let dy1 = p.z - c1.z - 8;
		let dx2 = p.x - c2.x - 8;
		let dy2 = p.z - c2.z - 8;
		return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2);
	}
	function fillReqs(x, z) {
		// Chunks must all be loaded first.
		var done = true;
		for (let i = x - 2; i <= x + 2; i++) {
			for (let j = z - 2; j <= z + 2; j++) {
				let chunk = world.loaded[(i + world.offsetX) * world.lwidth + j + world.offsetZ]
				if (!chunk.generated) {
					world.generateQueue.push(chunk);
					done = false;
				}
				if (!chunk.populated && i >= x - 1 && i <= x + 1 && j >= z - 1 && j <= z + 1) {
					world.populateQueue.push(chunk);
					done = false;
				}
			}
		}
		return done;
	}
	function maxDist(x, z, x2, z2) {
		let ax = Math.abs(x2 - x);
		let az = Math.abs(z2 - z);
		return Math.max(ax, az);
	}
	function renderFilter(chunk) {
		return maxDist(chunk.x >> 4, chunk.z >> 4, p.cx, p.cz) <= renderDistance;
	}

	function debug(message) {
		let ellapsed = performance.now() - debug.start;
		if (ellapsed > 30) {
			console.log(message, ellapsed.toFixed(2), "milliseconds");
		}
	}
	/** World Class **/
	//{
	let genChunk = function(chunk) {
		let x = chunk.x >> 4;
		let z = chunk.z >> 4;
		let trueX = chunk.x;
		let trueZ = chunk.z;

		if (chunk.generated) {
			return false;
		}
		let hide = !loadString;
		let smoothness = generator.smooth;
		let hilliness = generator.height;
		let gen = 0;
		for (let i = 0; i < 16; i++) {
			for (let k = 0; k < 16; k++) {
				gen = superflat ? 4 : Math.round(noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra;
				chunk.tops[k * 16 + i] = gen;

				chunk.setBlock(i, gen, k, blockIds.grass);
				chunk.setBlock(i, gen - 1, k, blockIds.dirt);
				chunk.setBlock(i, gen - 2, k, blockIds.dirt);
				chunk.setBlock(i, gen - 3, k, blockIds.dirt);
				for (let j = 1; j < gen - 3; j++) {
					chunk.setBlock(i, j, k, blockIds.stone);
				}
				chunk.setBlock(i, 0, k, blockIds.bedrock);
			}
		}
		chunk.generated = true;
		generatedChunks++;
	};
	let getAdjacentSubchunks = function(x, y, z) {
		let minChunkX = x - 16 >> 4;
		let maxChunkX = x + 16 >> 4;
		let minChunkY = y - 16 >> 4;
		let maxChunkY = y + 16 >> 4;
		let minChunkZ = z - 16 >> 4;
		let maxChunkZ = z + 16 >> 4;
		let ret = [];
		for (x = minChunkX; x <= maxChunkX; x++) {
			for (let y = minChunkY; y <= maxChunkY; y++) {
				for (z = minChunkZ; z <= maxChunkZ; z++) {
					if (y < 0) {
						ret.push(fullSection.blocks);
					} else if (this.chunks[x] && this.chunks[x][z]) {
						ret.push((this.chunks[x][z].sections[y] || emptySection).blocks);
					} else {
						ret.push(emptySection.blocks);
					}
				}
			}
		}
		return ret;
	};
	let updateBlock = function(x, y, z, lazy) {
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4];
		if (chunk && chunk.buffer) {
			chunk.updateBlock(x & 15, y, z & 15, this, lazy);
		}
	};
	let getWorldBlock = function(x, y, z) {
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return blockIds.air;
		}
		return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15);
	};
	let getLoadedBlock = function(x, y, z) {
		let X = (x >> 4) + this.offsetX;
		let Z = (z >> 4) + this.offsetZ;
		if (y > maxHeight) {
			return blockIds.air;
		} else if (y < 0) {
			return blockIds.bedrock;
		} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
			return this.getWorldBlock(x, y, z);
		}
		return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15);
	};
	let setBlock = function(x, y, z, blockID, lazy) {
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return;
		}
		let chunk = this.chunks[x >> 4][z >> 4];

		let xm = x & 15;
		let zm = z & 15;
		if (blockID) {
			chunk.setBlock(xm, y, zm, blockID, false, !lazy);
		} else {
			chunk.deleteBlock(xm, y, zm, !lazy);
		}



		//Update the 6 adjacent blocks and 1 changed block
		if (xm && xm !== 15 && zm && zm !== 15) {
			chunk.updateBlock(xm - 1, y, zm, this, lazy);
			chunk.updateBlock(xm + 1, y, zm, this, lazy);
			chunk.updateBlock(xm, y - 1, zm, this, lazy);
			chunk.updateBlock(xm, y + 1, zm, this, lazy);
			chunk.updateBlock(xm, y, zm - 1, this, lazy);
			chunk.updateBlock(xm, y, zm + 1, this, lazy);
		}
		else {
			this.updateBlock(x - 1, y, z, lazy);
			this.updateBlock(x + 1, y, z, lazy);
			this.updateBlock(x, y - 1, z, lazy);
			this.updateBlock(x, y + 1, z, lazy);
			this.updateBlock(x, y, z - 1, lazy);
			this.updateBlock(x, y, z + 1, lazy);
		}

		chunk.updateBlock(xm, y, zm, this, lazy);

		//Update the corner chunks so shadows in adjacent chunks update correctly
		if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy); }
		if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy); }
		if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy); }
		if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy); }
	};
	let spawnBlock = function(x, y, z, blockID) {
		//Sets a block anywhere without causing block updates around it. Only to be used in world gen.

		let chunkX = x >> 4;
		let chunkZ = z >> 4;
		if (!this.chunks[chunkX]) {
			this.chunks[chunkX] = [];
		}
		let chunk = this.chunks[chunkX][chunkZ];
		if (!chunk) {
			chunk = newChunk(chunkX * 16, chunkZ * 16);
			this.chunks[chunkX][chunkZ] = chunk;
		}
		if (chunk.buffer) {
			//Only used if spawning a block post-gen
			this.setBlock(x, y, z, blockID, true);
		} else if (!chunk.getBlock(x & 15, y, z & 15)) {
			chunk.setBlock(x & 15, y, z & 15, blockID, false);
		}
	};
	let tick = function() {
		let tickStart = win.performance.now();
		let maxChunkX = (p.x >> 4) + renderDistance;
		let maxChunkZ = (p.z >> 4) + renderDistance;
		let chunk = maxChunkX + "," + maxChunkZ;
		if (chunk !== this.lastChunk) {
			this.lastChunk = chunk;
			this.loadChunks();
			this.chunkGenQueue.sort(sortChunks);
		}

		if (Key.leftMouse && !Key.control && p.lastBreak < Date.now() - 250) {
			changeWorldBlock(0);
		}
		if ((Key.rightMouse || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250) {
			newWorldBlock();
		}
		if (Key.leftMouse && p.autoBreak && !Key.control) {
			changeWorldBlock(0);
		}

		for (let i = 0; i < this.sortedChunks.length; i++) {
			this.sortedChunks[i].tick();
		}

		do {
			let doneWork = false;
			debug.start = performance.now();
			if (this.meshQueue.length) {
				// Update all chunk meshes.
				let len = this.meshQueue.length - 1;
				do {
					this.meshQueue.pop().genMesh();
				} while(this.meshQueue.length);
				doneWork = true;
				debug("Meshes")
			}

			if (this.generateQueue.length && !doneWork) {
				let chunk = this.generateQueue.pop()
				this.genChunk(chunk);
				doneWork = true;
			}
			if (this.populateQueue.length && !doneWork) {
				let chunk = this.populateQueue[this.populateQueue.length - 1]
				if (!chunk.caves) {
					chunk.carveCaves();
					debug("Carve caves")
				} else if (!chunk.populated) {
					chunk.populate();
					this.populateQueue.pop();
				}
				doneWork = true;
			}

			if (this.chunkGenQueue.length && !doneWork) {
				let chunk = this.chunkGenQueue[0];
				if (!fillReqs(chunk.x >> 4, chunk.z >> 4)) {}
				else if (!chunk.optimized) {
					chunk.load();
					chunk.optimize(this);
					debug("Optimize")
				} else if (!chunk.buffer) {
					chunk.genMesh();
					debug("Initial mesh")
				} else {
					this.chunkGenQueue.shift();
				}
				doneWork = true;
			}
			if (!doneWork) {
				break;
			}
		} while(win.performance.now() - tickStart < 5);
	};
	let render = function() {
		initModelView(p.x, p.y, p.z, p.rx, p.ry);
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

		p2.x = Math.round(p.x);
		p2.y = Math.round(p.y);
		p2.z = Math.round(p.z);

		renderedChunks = 0;
		gl.enableVertexAttribArray(glCache.locations.aShadow);

		let c = this.sortedChunks;
		let lx = p.direction.x;
		let ly = p.direction.y;
		let lz = p.direction.z;
		let nlx = lx < 0 ? 0 : 16;
		let nly = ly < 0;
		let nlz = lz < 0 ? 0 : 16;
		let x = p.x;
		let y = p.y;
		let z = p.z;
		let dx = 0, dy = 0, dz = 0;
		let chunk = null;
		for (let i = 0, l = c.length; i < l; i++) {
			chunk = c[i];
			dx = chunk.x - x + nlx;
			dy = (nly ? chunk.minY : chunk.maxY) - y;
			dz = chunk.z - z + nlz;
			if (dx * lx + dy * ly + dz * lz > 0) {
				chunk.render();
			}
		}

		if(hitBox.pos) {
			blockOutlines = true;
			blockFill = false;
			block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0);
			blockOutlines = false;
			blockFill = true;
		}
		gl.flush();
	};
	let loadChunks = function() {
		renderDistance += 2;
		let cx = p.x >> 4;
		let cz = p.z >> 4;
		p.cx = cx;
		p.cz = cz;
		let minChunkX = cx - renderDistance;
		let maxChunkX = cx + renderDistance;
		let minChunkZ = cz - renderDistance;
		let maxChunkZ = cz + renderDistance;

		this.offsetX = -minChunkX;
		this.offsetZ = -minChunkZ;
		this.lwidth = renderDistance * 2 + 1;
		this.chunkGenQueue.length = 0;
		renderDistance -= 2;

		if (this.loaded.length > this.lwidth * this.lwidth) {
			this.loaded.length = this.lwidth * this.lwidth;
		}

		let i = 0;
		for (let x = minChunkX; x <= maxChunkX; x++) {
			for (let z = minChunkZ; z <= maxChunkZ; z++) {
				let chunk;
				if (!this.chunks[x]) {
					this.chunks[x] = [];
				}
				if (!this.chunks[x][z]) {
					chunk = newChunk(x * 16, z * 16);
					if (maxDist(cx, cz, x, z) <= renderDistance) {
						this.chunkGenQueue.push(chunk);
					}
					this.chunks[x][z] = chunk;
				}
				chunk = this.chunks[x][z];
				if (!chunk.buffer && !this.chunkGenQueue.includes(chunk) && maxDist(cx, cz, x, z) <= renderDistance) {
					this.chunkGenQueue.push(chunk);
				}
				this.loaded[i++] = chunk;
			}
		}
		this.sortedChunks = this.loaded.filter(renderFilter);
		this.sortedChunks.sort(sortChunks);
	};
	function getSaveString() {
		let edited = [];
		for (let x in this.chunks) {
			for (let z in this.chunks[x]) {
				let chunk = this.chunks[x][z];
				if (chunk.edited) {
					for (let y = 0; y < chunk.sections.length; y++) {
						if (chunk.sections[y].edited) {
							edited.push([ chunk.sections[y], chunk.cleanSections[y] ]);
						}
					}
				}
			}
		}

		let str = worldSeed.toString(36) + ";"
			+ Math.round(p.x).toString(36) + "," + Math.round(p.y).toString(36) + "," + Math.round(p.z).toString(36) + ","
			+ (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + ";"
			+ edited.length.toString(36) + ";";
		for (let i = 0; i < edited.length; i++) {
			let sc = edited[i][0];
			str += (sc.x / 16).toString(36) + ",";
			str += (sc.y / 16).toString(36) + ",";
			str += (sc.z / 16).toString(36) + ",";
		}
		if (edited.length) str = str.substr(0, str.length - 1); //Remove trailing comma
		str += ";";

		for (let i = 0; i < edited.length; i++) {
			let real = edited[i][0];
			let blocks = real.blocks;
			let original = edited[i][1];
			let hasBlocks = false;
			for (let j = 0; j < original.length; j++) {
				if ((blocks[j] & 0xff) !== (original[j] & 0xff)) {
					str += (j << 8 | blocks[j] & 0xff).toString(36) + ",";
					hasBlocks = true;
				}
			}
			if (hasBlocks) str = str.substr(0, str.length - 1); //Remove trailing comma
			str += ";";
		}
		str = str.substr(0, str.length - 1);
		return str;
	}
	function loadSave(str) {
		let data = str.split(";");
		worldSeed = parseInt(data.shift(), 36);
		seedHash(worldSeed);
		caveNoise = openSimplexNoise(worldSeed);
		noiseSeed(worldSeed);
		let playerData = data.shift().split(",");
		p.x = parseInt(playerData[0], 36);
		p.y = parseInt(playerData[1], 36);
		p.z = parseInt(playerData[2], 36);
		p.rx = parseInt(playerData[3], 36) / 100;
		p.ry = parseInt(playerData[4], 36) / 100;
		let editCount = parseInt(data.shift(), 36);

		this.loadFrom = [];

		let coords = data.shift().split(",").map(function(n) {
			return parseInt(n, 36);
		});
		for (let j = 0; j < coords.length; j += 3) {
			this.loadFrom.push({
				x: coords[j],
				y: coords[j + 1],
				z: coords[j + 2],
				blocks: [],
			})
		}

		for (let i = 0; data.length > 0; i++) {
			let blocks = data.shift().split(",");
			for (let j = 0; j < blocks.length; j++) {
				let block = parseInt(blocks[j], 36);
				let index = block >> 8;
				let id = block & 0xff;
				this.loadFrom[i].blocks[index] = id;
			}
		}
	}
	//}
	function World() {
		generatedChunks = 0;

		//Initialize the world's arrays
		return {
			chunks: [],
			loaded: [],
			sortedChunks: [],
			offsetX: 0,
			offsetZ: 0,
			lwidth: 0,
			chunkGenQueue: [],
			populateQueue: [],
			generateQueue: [],
			meshQueue: [],
			loadFrom: [],
			lastChunk: ",",
			genChunk: genChunk,
			getAdjacentSubchunks: getAdjacentSubchunks,
			updateBlock: updateBlock,
			getBlock: getLoadedBlock,
			getWorldBlock: getWorldBlock,
			setBlock: setBlock,
			spawnBlock: spawnBlock,
			tick: tick,
			render: render,
			loadChunks: loadChunks,
			getSaveString: getSaveString,
			loadSave: loadSave,
		};
	}

	let defineWorld = function() {
		let tickStart = win.performance.now();
		world.tick();
		analytics.totalTickTime += win.performance.now() - tickStart;
		let renderStart = win.performance.now();
		world.render();
		analytics.totalRenderTime += win.performance.now() - renderStart;
	};

	let controls = function() {
		move.x = 0;
		move.z = 0;
		let dt = (win.performance.now() - p.lastUpdate) / 33;
		dt = dt > 2 ? 2 : dt;
		if(Key.w) {
			move.z += p.speed;
		}
		if(Key.s) {
			move.z -= p.speed;
		}
		if(Key.a) {
			move.x += p.speed;
		}
		if(Key.d) {
			move.x -= p.speed;
		}
		if (p.flying) {
			if(Key[" "]) {
				p.velocity.y += 0.06 * dt;
			}
			if(Key.shift) {
				p.velocity.y -= 0.06 * dt;
			}
		}
		if(Key.arrowleft) {
			p.ry -= 0.1 * dt;
		}
		if(Key.arrowright) {
			p.ry += 0.1 * dt;
		}
		if(Key.arrowup) {
			p.rx += 0.1 * dt;
		}
		if(Key.arrowdown) {
			p.rx -= 0.1 * dt;
		}

		if (Key.q && !p.sneaking) {
			p.sprinting = true;
		}

		if(p.sprinting) {
			move.x *= p.sprintSpeed;
			move.z *= p.sprintSpeed;
		}
		if(p.flying) {
			move.x *= p.flySpeed;
			move.z *= p.flySpeed;
		}
		if (!move.x && !move.z) {
			p.sprinting = false;
		} else if(Math.abs(move.x) > 0 && Math.abs(move.z) > 0) {
			move.x *= move.ang;
			move.z *= move.ang;
		}
		//Update the velocity, rather than the position.
		let co = Math.cos(p.ry);
		let si = Math.sin(p.ry);
		let friction = p.onGround ? 1 : 0.3;
		p.velocity.x += (co * move.x - si * move.z) * friction * dt;
		p.velocity.z += (si * move.x + co * move.z) * friction * dt;

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2;
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2;
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2;
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2;
		}

		p.direction.set(-si * Math.cos(p.rx), Math.sin(p.rx), co * Math.cos(p.rx));
		computeFrustum();
	};

	//Disable scroll
	(function() {
		let preventDefault = function(e) {
			e.preventDefault();
			if (e.deltaY > 0) {
				inventory.hotbarSlot++;
			} else if (e.deltaY < 0) {
				inventory.hotbarSlot--;
			}
			if (inventory.hotbarSlot > 8) {
				inventory.hotbarSlot = 0;
			} else if (inventory.hotbarSlot < 0) {
				inventory.hotbarSlot = 8;
			}

			updateHUD = true;
			holding = inventory.hotbar[inventory.hotbarSlot];
		};

		let keys = { 32: 1, 37: 1, 38: 1, 39: 1, 40: 1 };

		function preventDefaultForScrollKeys(e) {
			if (keys[e.keyCode]) {
				e.preventDefault();
				return false;
			}
		}

		// modern Chrome requires { passive: false } when adding event
		let supportsPassive = false;
		try {
			window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
				get: function () {
					supportsPassive = true;
				},
			}));
		} catch(e) {}

		let wheelOpt = supportsPassive ? { passive: false } : false;
		let wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';

		// call this to Disable
		function disableScroll() {
			window.addEventListener('DOMMouseScroll', preventDefault, false); // older FF
			window.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
			window.addEventListener('touchmove', preventDefault, wheelOpt); // mobile
			window.addEventListener('keydown', preventDefaultForScrollKeys, false);
		}

		disableScroll();
	})();

	// Mouse sensitivity variable, used for the settings buttons and in the "mmoved" function
	let mouseS = 300;

	let buttons = [];
	let button = function(x, y, w, h) {
		if(mouseX > x && mouseY > y && mouseX < x + w && mouseY < y + h) {
			return true;
		} else {
			return false;
		}
	};
	let addButton = function(x, y, w, h, text, callback, screen) {
		w = Math.max(w, 300);
		buttons.push({
			x: width / 2 - w / 2,
			y: y,
			w: w,
			h: h,
			text: text,
			callback: callback,
			screen: screen,
		});
	};
	let clickButton = function(button) {
		if (screen === button.screen && mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
			button.callback();
		}
	};

	let drawButton = function(button) {
		if (screen === button.screen) {
			if (mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
				strokeWeight(7);
			} else {
				strokeWeight(3);
			}
			ctx.strokeStyle = "rgb(30, 30, 30)";
			ctx.fillStyle = "rgb(120, 120, 120)";
			ctx.rect(button.x, button.y, button.w, button.h);
			ctx.stroke();
			ctx.fill();
			ctx.beginPath();
			ctx.textAlign = 'center';
			ctx.fillStyle = "rgb(80, 80, 80)";
			ctx.font = "35.5px VT323";
			ctx.fillText(button.text, button.x + button.w / 2, button.y + button.h / 1.7 + 8);
			ctx.fillStyle = "rgb(220, 220, 220)";
			ctx.font = "35px VT323";
			ctx.fillText(button.text, button.x + button.w / 2, button.y + button.h / 2 + 10);
		}
	};

	var initEverything;
	//General buttons
	{
		addButton(width / 2 - 280, height / 2 - 45, width / 2.5, 50, "Singleplayer", function() {
			screen = "creation menu";
		}, "main menu");
		addButton(width / 2 - 150, height / 2 + 100, width / 5, 40, "Create New World", function() {
			world = World();
			win.world = world;
			world.loadChunks();
			world.chunkGenQueue.sort(sortChunks);
			play();
		}, "creation menu");
		addButton(width / 2 - 150, height / 2 + 150, width / 5, 40, "Load Saved World", function() {
			if (loadString) {
				savebox.value = loadString;
			}
			savebox.hidden = false;
			screen = "loadsave menu";
		}, "creation menu");
		addButton(width / 2 - 280, height / 2 + 25, width / 2.5, 50, "Load Save", function() {
			world = World();
			win.world = world;
			if (savebox.value) {
				try {
					world.loadSave(savebox.value);
				} catch(e) {
					alert("Something went wrong!");
					return;
				}
			}
			world.loadChunks();
			world.chunkGenQueue.sort(sortChunks);
			play();
		}, "loadsave menu");
		addButton(width / 2 - 180, height / 2 - 100, width / 4, 40, "World Type: Normal", function() {
			superflat = !superflat;
			if (superflat) {
				this.text = "World type: Superflat";
			} else {
				this.text = "World type: Normal";
			}
		}, "creation menu");
		addButton(width / 2 - 180, height / 2 - 50, width / 4, 40, "Game Mode: Creative", function(){
			// change gamemode
			screen = "comingsoon menu";
		}, "creation menu");
		addButton(width / 2 - 180, height / 2, width / 4, 40, "Difficulty: Peaceful", function() {
			// change difficulty
			screen = "comingsoon menu";
		}, "creation menu");
		addButton(width / 2 - 150, height / 2 + 200, width / 5, 40, "Cancel", function() {
			screen = "main menu";
		}, "creation menu");
		addButton(width / 2 - 280, height / 2 + 25, width / 2.5, 50, "Multiplayer", function() {
			screen = "rickrolled menu"
		}, "main menu");
		addButton(width / 2 - 280, height / 2 + 95, width / 2.5, 50, "Options", function() {
			screen = "options menu";
		}, "main menu");
		addButton(width / 2 - 220, 225, width / 3, 50, "Resume", function() {
			play();
		}, "pause");
		addButton(width / 2 - 220, 295, width / 3, 50, "Options", function() {
			screen = "pause options";
		}, "pause");
		addButton(width / 2 - 220, 365, width / 3, 50, "Get Save Code", function() {
			if (savebox.hidden) {
				savebox.hidden = false;
				saveDirections.hidden = false;
				savebox.value = world.getSaveString();
			} else {
				savebox.hidden = true;
				saveDirections.hidden = true;
			}
		}, "pause");
		addButton(width / 2 - 220, 435, width / 3, 50, "Exit Without Saving", function() {
			savebox.hidden = true;
			saveDirections.hidden = true;
			message.hidden = true;
			savebox.value = world.getSaveString();
			screen = "main menu";
		}, "pause");
		addButton(width / 2 - 220, 455, width / 3, 50, "Back", function() {
			screen = "main menu";
		}, "options menu");
		addButton(width / 2 - 220, 455, width / 3, 50, "Back", function() {
			screen = "pause";
		}, "pause options");
		addButton(width / 2 - 220, 395, width / 3, 50, "Back", function() {
			screen = "creation menu";
		}, "comingsoon menu");
		addButton(width / 2 - 220, 395, width / 3, 50, "\\_()_/", function() {
			screen = "main menu";
		}, "rickrolled menu");


		let settingsState = true;
		let mouseSense = 100;

		// Menu Settings
		addButton(width / 2 - 220, 155, width / 3, 50, "State: Increase", function() {
			settingsState = !settingsState;
			this.text = "State: " + (settingsState ? "Increase" : "Decrease");
		}, "options menu");
		addButton(width / 2 - 220, 245, width / 3, 50, "Render Distance: " + renderDistance + " chunks", function() {
			if(settingsState) {
				renderDistance++;
			} else if (renderDistance > 1) {
				renderDistance--;
			}
			this.text = "Render Distance: " + renderDistance + " chunks";
		}, "options menu");
		addButton(width / 2 - 220, 305, width / 3, 50, "FOV: " + fov, function() {
			if(settingsState && fov < 110) {
				fov += 5;
			} else if (!settingsState && fov > 30) {
				fov -= 5;
			}
			FOV(fov);
			this.text = "FOV: " + fov
		}, "options menu");
		addButton(width / 2 - 220, 365, width / 3, 50, "Mouse Sensitivity: " + mouseSense, function() {
			if(settingsState) {
				mouseSense += 10;
			} else if (mouseSense > 30) {
				mouseSense -= 10;
			}
			mouseS = 30000 / mouseSense;
			this.text = "Mouse Sensitivity: " + mouseSense;
		}, "options menu");

		// In-Game Settings
		addButton(width / 2 - 220, 155, width / 3, 50, "State: Increase", function() {
			settingsState = !settingsState;
			this.text = "State: " + (settingsState ? "Increase" : "Decrease");
		}, "pause options");
		addButton(width / 2 - 220, 245, width / 3, 50, "Render Distance: " + renderDistance + " chunks", function() {
			if(settingsState) {
				renderDistance++;
			} else if (renderDistance > 1) {
				renderDistance--;
			}
			this.text = "Render Distance: " + renderDistance + " chunks";
		}, "pause options");
		addButton(width / 2 - 220, 305, width / 3, 50, "FOV: " + fov, function() {
			if(settingsState && fov < 110) {
				fov += 5;
			} else if (!settingsState && fov > 30) {
				fov -= 5;
			}
			FOV(fov);
			this.text = "FOV: " + fov
			world.render();
		}, "pause options");
		addButton(width / 2 - 220, 365, width / 3, 50, "Mouse Sensitivity: " + mouseSense, function() {
			if(settingsState) {
				mouseSense += 10;
			} else if (mouseSense > 30) {
				mouseSense -= 10;
			}
			mouseS = 30000 / mouseSense;
			this.text = "Mouse Sensitivity: " + mouseSense;
		}, "pause options");
	}

	function initTextures() {
		let textureSize = 256;
		let texturePixels = newUint8Array(textureSize * textureSize * 4);
		textureMap = {};
		textureCoords = [];

		setPixel = function(textureNum, x, y, r, g, b, a) {
			let texX = textureNum & 15;
			let texY = textureNum >> 4;
			let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4;
			texturePixels[offset] = r;
			texturePixels[offset + 1] = g;
			texturePixels[offset + 2] = b;
			texturePixels[offset + 3] = a !== undefined ? a : 255;
		};
		getPixels = function(str) {
			// var w = parseInt(str.substr(0, 2), 36);
			// var h = parseInt(str.substr(2, 2), 36);
			var colors = [];
			var pixels = [];
			var dCount = 0;
			for (;str[4+dCount]==="0";dCount++) {}
			var ccount = parseInt(str.substr(4+dCount, dCount+1), 36);
			for (var i = 0; i < ccount; i++) {
				var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36);
				colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ]);
			}
			for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
				let num = parseInt(str[i], 36);
				pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3]);
			}
			return pixels;
		};


		(function() {
		//Specify the texture coords for each index
			for (let i = 0; i < 256; i++) {
				let texX = i & 15;
				let texY = i >> 4;
				let offsetX = texX * 0.0625;
				let offsetY = texY * 0.0625;
				textureCoords.push(newFloat32Array([ 0.0625 + offsetX, offsetY, offsetX, offsetY, offsetX, 0.0625 + offsetY, 0.0625 + offsetX, 0.0625 + offsetY ]));
			}

			//Set all of the textures into 1 big tiled texture
			let n = 0;
			for (let i in textures) {
				if (typeof textures[i] === "function") {
					textures[i](n);
				} else if (typeof textures[i] === "string") {
					let pix = getPixels(textures[i]);
					for (let j = 0; j < pix.length; j += 4) {
						setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3]);
					}
				}
				textureMap[i] = n;
				n++;
			}

			//Set the hitbox texture to 1 pixel
			let arr = newFloat32Array(192)
			for (let i = 0; i < 192; i += 2) {
				arr[i] = textureCoords[textureMap.hitbox][2] + 0.01;
				arr[i + 1] = textureCoords[textureMap.hitbox][1] + 0.01;
			}
			textureCoords[textureMap.hitbox] = arr;
		})();

		tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.activeTexture(gl.TEXTURE0);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.uniform1i(glCache.locations.uSampler, 0);

		genIcons();
	}
	function drawIcon(x, y, id) {
		if (blockMode === SLAB) {
			id |= 128;
		}
		x =  x / (3 * height) - 0.1666 * width / height;
		y = y / (3 * height) - 0.1666;
		initModelView(x, y, 0, 0, 0);

		let buffer = blockIcons[id];
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
		gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
		gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
		gl.drawElements(gl.TRIANGLES, 6 * 3, gl.UNSIGNED_INT, 0);
	}

	function hotbar() {
		let before = currentFov;
		FOV(90);

		for(let i = 0; i < inventory.hotbar.length; i ++) {
			if(inventory.hotbar[i]) {
				let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25;
				let y = height - inventory.size;
				drawIcon(x, y, inventory.hotbar[i]);
			}
		}

		FOV(before);
	}
	function hud() {
		let s = inventory.size;
		let x = width / 2 + 0.5;
		let y = height / 2 + 0.5;

		// Crosshair
		if (!p.spectator) {
			ctx.lineWidth = 1;
			ctx.strokeStyle = "white";
			ctx.beginPath();
			ctx.moveTo(x - 10, y);
			ctx.lineTo(x + 10, y);
			ctx.moveTo(x, y - 10);
			ctx.lineTo(x, y + 10);
			ctx.stroke();
		}

		//Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25;
		y = height - s * 1.5 + 0.5;

		ctx.strokeStyle = "black";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x + s * 9, y);
		ctx.moveTo(x, y + s);
		ctx.lineTo(x + s * 9, y + s);
		for(let i = 0; i <= 9; i++) {
			ctx.moveTo(x + i * s, y);
			ctx.lineTo(x + i * s, y + s);
		}
		ctx.stroke();

		ctx.strokeStyle = "white";
		ctx.lineWidth = 2;
		ctx.beginPath();

		ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s);

		let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
		+ "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
		+ "Render Time: " + analytics.displayedRenderTime + "ms\n"
		+ "Tick Time: " + analytics.displayedTickTime + "ms\n"
		+ "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
		+ "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
		+ "FPS: " + analytics.fps;

		if (p.autoBreak) {
			fastText("Super breaker enabled", 5, height - 89, 12);
		}

		ctx.textAlign = 'right';
		fastText(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0);
		ctx.textAlign = 'left';
		fastText(str, 5, height - 77, 12);
	}
	function drawInv() {
		let x = 0;
		let y = 0;
		let s = inventory.size;
		let s2 = s / 2;
		let before = currentFov;
		let perRow = 13;

		//I don't know why, but this is barely transparent, so the gray bleeds through
		gl.clearColor(0.5, 0.5, 0.5, 0.0);
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
		ctx.fillStyle = "rgb(127, 127, 127)";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		FOV(90);

		// Draw the grid
		ctx.lineWidth = 1;
		ctx.strokeStyle = "black";
		ctx.beginPath();
		for (y = 0; y < 10; y++) {
			ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s);
			ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s);
		}
		y--;
		for (x = 0; x < perRow + 1; x++) {
			ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2);
			ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s);
		}

		// Hotbar
		x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25;
		y = height - s * 1.5 + 0.5;
		ctx.moveTo(x, y);
		ctx.lineTo(x + s * 9, y);
		ctx.moveTo(x, y + s);
		ctx.lineTo(x + s * 9, y + s);
		for(let i = 0; i <= inventory.hotbar.length; i ++) {
			ctx.moveTo(x + i * s, y);
			ctx.lineTo(x + i * s, y + s);
		}
		ctx.stroke();

		let overHot = (mouseX - x) / s | 0;
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			x += s * overHot;
			ctx.lineWidth = 2;
			ctx.strokeStyle = "white";
			ctx.beginPath();
			ctx.strokeRect(x, y, s, s);
		}

		//Box highlight in inv
		let overInv = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
		if (overInv >= 0 && overInv < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow * s + 50 - s2;
			y = (overInv / perRow | 0) * s + 50 - s2;
			ctx.lineWidth = 2;
			ctx.strokeStyle = "white";
			ctx.beginPath();
			ctx.strokeRect(x, y, s, s);
		}

		if (inventory.holding) {
			drawIcon(mouseX, mouseY, inventory.holding);
		}
		for (let i = 1; i < blockData.length; i++) {
			x = (i - 1) % perRow * s + 50;
			y = ((i - 1) / perRow | 0) * s + 50;
			drawIcon(x, y, i);
		}

		hotbar();
		//hud();
		ctx.drawImage(gl.canvas, 0, 0);

		FOV(before);
	}
	function clickInv() {
		let s = inventory.size;
		let s2 = s / 2;
		let perRow = 13;
		let over = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
		let x = width / 2 - 9 / 2 * s + 25;
		let y = height - s * 1.5;
		let overHot = (mouseX - x) / s | 0;
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			let temp = inventory.hotbar[overHot];
			inventory.hotbar[overHot] = inventory.holding;
			inventory.holding = temp;
		} else if (over >= 0 && over < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			inventory.holding = over + 1;
		} else {
			inventory.holding = 0;
		}
	}

	let unpauseDelay = 0;
	function mmoved(e) {
		p.rx -= e.movementY / mouseS;
		p.ry += e.movementX / mouseS;

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2;
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2;
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2;
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2;
		}
	}
	function trackMouse(e) {
		mouseX = e.x;
		mouseY = e.y;
	}
	document.onmousemove = trackMouse;
	document.onpointerlockchange = function() {
		if (doc.pointerLockElement === canvas) {
			doc.onmousemove = mmoved;
		} else {
			doc.onmousemove = trackMouse;
			if (screen === "play" && !freezeFrame) {
				screen = "pause";
				message.hidden = false;
				unpauseDelay = Date.now() + 1000;
			}
		}
		for (let key in Key) {
			Key[key] = false;
		}
	};
	canvas.onmousedown = function(e) {
		mouseX = e.x;
		mouseY = e.y;
		switch(e.button) {
			case 0:
				Key.leftMouse = true;
				break;
			case 1:
				Key.middleMouse = true;
				updateHUD = true;
				inventory.hotbar[inventory.hotbarSlot] = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]);
				break;
			case 2:
				Key.rightMouse = true;
				break;
		}
		if(screen === "play") {
			if (doc.pointerLockElement !== canvas) {
				getPointer();
				p.lastBreak = Date.now();
			} else {
				place = false;
				if(e.button === 0) {
					if(Key.control) {
						place = true;
					} else {
						changeWorldBlock(0);
					}
				}
				holding = inventory.hotbar[inventory.hotbarSlot];
				if(e.button === 2 && holding) {
					place = true;
				}
				if(place) {
					newWorldBlock();
				}
			}
		} else if (screen === "inventory") {
			clickInv();
		}

		let currentScreen = screen;
		for (let i = 0; i < buttons.length; i++) {
			if (buttons[i].screen === currentScreen) {
				clickButton(buttons[i]);
			}
		}
	};
	canvas.onmouseup = function(e) {
		switch(e.button) {
			case 0:
				Key.leftMouse = false;
				break;
			case 1:
				Key.middleMouse = false;
				break;
			case 2:
				Key.rightMouse = false;
				break;
		}
	};
	document.onkeydown = function(e) {
		if (e.repeat || Key[e.key.toLowerCase()]) {
			return;
		}
		let k = e.key.toLowerCase();
		Key[k] = true;
		if (k === "delete") {
			initEverything();
			releasePointer();
		}

		if (k === "t") {
			initTextures();
		}

		if (k === "enter") {
			blockMode ^= 1;
			updateHUD = true;
		}

		if (screen === "play") {
			if(k === "p") {
				releasePointer();
				screen = "pause";
				message.hidden = false;
			}

			if(k === "b") {
				p.autoBreak = !p.autoBreak;
				updateHUD = true;
			}

			if (k === " " && !p.spectator) {
				if (Date.now() < p.lastJump + 400) {
					p.flying ^= true;
				} else {
					p.lastJump = Date.now();
				}
			}

			if (k === "z") {
				FOV(10);
			}

			if (k === "x") { //Quake Pro lol
				FOV(110);
			}

			if (k === "shift" && !p.flying) {
				p.sneaking = true;
				p.sprinting = false;
				p.speed = 0.03;
				p.bottomH = 1.32;
			}

			if (k === "l") {
				p.spectator = !p.spectator;
				p.flying = true;
				p.onGround = false;
				updateHUD = true;
			}

			if (k === "e") {
				screen = "inventory";
				releasePointer();
			}

			if (k === ";") {
				releasePointer();
				freezeFrame = true;
			}

			if(Number(k)) {
				inventory.hotbarSlot = Number(k) - 1;
				holding = inventory.hotbar[inventory.hotbarSlot];
				updateHUD = true;
			}
		} else if (screen === "pause") {
			if(k === "p") {
				play();
			}
		} else if (screen === "inventory") {
			if (k === "e") {
				play();
			}
		}

	};
	document.onkeyup = function(e) {
		let k = e.key.toLowerCase();
		Key[k] = false;
		if(k === "escape" && (screen.includes("pause") || screen === "inventory") && Date.now() > unpauseDelay) {
			play();
		}
		if (screen === "play") {
			if (k === "z") {
				FOV(fov);
			}

			if (k === "shift" && p.sneaking) {
				p.sneaking = false;
				p.speed = 0.075;
				p.bottomH = 1.62;
				// p.y += 0.3;
			}
		}
	};
	canvas.onblur = function() {
		for (let key in Key) {
			Key[key] = false;

		}
	}
	canvas.oncontextmenu = function(e) {
		e.preventDefault();
	}

	function initEverything() {
		console.log("Initializing world.");

		worldSeed = Math.random() * 2000000000 | 0;

		seedHash(worldSeed);
		caveNoise = openSimplexNoise(worldSeed);
		noiseSeed(worldSeed);

		generatedChunks = 0;

		screen = "main menu";
		p = {
			speed: 0.075,
			velocity: new PVector(0, 0, 0),
			direction: new PVector(0, 0, 0),
			sprintSpeed: 1.5,
			flySpeed: 2.5,
			x: 8,
			y: superflat ? 6 : (Math.round(noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra),
			z: 8,
			previousX: 8,
			previousY: 70,
			previousZ: 8,
			w: 3 / 8,
			bottomH: 1.62,
			topH: 0.18,
			rx: Math.random() / 2,
			ry: random(7),
			onGround: false,
			jumpSpeed: 0.3,
			sprinting: false,
			maxYVelocity: 1.5,
			gravityStength: -0.032,
			lastUpdate: win.performance.now(),
			lastBreak: Date.now(),
			lastPlace: Date.now(),
			lastJump: Date.now(),
			autoBreak: false,
			flying: false,
			sneaking: false,
			spectator: false,
			frustum: [],
		};
		for (let i = 0; i < 4; i++) {
			p.frustum[i] = new Plane();
		}
		
		win.player = p;
		win.p2 = p2;

		if (!win.gl) {
			let canv = document.createElement('canvas');
			canv.width = ctx.canvas.width;
			canv.height = ctx.canvas.height;
			canv.style.position = "absolute";
			canv.style.zIndex = -1;
			canv.style.top = "0px";
			canv.style.left = "0px";
			// var ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'];
			// for (var i=0, l=ctxNames.length; i<l; i++) {
			//	 gl = canv.getContext(ctxNames[i], {antialias: false});
			//	 if (gl) {
			//		 break;
			//	 }
			// }
			gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false });
			let ext = gl.getExtension('OES_element_index_uint');
			if (!ext) {
				alert("Please use a supported browser, or update your current browser.")
			}
			gl.viewport(0, 0, canv.width, canv.height);
			gl.enable(gl.DEPTH_TEST);
			gl.enable(gl.BLEND);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			win.gl = gl;
		} else {
			gl = win.gl;
		}

		if (!document.body.contains(gl.canvas)) {
			document.body.append(gl.canvas);
		}

		if (win.location.origin === "https://www.kasandbox.org" && window.parent.document.referrer.split("?")[0].split("/").pop() !== "5647155001376768") {
			// Prevent Ctrl F
			message.innerHTML = '.oot lanigiro eht tuo kcehc ot>rb<erus eb ,siht ekil uoy fI>rb<.dralliW yb >a/<nahKeniM>"wen_"=tegrat "8676731005517465/cm/sc/gro.ymedacanahk.www//:sptth"=ferh a< fo>rb<ffo-nips a si margorp sihT'.split("").reverse().join("");
		}

		modelView = newFloat32Array(16);
		glCache = { attributes: {}, locations: {} };
		programObject3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D);
		gl.useProgram(programObject3D);
		glCache.locations.uEdge = gl.getUniformLocation(programObject3D, "uEdge");
		glCache.locations.uSampler = gl.getUniformLocation(programObject3D, "uSampler");
		glCache.locations.aShadow = gl.getAttribLocation(programObject3D, "aShadow");

		//Send the block textures to the GPU
		initTextures();
		initShapes();

		sideEdgeBuffers = {};
		for (let side in shapes.cube.verts) {
			let edgeBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(shapes.cube.verts[side][0]), gl.STATIC_DRAW);
			sideEdgeBuffers[side] = edgeBuffer;
		}
		texCoordsBuffers = [];
		for (let t in textureCoords) {
			let buff = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buff);
			gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW);
			texCoordsBuffers.push(buff);
		}

		//Bind the Vertex Array Object (VAO) that will be used to draw everything
		indexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW);

		//Tell it not to render the insides of blocks
		gl.enable(gl.CULL_FACE);
		gl.cullFace(gl.BACK);

		gl.disableVertexAttribArray(glCache.locations.aShadow);
		gl.vertexAttrib1f(glCache.locations.aShadow, 1.0);
		gl.lineWidth(2);
		blockOutlines = false;
		gl.enable(gl.POLYGON_OFFSET_FILL);
		gl.polygonOffset(1, 1);
		gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

		FOV(60);
		let HALF_PI = Math.PI / 2;
		initModelView(0, 0, 0, -HALF_PI / 6, -HALF_PI / 2.5);

		block2(1, -1, 5, 1);
		block2(2, -1, 5, 1);
		block2(3, -2, 4, 1);
		block2(3, -2, 5, 1);
		block2(2, -2, 4, 1);
		block2(1, -2, 4, 1);
		block2(0, -3, 4, 1);
		block2(1, -3, 4, 2);
		block2(1, -4, 3, 1);
		block2(2, -3, 3, 1);
		block2(3, -2, 3, 1);
		block2(3, -3, 2, 1);
		block2(5, -3, 2, 1);
		block2(4, -4, 1, 1);
		block2(4, -3, 2, 1);
		block2(0, -2, 5, 1);
		block2(4, -2, 3, 1);
		block2(4, -2, 4, 1);
		block2(5, -3, 3, 1);
		//ctx.drawImage(gl.canvas, 0, 0);
		FOV(fov);
	}

	let debugMenu = false;
	function gameLoop() {
		let frameStart = win.performance.now();
		if (!screen) {
			initEverything();
			releasePointer();
		}

		if(screen.includes("menu")) {
			cursor(ARROW);
			strokeWeight(1);
			ctx.clearRect(0, 0, width, height);
			ctx.textAlign = 'center';
			ctx.font = "bold 150px VT323";
			fill(30);
			text("MINEKHAN", width / 2, 158);
			fill(40);
			text("MINEKHAN", width / 2, 155);
			ctx.font = "bold 151px VT323";
			fill(50);
			text("MINEKHAN", width / 2, 152);
			fill(70);
			text("MINEKHAN", width / 2, 150);
			fill(90);
			ctx.font = "bold 152px VT323";
			text("MINEKHAN", width / 2, 148);
			fill(110);
			text("MINEKHAN", width / 2, 145);
			ctx.font = "bold 31.5px VT323";
			fill(30);
			text("K H A N   A C A D E M Y   E D I T I O N", width / 2, 200);
			fill(40);
			text("K H A N   A C A D E M Y   E D I T I O N", width / 2, 198.5);
			fill(50);
			text("K H A N   A C A D E M Y   E D I T I O N", width / 2, 197);
			ctx.font = "bold 31.65px VT323";
			fill(70);
			text("K H A N   A C A D E M Y   E D I T I O N", width / 2, 195.5);
			fill(90);
			text("K H A N   A C A D E M Y   E D I T I O N", width / 2, 194);
			fill(110);
			text("K H A N   A C A D E M Y   E D I T I O N", width / 2, 192.5);

			if(screen === "main menu") {
				fill(220);
				ctx.font = "20px VT323";
				ctx.textAlign = 'left';
				text("Minecraft " + version, width - (width - 2), height - 2);
			} else if(screen === "creation menu") {
				// Buttons will draw themselves
			} else if(screen === "loadsave menu") {
				// Buttons will do the work
			} else if(screen === "options menu") {
				// Still nothing to do
			} else if(screen === "rickrolled menu") {
				ctx.beginPath();
				ctx.fillStyle = "white";
				ctx.rect(0, 0, width, height);
				ctx.font = "50px VT323";
				ctx.textAlign = 'center';
				fill(0);
				text("Multiplayer is impossible on KA.", width / 2, 300);
				ctx.beginPath();
			} else if(screen === "comingsoon menu") {
				ctx.beginPath();
				ctx.fillStyle = "white";
				ctx.rect(0, 0, width, height);
				ctx.font = "100px VT323";
				ctx.textAlign = 'center';
				fill(0);
				text("COMING SOON", width / 2, 325);
				ctx.beginPath();
			}
		} else if(screen === "play") {
			controls();
			runGravity();
			resolveContactsAndUpdatePosition();

			if (updateHUD) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
				hotbar();
				hud();
				ctx.drawImage(gl.canvas, 0, 0);
				updateHUD = false;
				freezeFrame = false;

				gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
			}
			defineWorld(); // Load, draw, and update the world
			gl.flush();
			gl.finish();
		} else if (screen === "inventory") {
			drawInv();
		} else if(screen.includes("pause")) {
			cursor(ARROW);
			strokeWeight(1);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(gl.canvas, 0, 0);

			// ctx.globalAlpha = 0.5;
			// ctx.rect(-2, -2, width + 2, height + 2);
			// ctx.globalAlpha = 1;

			textSize(60);
			fill(0, 0, 0);
			ctx.textAlign = 'center';
			text("Paused", width / 2, 60);
			if(screen === "pause options") {
				ctx.beginPath();
				ctx.beginPath();
			}
		}
		buttons.forEach(drawButton);

		if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
			analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1);
			analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1);
			analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1);
			analytics.fps = Math.round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate));
			analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1);
			analytics.frames = 0;
			analytics.totalRenderTime = 0;
			analytics.totalTickTime = 0;
			analytics.totalFrameTime = 0;
			analytics.worstFrameTime = 0;
			analytics.lastUpdate = Date.now();
			updateHUD = true;
		}

		analytics.frames++;
		analytics.totalFrameTime += win.performance.now() - frameStart;
		analytics.worstFrameTime = Math.max(win.performance.now() - frameStart, analytics.worstFrameTime);
		win.raf = requestAnimationFrame(gameLoop);
	}
	return gameLoop;
}
init = init();
if (window.parent.raf) {
	window.cancelAnimationFrame(window.parent.raf);
	console.log("Canceled", window.parent.raf)
}
init();


	</script>
	</body>
</html>
