<!DOCTYPE html>
<!-- @Minecraft version Alpha 0.5.1
** If it doesn't load, google "how to enable WebGL on <name of your browser>" (note internet explorer probably won't work no matter what)

To save your progress, copy the save code you can get in the pause options, and paste it into "loadString" string just below these comments (around line 127), then save it as a spin-off.
Old saves may break in future updates, so if you're attached to your build, don't update without double checking that it works first.

	Controls:
	
 * Right-click (or ctrl click for mac users) - place block
 * Left-click - remove block
 * Middle-click - pick block
 * Q - sprint
 * Delete - Forced restart (wipes the world and changes seeds)
 * T - Reload Textures
 * W - walk forward
 * S - walk backward
 * A - walk left
 * D - walk right
 * E - open inventory
 * B - toggle super Breaker
 * Z - Zoom
 * X - Quake Pro FOV (Z to return to normal)
 * Arrow Keys - look around
 * P or Esc - pause/unpause
 * 1-9 navigate hotbar
 * Spacebar - jump
 * Double jump - toggle flight
 * Shift (flying) - fly down
 * Space (flying) - fly up
 * ;  -  Release the pointer without pausing (for screenshots)

	Notes and accreditation:

 * This program originated as a spin-off of ScusCraft, which is a P3D Minecraft program with a 4 block render distance. I started out just optimizing it, but it... got a little bit out of hand.
 * I ended up with a program 3x the size of the original that used all sorts of disallowed functionality for the PJS environment. 
 * I ported it to the web environment where all this stuff is allowed to make sure it followed the guidelines. All future updates will be to this version.
 * ScusCraft can be found here: https://www.khanacademy.org/computer-programming/scuscraft-3d/5145400332058624
 * My original spin-off can be found here: https://www.khanacademy.org/computer-programming/high-performance-minecraft/5330738124357632
 * While porting the code, I copied the PJS source code for a few of their helper functions from here: https://raw.githubusercontent.com/Khan/processing-js/master/processing.js
 * The textures and name are obviously stolen from real Minecraft, and are the property of Mojang and Microsoft with whom I have no association. The real game can be found at https://www.minecraft.net/en-us/

 * If anything doesn't work right, let me know in the comments and I'll try to fix it. Any errors in your Javascript console would be useful.

 * Render distance is measured in 16x16 chunks (same as real Minecraft).

 * There's nowhere to offload chunks to, so they're kept in memory until you restart. So don't explore too far or memory usage will grow until it crashes unrecoverably.

 * Adding new (cube shaped) blocks is super easy, so if there's any you want added, just let me know!
 

	Willard's changes from the original:

 * Store blocks in chunks
 * Render whole chunks at once
 * Don't render block faces that aren't adjacent to air
 * Don't render chunks that aren't in within the viewing frustum
 * Fix collision bug
 * Make physics dynamic based on ellapsed time
 * Rewrite rendering system
 * Replace targeting system with much faster raytracing system
 * Add pointer lock for looking around more easily
 * Add textures to blocks
 * Add block shadows
 * Scroll to change inventory slot (Buggy on Chrome - can't fix)
 * Bigger trees
 * Add flying
 * Add Camera Zoom
 * Add Super Breaker
 * Change hotbar to 3D
 * Add Inventory
 * Lots of blocks added


	To-Do:
 * Add superflat world gen option
 * Add leaf decay and grass spread
 * Add new block models (stairs/slabs/doors)
 * Add hand/held item animation
 * Add block breaking particles
 * Add lighting and block lighting
 * Sound effects for falling, breaking, and placing blocks
 * Add sky box
 * Move debug info to option


	How it works:

The graphics in this project are done using WebGL, which is a web implementation of OpenGL ES 2.
It allows us to write shader programs that run right on the GPU, which means it can run as fast as any C++ game.
The infamous P3D mode in Processing.js uses WebGL behind the scenes, but it does it so inefficiently that it might as well not even being using the GPU.

To properly utilize WebGL like this program does, you need to make efficient use of Vertext Buffer Objects (VBOs).
A VBO is an array that contains a whole bunch of vertices. Since WebGL can only render triangles and lines, these vertices are stored in multiples of 3.
A vertex doesn't only include its world coordinates, though. It also includes its texture coordinates, and any other data you want the shaders to manipulate.
In my case, every vertex has an X, Y, Z, textureX, textureY, and shadowIntensity. So 6 values for every block vertex in the world.

A program can only draw 1 VBO per draw call. Since the texture data is attached to the vertex data, you can't switch textures between vertices.
That means you either have to make seperate draw calls for each texture, or only use 1 texture. I do the latter.
I make a single 256x256 pixel texture, and store each of the 16x16 block textures in a section of that big texture, and store the coordinates to it.
Then when I'm preparing my VBO, I send the texture coordinates along with the block coordinates so the shader knows how to map the 256x256 pixel texture onto the 16x16 pixel block face.

I do this once for each chunk in the world, and store those VBOs so I can draw them every frame. If a block is edited in a chunk, then that VBO is replaced.
Drawing a chunk after the VBO has been created is as simple as binding the buffer and calling "gl.drawArrays" once per chunk. The GPU takes care of the rest.

I also use what's called Vertex Array Objects (VAOs) to re-use shared vertices. Since the GPU expects triangles, and I want to draw squares, I need to draw 2 triangles (6 vertices) per square.
That means 2 of them are being re-used. The VAO lets me tell the GPU to use the cached vertex data instead of looking for a new one, which offers a small inprovement to GPU performance.
This isn't entirely necessary, but it's considered best practice. Some OpenGL ES implementations require it, but WebGL 1 does not. I think WebGL 2 does, but that's not as well supported.
-->

<html>
	<head>
		<meta charset="utf-8">
		<title>Minecraft</title>
	</head>
	<style>
		body {
			overflow: hidden; /* Hide scrollbars */
		}
	</style>
	<body>
	<canvas id="overlay" tabindex="0" width="600" height="600" style="position: absolute; top: 0px; left: 0px"></canvas>
	<textarea id="savebox" hidden="true" spellcheck="false" style="position: absolute; top: 0px; left: 0px; z-index: 1;"></textarea>
	<script>
		// Code edits will erase the world.
		// Place save code here to load your world. Make extra sure you got it copied so you don't paste in the wrong thing and delete your world on accident lol
		var loadString = "";
	</script>
	<script>
var canvas = document.getElementById("overlay");
var ctx = canvas.getContext("2d");
var savebox = document.getElementById("savebox");
ctx.canvas.width  = window.innerWidth;
ctx.canvas.height = window.innerHeight;

/* Set this text editor to max width by copying this into the JS console:
document.getElementsByClassName("_1chbfei")[0].setAttribute('style', 'max-width: 100vw !important');
*/

function delag(f) {
	delag.stripDetection = delag.stripDetection || function(s) {
		let outLines = [];
		let lines = s.split("\n");
		for (let i = 0; i < lines.length; i++) {
			if (!lines[i].includes("KAInfiniteLoopProtect")) {
				outLines.push(lines[i]);
			}
		}
		return outLines.join("\n");
	};
	let str = delag.stripDetection(f.toString());
	/* Copied from Element118 delag() function: */
	return Object.constructor('return (function(__env__) {return ' + str + ';});')()(this);
}

var MathGlob = Math;

var init = delag(function() {
	let Math = MathGlob;
	let setPixel, getPixels;
	let textures = {
		grassTop: function(n) {
			let r = 0, g = 0, b = 0, d = 0;
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					d = Math.random() * 0.25 + 0.65;
					r = 0x54 * d;
					g = 0xa0 * d;
					b = 0x48 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
		grassSide: function(n) {
			let r = 0, g = 0, b = 0, d = 0;
			let pix = getPixels("0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530");
			for (let i = 0; i < pix.length; i += 4) {
				setPixel(n, i >> 2 & 15, i >> 6, pix[i], pix[i+1], pix[i+2], pix[i+3]);
			}
			for (let x = 0; x < 16; x++) {
				let m = Math.random() * 4 + 1;
				for (let y = 0; y < m; y++) {
					d = Math.random() * 0.25 + 0.65;
					r = 0x54 * d;
					g = 0xa0 * d;
					b = 0x48 * d;
					setPixel(n, x, y, r, g, b);
				}
			}
		},
		leaves: function(n) {
			let r = 0, g = 0, b = 0, a = 0;
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					r = 0;
					g = Math.floor(Math.random() * 30 + 100);
					b = Math.floor(Math.random() * 30);
					if (Math.random() < 0.35) {
						a = 0;
					} else {
						a = 255;
					}
					setPixel(n, x, y, r, g, b, a);
				}
			}
		},
		oakPlanks: function(n) {
			let r = 0;
			for (let y = 0; y < 16; y++) {
				let a = (y & 3) === 3 ? 0.7 : 1;
				for (let x = 0; x < 16; x++) {
					let mid = x === 8 && (y & 7) > 3 && a === 1 ? 0.85 : 1;
					let rit = x === 15 && (y & 7) < 3 && a === 1 ? 0.85 : 1;
					r = (Math.random() * 0.1 + 0.9) * a * mid * rit;
					setPixel(n, x, y, 190 * r, 154 * r, 96 * r);
				}
			}
		},
		hitbox: function(n) {
			for (let x = 0; x < 16; x++) {
				for (let y = 0; y < 16; y++) {
					setPixel(n, x, y, 0, 0, 0, 255);
				}
			}
		},
		dirt: "0g0g70ordrzz0u30g730wa4vzz0xnyl8f11lrk7315qj7jz1fh47pb6553365533033636350335403653650063306333633300635163503655353653535605335031350330553500033033366333433663663535336655335055335553353530355333033503300333336635353663650660554353355635155305303053556333333366353323553060365553063030663533555365534355335530",
		stone: "0g0g40sywflr0wb8hdr0zdjj0f13tzldr3333211210112222221212222220012121001110111222222233232233222111122111212333312223222222211010131223331331112222110010112211122233323223332222212232223332233332021211001212211122222332222233232111232112200101332112211122111321122222222233332222221123322122",
		logSide: "0g0g60fl1ssf0l5j1fj0qftm2n0wa7mdb14cs7wf16az8xr3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		logTop: "0g0g90l5j1fj0qftm2n0wa7mdb0z2esxr15quebj189da7z1cpma671f7ppfj1hzyayn1012101120110111077776768667777017334454555544811738877776777471164766666666756107576445544674601646636666466471165764655656756116576465464674610657646666566460164764434556756116576666666674610757767777787460175454444444447117776676686677711011101120110211",
		bedrock: "0g0g509gy58f0e7f7r30o8fd330rkrev31627mkf3111124324211212133434341443012110110111412224232433202422111112014111121134433112221221102211014432344323443410222122211011213234421122344344442110121213211143334134410144431102221123442334402111321134111112343420211101234433211211234421121011044312301123",
		glass: "0g0g50ybfh8f0znkiyo12rzshr1au95hb1lytipr4444444444444443411111111111111341114111111111104114111111111110413111111111111041111111111111124111111111111110411111111111111241111111111111124111111111111112411111111111111241111111111111123111111111111412411111111111411231111111111111133323222222222233",
		cobblestone: "0g0g60muaccf0r0pekf0un11q711vr5rz1a8mosf1ef1r0f2144011454313543145330554330132314342143342101321132113232134310021354131154443152453321033543234313433211243215332233213541231321542213533311021543232233121341323231101221044532211235411035532354215434213323154331432332113244323212332143111311232121135432",
		mossyCobble: "0g0gb0muaccf0mupnnj0p38xdr0r0pekf0rbmj9b0un11q70w1wkxr0y07svz11vr5rz1a8mosf1ef1r0f4199211276438a9619a8812764813858398951644251118533852182851464110531183233866642a176895308948428981498852118851988111851664158385117641484642305126244558824124185442111155214698112124761318998127651764653885847488164588511858685851588531841183352111338a984",
		stoneBricks: "0g0g70p2gyyn0rkrev30tj2nlr0xf9ou70zdjj0f12psrnj17g8flr5666666666665550645455555444445065454444445534406434554345434330632334544334324053244333345324302222222222222220110011000111111166666650566666663555544065455554544544306435354445544320634344454444343053345433332322305443344322222220222222221111110000111111",
		mossyStoneBricks: "0g0gc0mupnnj0p2gyyn0p38xdr0rbmj9b0rkrev30tj2nlr0w1wkxr0xf9ou70y07svz0zdjj0f12psrnj17g8flrab3668863b88a680b9a28683a9999332ba926363996a2931b9792a679a979721b737793993697591a72397773632297075225752332277924410441110000444886bbba1abbbb6883aaaa991ba9aaaa6a99a9971b97a7a399aa99351b797992a99997371a689a97777573371a897799755223791722757754000041110004400",
		bricks: "0g0g90vz62nz0yhavi712oqn7j13rinsv173m8lb193f4zj1b1w1rz1d7u7sv1j1u51b7742888777458777443513444435144410060033100503112256522225565222887747458777474214444315133333151341110600133105522225565522225677458887474588774435344444153444110511331106133325565222225652224777474287774745144444353444441501111106011111065222225655222566",
		coalOre: "0g0g70ehg7wf0hjr9j30j7xaf30sywflr0wb8hdr0zdjj0f13tzldr6556544543445666554536666553335454331453344511556665655105655644455443346545645556553215542143464552111065105555433556663334466661156543215455645565354100056665354514334663354455555666634106655443366412111054665105556005455554456665566544455555554655555566",
		ironOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1cpl2bj1gbvabj1o4exa71qwyvb33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217510131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167666421332542223442122221123332233211122222221322222233",
		goldOre: "0g0g80sywflr0wb8hdr0zdjj0f13tzldr1x01czj1y6gem71z13ncv1z141z33223211210112333221203333220002121005120011265223332322642322311122110013212312223220762217610131227655432542222100223330001133336523210762122312232021644423332021251001330021122222333301643322110033167655421332642223442122221123332233211122222221322222233",
		diamondOre: "0g0g80h634zj0sagdtr0sywflr0wb8hdr0zdjj0f13tzldr1845xbz1ndl24f5445433432334555443425555442224343221342233461445554544604544533344332235434534445442764437632353447611054104444322445552223355556145432764344534454243600045554243413223552243344444555523605544332255367611043554604445004344443345554455433344444443544444455",
		redstoneOre: "0g0g90sywflr0wb8hdr0zdjj0f13oi67z13tzldr15wexa71b68mbj1f24cfz1yr4gsf4224211210112444221204444220002121005120011285224442422832422411122110014212412224220862218610141227655342532222100224440001144448524210862122412242021633324442021251001440021122222444401834422110044168655321442832224332122221124442244211122222221422222244",
		lapisOre: "0g0ga04hvenz04hvl6n04ihywv066fd3306r2ozj08z4sfz0sywflr0wb8hdr0zdjj0f13tzldr9889877876778999886669999886668787454386777813889889926329989977788776679867978889866428862576797861242398238888723679978767799993189872643386678998687222236258686627661237725788300799668893588779906612366339998700381039799887783339899877788888899888888899",
		emeraldOre: "0g0g7004swsf06mdmv30sywflr0wb8hdr0zdjj0f13tzldr1ohjdhb5445432232334555443445615442334343223310333422445555225555546133344361324555104445441061243255353445551054434444332232552323355555545461442244534444441053615224243433223310361344444556155551044223455103322553261334455444344441045554455433344554443544444455",
		coalBlock: "0g0g501e50xr03md24f05ul3b308mtq0v0bf3ri73322122002210012222121000210123321000122000022221001243222202210001233222100210020222221000001220132211001122222022210122343221002110123322210000012123221103200212122210002211232102112210012230002113432123322000123420023221000123210012221001222212212221000",
		ironBlock: "0g0gb1dawbnj1fj5rlr1hrdssf1m7r1mn1nlyvwf1pa4wsf1qe8xdr1s2ey9r1t6iyv31tqkz5r1ver01r32233333333222232aaaaa9998777772277777777777777105555555666444402aaaaaa999777771277777777777777105555566664444402aa9999977777771277777777777777105555555566644402aaaaaa999977771277777777777777105555556666444402aaaa9999777777127777777777777712222222112111111",
		goldBlock: "0g0g91kr8um71mphb0f1w77ain1xakkqn1ypvwu71yr43jz1yzk7pb1z0cef31z10mwv2222332223333221285577888776688125664877623324812564877462224471374777462264467137777462267762302877444667762330287444664462232037444664466222613744664466662461364667766666742032667762262776203267762332446261334462332666224132322332662264701101100011001100",
		diamondBlock: "0g0g90434min061d2in0h634zj0l2fpxb0sagdtr0vckf0f1845xbz1ndl24f1z141z33333223332222331378866777664477138445766432235713845766543335561265666543345546126666543346643203766555446643220376555445543323026555445544333412655445544443541245446644444653023446643343664302346643223554341225543223444335123233223443345601101100011001100",
		redstoneBlock: "0g0g50vx660v153407319j36671gh49a71runlz34444444444444444433433222334333443342202222232344332311001120234443211012011244443210000000042344302100000011134421100000000122442231000000111344324110210111234432110004001224443321101001110344322211111122224443124211022323443334433223333344444444444444444",
		lapisBlock: "0g0gd05lqqkf06zt0xr07js8hr07tw35r084kzr308e6ein08e99fj08yjpq708ys8ov0an2j270c0w4cf0dp94hr0fdf5kv98999989cb848484878b78736733677197b8867767623765967877377863366597687666378a63759a77776636a7736197a767676236763596763666a6233625c636636376632775c633687363332371963237873676327186672236338763619763722332677630877633332336667143766633633367708111111610220000",
		emeraldBlock: "0g0g606lfrb306mdmv307ei5fj07xmdbz0iaro5b10c5ptr0000000000000002055555454551144305000000200002430404555411114243050500000002425305050555445212130405054411421203040405451142120305040411020202130404041122120213042105410112420301212222222242030405510000441213012222222222224301011001110014532333333333333332",
		tntTop: "0g0g704qh5a70nyecxr13jyl8f14a4flr1d4tukf1otd8u71szz8jj5665566556655665622462246224622462136210012300234431403344004433566006655660566562246204121402246211120000231023443341000111403356651000000506656211020001140224621360200120112344331031140344335661560500611665621462146124612462236223622362234433443344334433",
		tntSides: "0g0ga07ipw5b0fbhzwf14a4flr1d4tukf1gwtvcv1ldqupr1otd8u71pk09vj1szz8jj1z141z38863886388638863663266326632663266326632663266326632663266326632663266326632663295775577755777799711071550711059745055115157177795717717115505479750571550550759444444444444444433223322332233226632663266326632663266326632663266326632663266323332333233323332",
		tntBottom: "0g0g413jyl8f14a4flr1d4tukf1otd8u72332233223322332300130013001300130013001300130011111111111111111233223322332233230013001300130013001300130013001111111111111111123322332233223323001300130013001300130013001300111111111111111112332233223322332300130013001300130013001300130011111111111111111",
		acaciaLogSide: "0g0g60ma181r0oi99fj0pcavi70t8nim70y9464f139ktmn3143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		acaciaLogTop: "0g0gb0j7rlz30kvxmgv0ma2nen0o889hb0t8nim713rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf432332211231433449999898a889999329556676777766a2395aa999989996910869888888889782197986677668968318688588886886932879868778789784487986876868968448798688887886833869866567789782287988888888968219799899999a96811976766666666691099988988a8899933412233444322114",
		acaciaPlanks: "0g0g711t8qgv13rcxdr16jehof18hk3r31c3oo3j1fprugv1hy2osf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466656666535455554333434332654433334444335300122100012110006556655366646566445533433555544443345432554333330110012221010000",
		birchLogSide: "0g0g80f1fcov0qqliwv1gxap6n1o60u7z1ptrf271uar6db1uum5mn1z141z36643366634663366346666777634443677744367666636777732100136777737366321101377631211336344363331001266344677766532343777777334556376336775577775777764455577766336336777766634477636777767777577634436633667553210026677763443100000133377761132116331677764336336",
		birchLogTop: "0g0ga0mk6h3316m5am719xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm71tgjy7z1z141z39818811001809889966665657556666816223343444433718627766665666360153655555555645106465334433563580535525555355368154653544545645995465354353563599546535555455358853653323445645115465555555563510646656666676350064343333333336016665565575566688901188999811009",
		birchPlanks: "0g0g717znmrj19xxgqn1cg9ce71f8hx4v1jowirj1nv4jcv1nvimm75456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		darkOakLogSide: "0g0g60besef30dcwlbz0e6y70f0hj7ev30klcs8v0oho0e73143304330341432315230523034133230223052313113324032313232301342413230325232314343134131524131432313422343433143230343243342324331053324324242433315332332414303333432303231430331343230533053135133424052303323531343314231333343143340313114334314134131331432",
		darkOakLogTop: "0g0gb08ml79b0auqebj0dcmqdb0e6y70f0f117gf0g4r4730h8wirj0hj7ev30kb0idb0lz2akf0n393wf741441100140744779999898a889999419225565666655a1492aa999989995903859888888889681096985566558958408588288885885941869858668689687786985865858958778698588886885844859855256689681186988888888958109699899999a95800965655555555590399988988a8899944701144777411007",
		darkOakPlanks: "0g0g70bejy0v0dcmqdb0g4r4730h8wirj0kb0idb0lz2akf0n393wf5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		jungleLogSide: "0g0g90h96cxr0htdywv0m9k4xr0ne277j0orqc5b0rkbldr0sxvim70wunksf0ys83cv4688422222666444444114414441001111137510011441866644668842422224146644411143573444422235311010006646442222444886101000466412222444688411068844441122575311222100755444666664355741100112241201661144866643341111623533422111444644111004661664444664122244442222",
		jungleLogTop: "0g0g90h96cxr0htdywv0rkbldr0ys83cv160fym7188mku71batekf1f77h1b1h5ei2n3212210011213223377776768667777217444454555544812748877776777470164766666666756107576445544674620646646666466472165764655656756336576465464674633657646666566462264764444556756106576666666674600757767777787460175454444444447117776676686677722310122333211013",
		junglePlanks: "0g0g70sxkd1b0xdxkov160fym7188mku71batekf1f77h1b1h5ei2n5456666656666652554423455544553345554543333445522112210011010010563666636665443545543432344555543345444255544333001121000011121056654466666666535455554333434332654433334444335300122100012110006356655366636566445533433554544443345432554333330110012221010000",
		spruceLogSide: "0g0g60csc9vj0cskpof0dmmb5r0geuxof0lf4i670nnb4sf3243304330342431325130513034233130113051323223314031323131302341423130315131324343234232514232431323411343433243130343143341314332053314314141433325331331424303333431303132430332343130533053235233414051303313532343324132333343243340323224334324234232332431",
		spruceLogTop: "0g0g80ix87pb0nnb4sf0p1n6db0qzu7zz0v5xypr0xy569r106bshr11ueyv31012101120110111066665657556666016223343444433711627766665666361153655555555645106465334433563501535525555355361154653533545645115465353353563510546535555455350153653323445645115465555555563510646656666676350164343333333336116665565575566611011101120110211",
		sprucePlanks: "0g0g80nnb4sf0p1n6db0qzu7zz0v5xypr0xe36rj0xy569r106bshr11ueyv36567777767777762665523566655663356665643333556622112210011010010673777737776553656653532355666653356555266655333001121000011121067765577777777636566665333535332765533335555336300122100012110007367766377737677556633533665655553356532665333330110012221010000",
		sand: "0g0g61m6x62n1nb9nnj1opn5dr1r80f7j1scbi0v1u0izgf4223213232132313122121130142502432011422222121122331213133132122125213232322122321223332123122121421151211022121212212212111242112322310131232124212221120212231202321232232012311223212331112121213132145321123323230232323221223235332323203223232332321223232",
		gravel: "0g0g80rufq4f0vqwlbz0zxiprz125i9rz15rvcan1627mkf1d0twqn1dackxr0341152512122521522122312102333522103133522351352232321522512322132741122210253202140133526552213104226515530122553253522311225353521223310256122311652152322132123553102521325022533562113225212132222537415525331025232422215235323311243310351274122232321212",
		blackConcrete: "0g0g40149on3028826702882yn028dp8f1330112022012232303130022112212111032203010022012122012222321221011223213030101033110011212233120230013131003200032022012002002112233122202312230200102211312102222122132011021201223320211021220121122122321331201102120210001220112022023302312210123220102110",
		blackWool: "0g0gf0149on3028826702882yn028dp8f03cc2rj03cc3jz03chptr04gg3cv04glqf305kk3y705kpr0f06oo4jj07ss54v08ww5q70a106bj46348b45ab13993299eebb7742570367bc77dc97bcbbdeb996bc768c47cc96ec9749bb115953bb31314c414641672547eebb8879bea7eeb966eebacc45bca9ccbb35ca4657528733577b117949ee7beeccbbecbacb799839349966bb445911796611cd318b9bee92badecb9717bc77cedc97c99beb559b6424c946cd76ac44bc",
		blueConcrete: "0g0g30c98pof0c98qgv0c9ecqn1000001101000201011001000101120101211111010200000001000110100100220110011001121111001100100100010200102101101000000011110001101010101011020111110000000101121111101100100100010110111010210111001101000100000111110100101111000120000010100000110001200110010002",
		blueWool: "0g0gj0c98pof0c98qgv0c9ecqn0c9edj30ddcr270ddidbz0ddie4f0ehgrnj0ehgsfz0ehmepr0ehmfi70flkt1b0flqfb30flqg3j0flw2db0flw35r0gpugov0gq02yn0gqbd3335237c44ac12992289iidc6632460256de67ge96cebbhic985ce657e46ee85ie9648cc114942cc21214e413541562436iidc7769dia6iic955iicaee34cea9eecb24ea4546427622466d116949ii7biieecciecaed699728249955cb344911695511eg217c9bii92bahiec9617be67eigf86e99cid449b5324e935eh65ae34de",
		brownConcrete: "0g0g30pl5gqn0qp3u9r0qp9hbz0211211202222221222122211211122121011102222222212211200222112101121111211111222121222122122221201212121222112122222221220222222122221201121212022122122110221211122221211011221212121010121011111212122221121221222212122112112112211010222111121211220222221122",
		brownWool: "0g0gi0qp3u9r0qp9hbz0rt7uv30rtdh4v0sxbunz0sxbvgf0u1a8zj0u1fv9b0v5e8sf0v5e9kv0v5jvun0w9i9dr0xdgmwv0xdm9z30yhkni70yhq9rz0zloo3j0zluadb35228d45bd12aa219bhhed7721570257ef77gfa7dfccghdb95df758f47ff95hfb749dd115a52dd21214f413541571526hhed887aehb7hhda55hhdbff25dfbbffdc25fb4557518722576e117b4bhh7chhffddhfdbfe7ab82924bb55dc245b116b5511fg218dachhb1cbghfda717cf77fhgg97fabdhe55ac5214fa25fg75bf24ef",
		cyanConcrete: "0g0g305objsv05obklb05oh6v31112010122111202100121222111122012212211101111202102221210222122211111211221111011021102021212212220211021022022201210110010212210211110202101010201110112020221222112102111202212110222110211221001010211001221212202222122111221102211100222112011211120220211",
		cyanWool: "0g0ge05obklb05oh6v305omt4v05omtxb05osg7305oy2gv05p3pj305p9bsv05p9clb05peyv305pkl4v05pklxb05pq87305pq8zj242269347912662167dda95521450145ab55cb659b88cd97649b546b35bb64db7536991146419921113b312431451424dda96656ad75dd9644dd97bb249b77bb9814b73445416521454a115737dd58ddbb99db97ba56762623774498234711474411bc116968dd7187cdb965158b55bdcc65b679da44684213b624bc547b23ab",
		grayConcrete: "0g0g20ehlvr30flk9a70000000000000000000000000000000000000000000000000000000000000000000000000000100100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000100000000000000000001000000010000",
		grayWool: "0g0gd0ehlvr30flk9a70flpvjz0flpwcf0flvim70gptwxr0gpzjzz0htxxj30hu3jsv0hu3klb0iy1y4f0iy7ke70iy7l6n333359337803663157cca85531350135ab55cb658b88cc87539b545b35bb53ca7535990036329930103b303330350335cc995556ac75cc8633cc87ba339b77ba8813a73435305532355a005737cc58ccab88cb87ba56753533773498333700574300ac205968cc7087cca865058b55bccc55b679ca33684313a634bc537a33ab",
		greenConcrete: "0g0g20k2mku70k2s73z0001000100111100101010100101101101101100111010010111001001011000100001100011000100101010110101111010000001011001001000100001010110101110010011010000101011110000010110101000000001010000110101011101000111110011101010011000111100001100011000000111101001101100",
		greenWool: "0g0gh0k2mku70k2s6bj0k2s73z0l6qjun0l6w64f0l71rlr0mb054v0mb5qm70mb5ren0nf9qf30nffcov0ojdq7z0ojjbpb0ojoxz30pnnbi70pnsxrz0rw0y6746447c45ab1499419aggcb8841580168ce88ee98bebbfgba96ce867e48ee96gda849cc125953cc41114e424642681546ggcc7789cga8ggb966ggbaed45ceaaedbb15da4658517843586c21894agg8bggdebbgebaec89a749449966cb445a116a6621de327c9bgga1bafgdb9828be88egee98e9acgc559b6414d946ef86ad44ce",
		lightBlueConcrete: "0g0g3090ti4f090z4e70a4xipr2120111111121222222121122112211121121211112221221111102221122212112021111111122111112111112121211222221111122121212121112021122112211121211211111121220111212121111121222001122211222221022122111011221111111021211221211211121112212111111122121111211112222111",
		lightBlueWool: "0g0gq090z4e70a4xipr0a534zj0a58r9b0b974sf0b9crun0b9ie4f0cdgrnj0cdmepr0cds0zj0dhqein0dhw0sf0dhw1kv0em01dr0em5nnj0fq9o8v0fqfain0gudou70gujb3z0hyhon30hynawv0hynbpb0j2lp8f0j2rbi70k6pptr0latpmn7b57fm89ik26ff63fippnkdd739d04benodepogdkojjppkifblodcfo8doofbpoie8fml21af95mm62428o817b81bd397cppmlffefnpidppkgbbppkioo79loiiookj4aoi8cad93fd55adcn22dh8ippejppookkpokiondfif6f68hhbcmj78ai22cicb22op51fmfjppi3jippokfd2ejoeeoppofdofilpn9agjc738og7copebio78no",
		lightGrayConcrete: "0g0g20yjgg730yjggzj1000110001001010100010000000011101100010001001011010001100101010001000000000000010100000000100010100000000001010100010001000000000100000110000100001100000011101110001001011001001001001011000000000011001001001001010000000010000000010100110000000001000001001",
		lightGrayWool: "0g0gi0yjgg730yjggzj0znkgsf0znkhkv10rohdr10roi6711vshz311vsirj11vy5tr12zwjcv12zwk5b1440jy7144670f1584kjj1584lbz16c8l4v16c8lxb17gclq745339e55bd1399329bhhfd7732570257ff78hfa7dfcchhdb95df769f57ff95hfb759ed115953ee31215f514551572537hhed9979fhb7hhda55hhdbff35dfbbgfdc25fb5657529733577f117b5bhh8chhfgddhfdbgf79b93935bb56ec355b117b6511fh319e9chhb2cbhhfd9718cf78fhhg97f9bdhf55ac6325fa36fh75bf35ff",
		limeConcrete: "0g0g30ppd5a70ppirjz0qth5331121111111100111111111110111110111010211100110111211111211101111112111111111111101110111011110211011011110111110102111110100111000110112112110211112112112111212111111111111111011111011100101111111111212111111111112010011011221111111110111120011110111101111",
		limeWool: "0g0gg0ppirjz0qth5330qtmrcv0rxl4vz0rxqr5r0t1p4ov0t1uqyn0u5t4hr0u5yqrj0v9x4an0va2qkf0we143j0xi53wf0ym3hfj0ym94hr10uh5of35237c44bb1299228affcb6632460257cd67ed96bdbbefba85bd657d46dd85fca748cb104942cc21214d403540562435ffcb7779cfb6ffb955ffbbdc34bdbaecbb24cb4546427622465c01694aff7bffcebbfdbbec69a728249955cb344a105a5501ce207c9bffa2bbefcb9607bd77dfee86d9abfc449b5324c935de75bc34cd",
		magentaConcrete: "0g0g419jw2rj1anugan1ao02kf1ao03cv2233313332221332333333233213322333223332331233333313323103121223222131233211303233130230322231223302323103002220333103232232223333313231221331233333231232212303302330122232333333332123320111033031332321233232303322232223332223231233212323332233222231230323",
		magentaWool: "0g0gs1ao02kf1ao03cv1brygvz1bs435r1bs43y71cw2hhb1cw83r31cw84jj1e06i2n1e0c4cf1e0c54v1f4ainz1f4g4xr1f4g5q71g8ej9b1g8k5j31g8k6bj1hcijun1hco64f1hco6wv1igmkfz1igs6pr1igs7i71jkw7b31jkw83j1kp08ov1lt49a71mxdwxr6945dl77ij14ff43ehrrmjba537a039cmoacqogajojjqrjhe9koa9do7booe9rnhc7elk118f74ll41317o7169719a275arrmkddcfmribrrjg99rrjion57koihonjj38ni798a72db448bam11bh7hrrcjrrnojjrojiomafhd4e47hh99lj578h11ah9911nq41dlfjrrh2jiqrnjfa1cjoccorqpebofhkrm78gj9537ng59oqc9in57mo",
		orangeConcrete: "0g0g21p59iwv1q97wfz1011110111101111111011111110000111101110100111111110011111011001001101110110111111111110111111011111101110111111110111111111111111011110111101111011101101101111010010111111110110101110010011101111111010101001101111111011111110111111111001111111101111111111",
		orangeWool: "0g0gm1q97wfz1rdbw8v1rdbx1b1rdhjb31shfwu71shfxmn1tljxfj1tljy7z1tlpkhr1upnytb1uptl331uptlvj1vtrzen1vtxlof1vtxmgv1wy1m9r1wy1n271wy79bz1wycwe71wyijgf1wyo5q71wytssf46239f55de02aa219dllhe8731570268hi79kib7eieelled96fi779i58ii96lhd859ff005a52ff20205i504650671537llgf998ahld8lleb66lledih35fiddihee25hd5757519822587h008c5dll9ellhieeliedih7ad92925cc67fe355d007d7600hk209faelld1edllhea709ei89ilkj98iadflh55be7315hb37il86dh35hi",
		pinkConcrete: "0g0g31ltks8v1mxj5rz1mxj6kf1122212121112211111211211211122112111221111111121211212111122211111112112121112111111111111112111212221121111111212211112101110212211211122111211112212111211110211211211211111111121212221211121111112212211121211111211212211111111111121112111211212122122111",
		pinkWool: "0g0gv1mxj6kf1o1hk3j1o1n6db1p5r6yn1q9v6rj1q9v7jz1rdz7cv1re4uf31si37y71si8u7z1tm78jj1tmcutb1tmcvlr1uqgven1uqmigv1uqs4qn1vuqj271vuw5bz1vuw64f1vv1se71vv7fgf1vvd1q71vvd2in1vviosf1vvipkv1vvobun1vvocn31vvtywv1vvzlz31vw588v1vw591b6a46em78jk25gg53fjuuokdc638c03adoqcesqhckqkktukjfalqcbeq7dqqfaupjd7fml219g83mm52327q716a71ac386buunleedgoujduukhaauukjqp68lqjjrpkk39pj7b9c83ed439dbo12di7juuekuuprkkuqkjrocgje5f57iiabmk679j22bjba12ps31emgkuuj3kjtupkgc1ekqdequssfdqgjluo89hkb637ph6bqtdajp67oq",
		purpleConcrete: "0g0g40qo16v30rrzke70rrzl6n0rs57gf3222322033323333333312320220233231302222232332333202332233033330333322320012333323333330233022223332223332223232323303323233332332021220323110033223333322032332312323332322322202232223033232221223233023333332022233332332233232023333233223032323332323323332",
		purpleWool: "0g0gm0rrzl6n0rs57gf0sw3kzj0sw3lrz0u01zb30u07lkv0u07mdb0v45zwf0w84dfj0w84e7z0xc8e0v0xc8etb0yg6scf0ygcem70zkasxr10o96gv10o979b10oetj311sd72711sd7un12wh8fz154uxhb47349e45ce13aa32acllfe8742570279fh79jhb7ehddkleca7eh779h48hha7lgc94aee116a52ee31214h414741771547llfe999aflc8lleb77llechg45ehcchged26gc4767519832687f118c4cll9dllgheelhechf7ac93a34cc77ed446c117c7711gj219eadllc1dcklgea719dh99hljia8hacelf56bd7424gb47hk97cg44fh",
		redConcrete: "0g0g112voa9r0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
		redWool: "0g0gd12voa9r13zmnsv153l1bz167jev3167p14v17bnenz18fls7319jprzz1ano5j31ano6bj1brmjun1brs64f1f3yku7241258227712662157cc9754212401459b45bb647b77bc77548b445b25bb54ca7525881036218821112b202420441224cc8855569c75cc7644cc77ba228b77ba7713a724342155113549015627cc57ccab77cb77b946752522664487223711474401ab105867cc7177bca764057b55bcbb55b678c923674212a624bb547a229b",
		whiteConcrete: "0g0g31ktui9r1ku04jj1lxyi2n1121212211221121111221111121122111211111121112111212112211111211212222111111221112211112101110211111122211211211111111212221111112212121212222111121122211111111222111111112121222121111111111211121221112221111121222121112212122111221211212111121221211221212",
		whiteWool: "0g0gn1lxyi2n1lxyiv31ly454v1n22inz1n22jgf1n285q71o66j9b1o66k1r1o6c6bj1paajun1qeekfz1ricyrj1riil1b1smgykf1smmlmn1tqkz5r1tqqm7z1uuozr31uuumtb1vyt0cf1vyynen1x2x0xr1y711j37a56dj89hi26ee63egmmliba639a04acllacmlfailiimmigeajlaadl8blleamlgc8ejj219e94jj62429l817a81aa396ammkjddcelmhbmmifaammihll69jlhgllii49lh8a9a93db549bal12bg8gmmcimmlliimlihllaegd6e68ggaaji689g22agaa12lm41djeimmg3ihmmliea1cilcclmmmeblegjml99fia638lf6almcahl68ll",
		yellowConcrete: "0g0g41to1w5b1us09of1us5vy71us5wqn2111111122222221232021021213122222211020112110121211022201012212122222312211221122213110202011133121132211112221221211211111112120231210211111201132001211212111211102220222021102211223011100222121202222222132111211111112111112021121120222221222011012122121",
		yellowWool: "0g0gj1us5vy71usbj0f1vw9wjj1vwfitb1vwfjlr1vwl5vj1vwl6nz1vwqsxr1x0p6gv1x0utj31x10fsv1x10glb1x163nj1y54h6n1y5a48v1y5a51b1y5frb31y5fs3j1y5lf5r45239e44bc0299219biiec7731470158eg78hga7cgcchicb95dg759g47gg95ifb849ed005942ee20104g404540571436iied9989eib7iica55iicbgf34dgbbgfcc15fb4557419722576e007b4bii8ciifgccigcbge79b92924bb55ec345b006b5500fh209e9ciib1cbhifc9708cg88gihh97g9bdie45ac5314fa35gh85bf34eg",
	};

	let blockData = [
		{
			name: "air",
			id: 0,
			textures: [],
			transparent: true,
			shadow: false,
		},
		{
			name: "grass",
			textures: [ "dirt", "grassTop", "grassSide" ],
		},
		{ name: "dirt" },
		{ name: "stone" },
		{ name: "bedrock" },
		{ name: "sand" },
		{ name: "gravel" },
		{
			name: "leaves",
			transparent: true,
		},
		{
			name: "glass",
			transparent: true,
			shadow: false,
		},
		{ name: "cobblestone" },
		{ name: "mossyCobble" },
		{ name: "stoneBricks" },
		{ name: "mossyStoneBricks" },
		{ name: "bricks" },
		{ name: "coalOre" },
		{ name: "ironOre" },
		{ name: "goldOre" },
		{ name: "diamondOre" },
		{ name: "redstoneOre" },
		{ name: "lapisOre" },
		{ name: "emeraldOre" },
		{ name: "coalBlock" },
		{ name: "ironBlock" },
		{ name: "goldBlock" },
		{ name: "diamondBlock" },
		{ name: "redstoneBlock" },
		{ name: "lapisBlock" },
		{ name: "emeraldBlock" },
		// { // I swear, if y'all don't stop asking about TNT every 5 minutes!
		//	 name: "tnt",
		//	 textures: ["tntBottom", "tntTop", "tntSides"]
		// },
		{ name: "oakPlanks" },
		{
			name: "oakLog",
			textures: [ "logTop", "logSide" ],
		},
		{ name: "acaciaPlanks" },
		{
			name: "acaciaLog",
			textures: [ "acaciaLogTop", "acaciaLogSide" ],
		},
		{ name: "birchPlanks" },
		{
			name: "birchLog",
			textures: [ "birchLogTop", "birchLogSide" ],
		},
		{ name: "darkOakPlanks" },
		{
			name: "darkOakLog",
			textures: [ "darkOakLogTop", "darkOakLogSide" ],
		},
		{ name: "junglePlanks" },
		{
			name: "jungleLog",
			textures: [ "jungleLogTop", "jungleLogSide" ],
		},
		{ name: "sprucePlanks" },
		{
			name: "spruceLog",
			textures: [ "spruceLogTop", "spruceLogSide" ],
		},
		{ name: "whiteWool" },
		{ name: "orangeWool" },
		{ name: "magentaWool" },
		{ name: "lightBlueWool" },
		{ name: "yellowWool" },
		{ name: "limeWool" },
		{ name: "pinkWool" },
		{ name: "grayWool" },
		{ name: "lightGrayWool" },
		{ name: "cyanWool" },
		{ name: "purpleWool" },
		{ name: "blueWool" },
		{ name: "brownWool" },
		{ name: "greenWool" },
		{ name: "redWool" },
		{ name: "blackWool" },
		{ name: "whiteConcrete" },
		{ name: "orangeConcrete" },
		{ name: "magentaConcrete" },
		{ name: "lightBlueConcrete" },
		{ name: "yellowConcrete" },
		{ name: "limeConcrete" },
		{ name: "pinkConcrete" },
		{ name: "grayConcrete" },
		{ name: "lightGrayConcrete" },
		{ name: "cyanConcrete" },
		{ name: "purpleConcrete" },
		{ name: "blueConcrete" },
		{ name: "brownConcrete" },
		{ name: "greenConcrete" },
		{ name: "redConcrete" },
		{ name: "blackConcrete" },
	];

	//Set defaults on blockData
	(function() {
		for (let i = 1; i < blockData.length; i++) {
			let data = blockData[i];
			data.id = i;

			if (!data.textures) {
				data.textures = [ data.name, data.name, data.name, data.name, data.name, data.name ];
			} else if (typeof data.textures === "string") {
				let texture = data.textures;
				data.textures = [ texture, texture, texture, texture, texture, texture ];
			} else if (data.textures.length === 3) {
				data.textures[3] = data.textures[2];
				data.textures[4] = data.textures[2];
				data.textures[5] = data.textures[2];
			} else if (data.textures.length === 2) {
			// Top and bottom are the first texture, sides are the second.
				data.textures[2] = data.textures[1];
				data.textures[3] = data.textures[2];
				data.textures[4] = data.textures[2];
				data.textures[5] = data.textures[2];
				data.textures[1] = data.textures[0];
			}

			data.transparent = data.transparent || false;
			data.shadow = data.shadow !== undefined ? data.shadow : true;
		}
	})();

	let win = window.parent;
	let doc = document;
	let console = win.console;
	let world;

	let newFloat32Array = function(arr) {
		return new Float32Array(arr);
	};
	let newInt32Array = function(arr) {
		return new Int32Array(arr);
	};
	let newUint32Array = function(arr) {
		return new Uint32Array(arr);
	};
	let newUint8Array = function(arr) {
		return new Uint8Array(arr);
	};

	let seedHash;
	let hash = (function() {
		let seed = Math.random() * 2100000000 | 0;
		let PRIME32_2 = 1883677709;
		let PRIME32_3 = 2034071983;
		let PRIME32_4 = 668265263;
		let PRIME32_5 = 374761393;

		seedHash = function(s) {
			seed = s | 0;
		};

		return function(x, y) {
			let h32 = 0;

			h32 = seed + PRIME32_5 | 0;
			h32 += 8;

			h32 += Math.imul(x, PRIME32_3);
			h32 = Math.imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);
			h32 += Math.imul(y, PRIME32_3);
			h32 = Math.imul(h32 << 17 | h32 >> 32 - 17, PRIME32_4);

			h32 ^= h32 >> 15;
			h32 *= PRIME32_2;
			h32 ^= h32 >> 13;
			h32 *= PRIME32_3;
			h32 ^= h32 >> 16;

			return h32 / 2147483647;
		};
	})();
	let worldSeed;

	//The noise and random functions are copied from the processing.js source code; these others are polyfills made by me to avoid needing to remove all the pjs draw calls
	let currentRandom = null;
	function Marsaglia(i1, i2) {
	// from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c
		let z = (i1 | 0) || 362436069, w = i2 || hash(521288629, z) * 2147483647 | 0;

		let nextInt = function() {
			z=36969*(z&65535)+(z>>>16) & 0xFFFFFFFF;
			w=18000*(w&65535)+(w>>>16) & 0xFFFFFFFF;
			return ((z&0xFFFF)<<16 | w&0xFFFF) & 0xFFFFFFFF;
		};

		this.nextDouble = function() {
			let i = nextInt() / 4294967296;
			return i < 0 ? 1 + i : i;
		};
		this.nextInt = nextInt;
	}
	let randomSeed = function(seed) {
		currentRandom = (new Marsaglia(seed)).nextDouble;
	}
	let random = function(min, max) {
		if (!max) {
			if (min) {
				max = min;
				min = 0;
			} else {
				min = 0;
				max = 1;
			}
		}
		return currentRandom() * (max - min) + min;
	}
	let noiseProfile = { generator: undefined, octaves: 4, fallout: 0.5, seed: undefined };
	function PerlinNoise(seed) {
		let rnd = seed !== undefined ? new Marsaglia(seed) : Marsaglia.createRandomized();
		let i, j;
		// http://www.noisemachine.com/talk1/17b.html
		// http://mrl.nyu.edu/~perlin/noise/
		// generate permutation
		let perm = new Uint8Array(512);
		for(i=0;i<256;++i) {
			perm[i] = i;
		}
		for(i=0;i<256;++i) {
			let t = perm[j = rnd.nextInt() & 0xFF]; perm[j] = perm[i]; perm[i] = t;
		}
		// copy to avoid taking mod in perm[0];
		for(i=0;i<256;++i) {
			perm[i + 256] = perm[i];
		}

		function grad3d(i,x,y,z) {
			let h = i & 15; // convert into 12 gradient directions
			let u = h<8 ? x : y,
				v = h<4 ? y : h===12||h===14 ? x : z;
			return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);
		}

		function grad2d(i,x,y) {
			let v = (i & 1) === 0 ? x : y;
			return (i&2) === 0 ? -v : v;
		}

		function grad1d(i,x) {
			return (i&1) === 0 ? -x : x;
		}

		function lerp(t,a,b) {
			return a + t * (b - a);
		}

		this.noise3d = function(x, y, z) {
			let X = Math.floor(x) & 255, Y = Math.floor(y) & 255, Z = Math.floor(z) & 255;
			x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
			let fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;
			let p0 = perm[X]+Y, p00 = perm[p0] + Z, p01 = perm[p0 + 1] + Z,
				p1 = perm[X + 1] + Y, p10 = perm[p1] + Z, p11 = perm[p1 + 1] + Z;
			return lerp(fz,
				lerp(fy, lerp(fx, grad3d(perm[p00], x, y, z), grad3d(perm[p10], x-1, y, z)),
					lerp(fx, grad3d(perm[p01], x, y-1, z), grad3d(perm[p11], x-1, y-1,z))),
				lerp(fy, lerp(fx, grad3d(perm[p00 + 1], x, y, z-1), grad3d(perm[p10 + 1], x-1, y, z-1)),
					lerp(fx, grad3d(perm[p01 + 1], x, y-1, z-1), grad3d(perm[p11 + 1], x-1, y-1,z-1))));
		};

		this.noise2d = function(x, y) {
			let X = Math.floor(x)&255, Y = Math.floor(y)&255;
			x -= Math.floor(x); y -= Math.floor(y);
			let fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;
			let p0 = perm[X]+Y, p1 = perm[X + 1] + Y;
			return lerp(fy,
				lerp(fx, grad2d(perm[p0], x, y), grad2d(perm[p1], x-1, y)),
				lerp(fx, grad2d(perm[p0 + 1], x, y-1), grad2d(perm[p1 + 1], x-1, y-1)));
		};

		this.noise1d = function(x) {
			let X = Math.floor(x)&255;
			x -= Math.floor(x);
			let fx = (3-2*x)*x*x;
			return lerp(fx, grad1d(perm[X], x), grad1d(perm[X+1], x-1));
		};
	}
	let noiseSeed = function(seed) {
		noiseProfile.seed = seed;
		noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
	};
	let noise = function(x, y, z) {
		let generator = noiseProfile.generator;
		let effect = 1, k = 1, sum = 0;
		for(let i = 0; i < noiseProfile.octaves; ++i) {
			effect *= noiseProfile.fallout;
			switch (arguments.length) {
				case 1:
					sum += effect * (1 + generator.noise1d(k*x))/2; break;
				case 2:
					sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;
				case 3:
					sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;
			}
			k *= 2;
		}
		return sum;
	};

	let caveNoise;
	// Copied and modified from https://github.com/blindman67/SimplexNoiseJS
	function openSimplexNoise(clientSeed) {
		const SQ4 = 2;
		const toNums = function(s) { return s.split(",").map(function(s) { return new Uint8Array(s.split("").map(function(v) { return Number(v) })) }) };
		const decode = function(m, r, s) { return new Int8Array(s.split("").map(function(v) { return parseInt(v, r) + m })) };
		const toNumsB32 = function(s) { return s.split(",").map(function(s) { return parseInt(s, 32) }) };
		const NORM_3D = 1.0 / 206.0;
		const SQUISH_3D = 1 / 3;
		const STRETCH_3D = -1 / 6;
		var base3D = toNums("0000110010101001,2110210120113111,110010101001211021012011");
		const gradients3D = decode(-11, 23, "0ff7mf7fmmfffmfffm07f70f77mm7ff0ff7m0f77m77f0mf7fm7ff0077707770m77f07f70");
		var lookupPairs3D = function() { return new Uint16Array(toNumsB32("0,2,1,1,2,2,5,1,6,0,7,0,10,2,12,2,41,1,45,1,50,5,51,5,g6,0,g7,0,h2,4,h6,4,k5,3,k7,3,l0,5,l1,5,l2,4,l5,3,l6,4,l7,3,l8,d,l9,d,la,c,ld,e,le,c,lf,e,m8,k,ma,i,p9,l,pd,n,q8,k,q9,l,15e,j,15f,m,16a,i,16e,j,19d,n,19f,m,1a8,f,1a9,h,1aa,f,1ad,h,1ae,g,1af,g,1ag,b,1ah,a,1ai,b,1al,a,1am,9,1an,9,1bg,b,1bi,b,1eh,a,1el,a,1fg,8,1fh,8,1qm,9,1qn,9,1ri,7,1rm,7,1ul,6,1un,6,1vg,8,1vh,8,1vi,7,1vl,6,1vm,7,1vn,6")) };
		var p3D = decode(-1, 5, "112011210110211120110121102132212220132122202131222022243214231243124213241324123222113311221213131221123113311112202311112022311112220342223113342223311342223131322023113322023311320223113320223131322203311322203131");
		const setOf = function(count) { var a = [],i = 0; while (i < count) { a.push(i++) } return a };
		const doFor = function(count, cb) { var i = 0; while (i < count && cb(i++) !== true) {} };

		function shuffleSeed(seed,count){
			seed = seed * 1664525 + 1013904223 | 0;
			count -= 1;
			return count > 0 ? shuffleSeed(seed, count) : seed;
		}
		const types = {
			_3D : {
				base : base3D,
				squish : SQUISH_3D,
				dimensions : 3,
				pD : p3D,
				lookup : lookupPairs3D,
			}
		};

		function createContribution(type, baseSet, index) {
			var i = 0;
			const multiplier = baseSet[index ++];
			const c = { next : undefined };
			while(i < type.dimensions) {
				const axis = ("xyzw")[i];
				c[axis + "sb"] = baseSet[index + i];
				c["d" + axis] = - baseSet[index + i++] - multiplier * type.squish;
			}
			return c;
		}

		function createLookupPairs(lookupArray, contributions){
			var i;
			const a = lookupArray();
			const res = new Map();
			for (i = 0; i < a.length; i += 2) { res.set(a[i], contributions[a[i + 1]]); }
			return res;
		}

		function createContributionArray(type) {
			const conts = [];
			const d = type.dimensions;
			const baseStep = d * d;
			var k, i = 0;
			while (i < type.pD.length) {
				const baseSet = type.base[type.pD[i]];
				let previous, current;
				k = 0;
				do {
					current = createContribution(type, baseSet, k);
					if (!previous) { conts[i / baseStep] = current; }
					else { previous.next = current; }
					previous = current;
					k += d + 1;
				} while(k < baseSet.length);

				current.next = createContribution(type, type.pD, i + 1);
				if (d >= 3) { current.next.next = createContribution(type, type.pD, i + d + 2) }
				if (d === 4) { current.next.next.next = createContribution(type, type.pD, i + 11) }
				i += baseStep;
			}
			const result = [conts, createLookupPairs(type.lookup, conts)];
			type.base = undefined;
			type.lookup = undefined;
			return result;
		}

		let temp = createContributionArray(types._3D);
		const contributions3D = temp[0], lookup3D = temp[1];
		const perm = new Uint8Array(256);
		const perm3D = new Uint8Array(256);
		const source = new Uint8Array(setOf(256));
		var seed = shuffleSeed(clientSeed, 3);
		doFor(256, function(i) {
			i = 255 - i;
			seed = shuffleSeed(seed, 1);
			var r = (seed + 31) % (i + 1);
			r += r < 0 ? i + 1 : 0;
			perm[i] = source[r];
			perm3D[i] = (perm[i] % 24) * 3;
			source[r] = source[i];
		});
		base3D = undefined;
		lookupPairs3D = undefined;
		p3D = undefined;

		return function(x, y, z) {
			const pD = perm3D;
			const p = perm;
			const g = gradients3D;
			const stretchOffset = (x + y + z) * STRETCH_3D;
			const xs = x + stretchOffset, ys = y + stretchOffset, zs = z + stretchOffset;
			const xsb = Math.floor(xs), ysb = Math.floor(ys), zsb = Math.floor(zs);
			const squishOffset	= (xsb + ysb + zsb) * SQUISH_3D;
			const dx0 = x - (xsb + squishOffset), dy0 = y - (ysb + squishOffset), dz0 = z - (zsb + squishOffset);
			const xins = xs - xsb, yins = ys - ysb, zins = zs - zsb;
			const inSum = xins + yins + zins;
			var c = lookup3D.get(
				(yins - zins + 1) |
				((xins - yins + 1) << 1) |
				((xins - zins + 1) << 2) |
				(inSum << 3) |
				((inSum + zins) << 5) |
				((inSum + yins) << 7) |
				((inSum + xins) << 9)
			);
			var i, value = 0;
			while (c !== undefined) {
				const dx = dx0 + c.dx, dy = dy0 + c.dy, dz = dz0 + c.dz;
				let attn = 2 - dx * dx - dy * dy - dz * dz;
				if (attn > 0) {
					i = pD[(((p[(xsb + c.xsb) & 0xFF] + (ysb + c.ysb)) & 0xFF) + (zsb + c.zsb)) & 0xFF];
					attn *= attn;
					value += attn * attn * (g[i++] * dx + g[i++] * dy + g[i] * dz);
				}
				c = c.next;
			}
			return value * NORM_3D + 0.5;
		}
	}

	let PVector = function(x, y, z) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.set = function(x, y, z) {
			if (y === undefined) {
				this.x = x.x;
				this.y = x.y;
				this.z = x.z;
			} else {
				this.x = x;
				this.y = y;
				this.z = z;
			}
		}
		this.normalize = function() {
			let mag = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
			this.x /= mag;
			this.y /= mag;
			this.z /= mag;
		}
		this.add = function(v) {
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
		}
		this.mult = function(m) {
			this.x *= m;
			this.y *= m;
			this.z *= m;
		}
	}
	let fill = function(r, g, b) {
		if (g === undefined) {
			g = r;
			b = r;
		}
		ctx.fillStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let stroke = function(r, g, b) {
		if (g === undefined) {
			g = r;
			b = r;
		}
		ctx.strokeStyle = "rgb(" + r + ", " + g + ", " + b + ")"
	}
	let line = function(x1, y1, x2, y2) {
		ctx.moveTo(x1, y1);
		ctx.lineTo(x2, y2);
	}
	function fastText(txt, x, y, h) {
		h = h || 0;

		let lines = txt.split("\n");
		for (let i = 0; i < lines.length; i++) {
			ctx.fillText(lines[i], x, y + h * i);
		}
	}
	function textSize(size) {
		ctx.font = size + 'px Sans-Serif';
	}
	let text = fastText;
	let strokeWeight = function(num) {
		ctx.lineWidth = num;
	}
	let HAND = "pointer";
	let CROSS = "crosshair";
	let cursor = function(type) {
		canvas.style.cursor = type;
	}
	randomSeed(Math.random() * 10000000 | 0);

	//globals
	//{
	let fov = 70; // Field of view in degrees
	let version = "Alpha 0.5.1";
	let reach = 5; // Max distance player can place or break blocks

	let blockIds = {};
	blockData.forEach(function(block) {
		blockIds[block.name] = block.id;
	});

	let currentFov, targetFov, fovTime;
	let renderDistance;
	let generatedChunks;
	let mouseX, mouseY;
	let width = window.innerWidth;
	let height = window.innerHeight;
	let generator = {
		height: 80, // Height of the hills
		smooth: 0.01, // Smoothness of the terrain
		extra: 30, // Extra height added to the world.
		caveSize: 0.00 // Redefined right above where it's used
	};
	let maxHeight = 255;
	let blockOutlines = false;
	let blockFill = true;
	let updateHUD = true;
	let textureMap;
	let textureCoords;
	let texCoordsBuffers;
	let bigArray = win.bigArray || newFloat32Array(200000);
	win.bigArray = bigArray;

	let screen;
	let hitBox = {};
	let holding = 0;
	let Key = {};
	let modelView = win.modelView || newFloat32Array(16);
	win.modelView = modelView;
	let glCache;
	let nearH;
	let freezeFrame = 0;
	let p;
	let vec1 = new PVector(), vec2 = new PVector(), vec3 = new PVector();
	let move = {
		x: 0,
		y: 0,
		z: 0,
		ang: Math.sqrt(0.5),
	};
	let p2 = {
		x: 0,
		y: 0,
		z: 0,
	};
	let place;
	let inventory = {
		hotbar: [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
		main: [],
		hotbarSlot: 0,
		size: 40,
		holding: 0,
	};

	//}


	function play() {
		screen = "play";
		getPointer();
		fill(255, 255, 255);
		textSize(10);
		p.lastBreak = Date.now();
		updateHUD = true;
		gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
		savebox.hidden = true;
	}

  function scode() {
    //set a save code with a prompt, bit messy
		var PLOAD = prompt('Enter Save Code:');
    localStorage.setItem('savecode', PLOAD);
    world.loadSave(PLOAD);
    play();
    delete PLOAD;
  }

	let gl;
	function getPointer() {
		if (canvas.requestPointerLock) {
			canvas.requestPointerLock();
		}
	}
	function releasePointer() {
		if (doc.exitPointerLock) {
			doc.exitPointerLock();
		}
	}


	let Block = {
		top: 0x4,
		bottom: 0x8,
		north: 0x20,
		south: 0x10,
		east: 0x2,
		west: 0x1,
	};
	let Sides = {
		top: 0,
		bottom: 1,
		north: 2,
		south: 3,
		east: 4,
		west: 5,
	};

	//GLSL Shader code
	//{
	let vertexShaderSrc3D = ""
	+ "varying float vShadow;"
	+ "attribute vec3 aVertex;"
	+ "attribute vec2 aTexture;"
	+ "attribute float aShadow;"
	+ "varying   vec2 vTexture;"
	+ "uniform vec4 uColor;"
	+ "uniform mat4 uView;"
	+ "uniform mat4 uProjection;"
	+ "uniform bool uEdge;"

	+ "void main(void) {"
	+ "  vTexture = aTexture;"
	+ "  vShadow = aShadow > 0.0 ? aShadow : 1.0;"
	+ "  gl_Position = uView * vec4( aVertex, 1.0 );"

	//"  vShadow = 1.0;"+// - gl_Position.z / 10000.0;" +
	+ "}";

	let fragmentShaderSrc3D = ""
	+ "#ifdef GL_FRAGMENT_PRECISION_HIGH\n"
	+ "  precision highp float;\n"
	+ "#else\n"
	+ "  precision mediump float;\n"
	+ "#endif\n"

	+ "varying float vShadow;"

	+ "uniform sampler2D uSampler;"
	+ "varying vec2 vTexture;"

	+ "void main(void){"
	+ "  vec4 color = texture2D(uSampler, vTexture);"
	+ "  gl_FragColor = vec4(color.rgb * vShadow, color.a);"
	+ "  if (gl_FragColor.a == 0.0) discard;"
	+ "}";
	//}

	let createProgramObject = function(curContext, vetexShaderSource, fragmentShaderSource) {
		let vertexShaderObject = curContext.createShader(curContext.VERTEX_SHADER);
		curContext.shaderSource(vertexShaderObject, vetexShaderSource);
		curContext.compileShader(vertexShaderObject);
		if (!curContext.getShaderParameter(vertexShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(vertexShaderObject);
		}

		let fragmentShaderObject = curContext.createShader(curContext.FRAGMENT_SHADER);
		curContext.shaderSource(fragmentShaderObject, fragmentShaderSource);
		curContext.compileShader(fragmentShaderObject);
		if (!curContext.getShaderParameter(fragmentShaderObject, curContext.COMPILE_STATUS)) {
			throw curContext.getShaderInfoLog(fragmentShaderObject);
		}

		let programObject = curContext.createProgram();
		curContext.attachShader(programObject, vertexShaderObject);
		curContext.attachShader(programObject, fragmentShaderObject);
		curContext.linkProgram(programObject);
		if (!curContext.getProgramParameter(programObject, curContext.LINK_STATUS)) {
			throw "Error linking shaders.";
		}

		return programObject;
	};

	let programObject3D;
	/*
var boxVerts = newFloat32Array([
	0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,//South
	0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,//North
	0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,//East
	0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,//Bottom
   -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5,//West
	0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5 //Top
]);
 var sideFaceVerts = { //Must use GL_TRIANGLES for these
	south:  newFloat32Array([0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5]),
	north:  newFloat32Array([0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5]),
	east:   newFloat32Array([0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5]),
	top: newFloat32Array([0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5]),
	west:  newFloat32Array([-0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5]),
	bottom:	newFloat32Array([0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5])
};*/
	let sideEdgeVerts = [
		newFloat32Array([ -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5 ]), //top
		newFloat32Array([ -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5,  0.5, -0.5 ]), //bottom
		newFloat32Array([ 0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5 ]), //north
		newFloat32Array([ -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5 ]), //south
		newFloat32Array([ 0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5 ]), //east
		newFloat32Array([ -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5 ]),  //west
	];
	let indexOrder;
	(function() {
		let arr = [];
		for (let i = 0; i < 40000; i++) {
			arr.push(0 + i * 4, 1 + i * 4, 2 + i * 4, 0 + i * 4, 2 + i * 4, 3 + i * 4);
		}
		indexOrder = newUint32Array(arr);
	})();
	/*
	let boxOutlineVerts = newFloat32Array([
		0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5,
		-0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,
		0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5,
		-0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5,
		0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5,
		-0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,
	]);
	let boxVerts = [
		[ 0.5, -0.5, -0.5,  0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5, -0.5,  0.5, -0.5, -0.5 ], //top
		[ 0.5,  0.5,  0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5,  0.5,  0.5,  0.5 ], //bottom
		[ 0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5 ], //north
		[ 0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5 ], //south
		[ 0.5,  0.5, -0.5,  0.5,  0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5, -0.5,  0.5,  0.5, -0.5 ], //east
		[ -0.5, -0.5, -0.5, -0.5, -0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5,  0.5, -0.5,  0.5, -0.5, -0.5, -0.5, -0.5 ], //west
	];*/
	let hexagonVerts;
	let blockIcons;
	(function() {
		let side = Math.sqrt(3) / 2;
		hexagonVerts = newFloat32Array([
			0, 1, 1, side, 0.5, 1, 0, 0, 1, -side, 0.5, 1,
			0, 0, 1, side, 0.5, 1, side, -0.5, 1, 0, -1, 1,
			-side, 0.5, 1, 0, 0, 1, 0, -1, 1, -side, -0.5, 1,
		]);
	})();
	function genIcons() {
		blockIcons = [null];
		let texOrder = [ 1, 2, 3 ];
		let shadows = [ 1, 0.4, 0.7 ];
		let scale = 0.16 / height * inventory.size;
		for (let i = 1; i < blockData.length; i++) {
			let data = [];
			let block = blockData[i];
			for (let j = 0; j < 12; j++) {
				data.push(hexagonVerts[j * 3 + 0] * scale);
				data.push(hexagonVerts[j * 3 + 1] * scale);
				data.push(0.1666666);
				data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 0) % 8]);
				data.push(textureCoords[textureMap[block.textures[texOrder[Math.floor(j / 4)]]]][(j * 2 + 1) % 8]);
				data.push(shadows[Math.floor(j / 4)]);
			}
			let buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, newFloat32Array(data), gl.STATIC_DRAW);
			blockIcons.push(buffer);
		}
	}

	function uniformMatrix(cacheId, programObj, vrName, transpose, matrix) {
		let vrLocation = glCache.locations[cacheId];
		if(vrLocation === undefined) {
			vrLocation = gl.getUniformLocation(programObj, vrName);
			glCache.locations[cacheId] = vrLocation;
		}
		gl.uniformMatrix4fv(vrLocation, transpose, matrix);
	}
	function vertexAttribPointer(cacheId, programObj, vrName, size, VBO) {
		let vrLocation = glCache.locations[cacheId];
		if(vrLocation === undefined) {
			vrLocation = gl.getAttribLocation(programObj, vrName);
			glCache.locations[cacheId] = vrLocation;
		}
		if (vrLocation !== -1) {
			gl.enableVertexAttribArray(vrLocation);
			gl.bindBuffer(gl.ARRAY_BUFFER, VBO);
			gl.vertexAttribPointer(vrLocation, size, gl.FLOAT, false, 0, 0);

		}
	}

	//Generate buffers for every block face and store them
	let sideEdgeBuffers;
	let indexBuffer;

	/** Matrix and Vector transformation methods **/
	//{
	let matrix = newFloat32Array(16);
	let projection = win.projection || newFloat32Array(16);
	win.projection = projection;
	function trans(matrix, x, y, z) {
		let a = matrix;
		a[3] += a[0] * x + a[1] * y + a[2] * z;
		a[7] += a[4] * x + a[5] * y + a[6] * z;
		a[11] += a[8] * x + a[9] * y + a[10] * z;
		a[15] += a[12] * x + a[13] * y + a[14] * z;
	}
	function rotX(matrix, angle) {
	// source = [1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1]
		let elems = matrix;
		let c = Math.cos(angle);
		let s = Math.sin(angle);
		let t = elems[1];
		elems[1] = t * c + elems[2] * s;
		elems[2] = t * -s + elems[2] * c;
		t = elems[5];
		elems[5] = t * c + elems[6] * s;
		elems[6] = t * -s + elems[6] * c;
		t = elems[9];
		elems[9] = t * c + elems[10] * s;
		elems[10] = t * -s + elems[10] * c;
		t = elems[13];
		elems[13] = t * c + elems[14] * s;
		elems[14] = t * -s + elems[14] * c;
	}
	function rotY(matrix, angle) {
	//source = c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1
		let c = Math.cos(angle);
		let s = Math.sin(angle);
		let elems = matrix;
		let t = elems[0];
		elems[0] = t * c + elems[2] * -s;
		elems[2] = t * s + elems[2] * c;
		t = elems[4];
		elems[4] = t * c + elems[6] * -s;
		elems[6] = t * s + elems[6] * c;
		t = elems[8];
		elems[8] = t * c + elems[10] * -s;
		elems[10] = t * s + elems[10] * c;
		t = elems[12];
		elems[12] = t * c + elems[14] * -s;
		elems[14] = t * s + elems[14] * c;
	}
	function transpose(matrix) {
		let temp = matrix[4];
		matrix[4] = matrix[1];
		matrix[1] = temp;

		temp = matrix[8];
		matrix[8] = matrix[2];
		matrix[2] = temp;

		temp = matrix[6];
		matrix[6] = matrix[9];
		matrix[9] = temp;

		temp = matrix[3];
		matrix[3] = matrix[12];
		matrix[12] = temp;

		temp = matrix[7];
		matrix[7] = matrix[13];
		matrix[13] = temp;

		temp = matrix[11];
		matrix[11] = matrix[14];
		matrix[14] = temp;
	}
	function matMult() {
	//Multiply the projection matrix by the view matrix; this is optimized specifically for these matrices by removing terms that are always 0.
		let proj = projection;
		let view = modelView;
		matrix[0] = proj[0] * view[0];
		matrix[1] = proj[0] * view[1];
		matrix[2] = proj[0] * view[2];
		matrix[3] = proj[0] * view[3];
		matrix[4] = proj[5] * view[4];
		matrix[5] = proj[5] * view[5];
		matrix[6] = proj[5] * view[6];
		matrix[7] = proj[5] * view[7];
		matrix[8] = proj[10] * view[8] + proj[11] * view[12];
		matrix[9] = proj[10] * view[9] + proj[11] * view[13];
		matrix[10] = proj[10] * view[10] + proj[11] * view[14];
		matrix[11] = proj[10] * view[11] + proj[11] * view[15];
		matrix[12] = proj[14] * view[8];
		matrix[13] = proj[14] * view[9];
		matrix[14] = proj[14] * view[10];
		matrix[15] = proj[14] * view[11];
	}
	function copyArr(a, b) {
		for (let i = 0; i < a.length; i++) {
			b[i] = a[i];
		}
	}
	function FOV(fov) {
		let tang = Math.tan(fov * 0.5 * Math.PI / 180);
		let scale = 1 / tang;
		let near = 1;
		let far = 1000000;
		currentFov = fov;
		nearH = near * tang;

		projection[0] = scale / width * height;
		projection[5] = scale;
		projection[10] = -far / (far - near);
		projection[11] = -1;
		projection[14] = -far * near / (far - near);

	// Set the projecction matrix in the shader
	// copyArr(projection, matrix);
	// transpose(matrix);
	// uniformMatrix("projection3d", programObject3D, "uProjection", false, matrix);
	}
	function cross(v1, v2, result) {
		let x = v1.x,
			y = v1.y,
			z = v1.z,
			x2 = v2.x,
			y2 = v2.y,
			z2 = v2.z;
		result.x = y * z2 - y2 * z;
		result.y = z * x2 - z2 * x;
		result.z = x * y2 - x2 * y;
	}
	//}

	function Plane(nx, ny, nz) {
		this.dx = nx > 0 ? 16 : 0;
		this.dy = ny > 0;
		this.dz = nz > 0 ? 16 : 0;

		// Normal vector
		this.nx = nx;
		this.ny = ny;
		this.nz = nz;
	}
	Plane.prototype.set = Plane;
	function computeFrustum() {
		let X = vec1;
		X.x = p.direction.z;
		X.y = 0
		X.z = -p.direction.x;
		X.normalize();

		let Y = vec2;
		Y.set(p.direction);
		Y.mult(-1);
		cross(Y, X, Y);

		//Near plane (hoisted to outside the render loop to improve performance)
		// var x = p.x + p.direction.x;
		// var y = p.y + p.direction.y;
		// var z = p.z + p.direction.z;
		// p.frustum[0].set(x, y, z, p.direction.x, p.direction.y, p.direction.z);

		let aux = vec3;
		aux.set(Y);
		aux.mult(nearH);
		aux.add(p.direction);
		aux.normalize();
		cross(aux, X, aux);
		p.frustum[0].set(aux.x, aux.y, aux.z);

		aux.set(Y);
		aux.mult(-nearH);
		aux.add(p.direction);
		aux.normalize();
		cross(X, aux, aux);
		p.frustum[1].set(aux.x, aux.y, aux.z);

		aux.set(X);
		aux.mult(-nearH * width / height);
		aux.add(p.direction);
		aux.normalize();
		cross(aux, Y, aux);
		p.frustum[2].set(aux.x, aux.y, aux.z);

		aux.set(X);
		aux.mult(nearH * width / height);
		aux.add(p.direction);
		aux.normalize();
		cross(Y, aux, aux);
		p.frustum[3].set(aux.x, aux.y, aux.z);
	}
	let chunkVisible = function(x, y, z, maxY) {
		x -= 0.5;
		y -= 0.5;
		z -= 0.5;
		maxY += 0.5;
		let px = 0, py = 0, pz = 0, plane = null;
		let cx = p.x, cy = p.y, cz = p.z;
		for (let i = 0; i < 4; i++) {
			plane = p.frustum[i];
			px = x + plane.dx;
			py = plane.dy ? maxY : y;
			pz = z + plane.dz;
			if ((px - cx) * plane.nx + (py - cy) * plane.ny + (pz - cz) * plane.nz < 0) {
				return false;
			}
		}
		return true;
	};

	let defaultModelView = newFloat32Array([ -4,0,0,0,0,4,0,0,0,0,-4,0,0,0,0,1 ]);
	let initModelView = function(x, y, z, rx, ry) {
		copyArr(defaultModelView, modelView);
		rotX(modelView, rx);
		rotY(modelView, ry);
		trans(modelView, -x, -y, -z);
		matMult();
		transpose(matrix);
		uniformMatrix("view3d", programObject3D, "uView", false, matrix);
	};
	let tex;

	function getFaces(x, y, z) {
		return p.x < x - 0.5
	| (p.x > x + 0.5) << 1
	| (p.y < y - 0.5) << 2
	| (p.y > y + 0.5) << 3
	| (p.z < z - 0.5) << 4
	| (p.z > z + 0.5) << 5;
	}
	function rayTrace(x, y, z, sides) {
		x -= 0.5;
		y -= 0.5;
		z -= 0.5;

		let cf, cd = 1e9; //Closest face and distance
		let m; //Absolute distance to intersection point
		let ix, iy, iz; //Intersection coords

		//Top and bottom faces
		if (Block.top & sides && p.direction.y) {
			m = (y - p.y) / p.direction.y;
			ix = m * p.direction.x + p.x;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iz >= z && iz <= z + 1) {
				cd = m; //Ray crosses top face
				cf = "top";
			}
		}
		y += 1;
		if (Block.bottom & sides && p.direction.y) {
			m = (y - p.y) / p.direction.y;
			ix = m * p.direction.x + p.x;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iz >= z && iz <= z + 1) {
				cd = m;
				cf = "bottom";
			}
		}
		y -= 1;

		//West and East faces
		if (Block.west & sides && p.direction.x) {
			m = (x - p.x) / p.direction.x;
			iy = m * p.direction.y + p.y;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && iy >= y && iy <= y + 1 && iz >= z && iz <= z + 1) {
				cd = m;
				cf = "west";
			}
		}
		x += 1;
		if (Block.east & sides && p.direction.x) {
			m = (x - p.x) / p.direction.x;
			iy = m * p.direction.y + p.y;
			iz = m * p.direction.z + p.z;
			if (m > 0 && m < cd && iy >= y && iy <= y + 1 && iz >= z && iz <= z + 1) {
				cd = m;
				cf = "east";
			}
		}
		x -= 1;

		//South and North faces
		if (Block.south & sides && p.direction.z) {
			m = (z - p.z) / p.direction.z;
			ix = m * p.direction.x + p.x;
			iy = m * p.direction.y + p.y;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iy >= y && iy <= y + 1) {
				cd = m;
				cf = "south";
			}
		}
		z += 1;
		if (Block.north & sides && p.direction.z) {
			m = (z - p.z) / p.direction.z;
			ix = m * p.direction.x + p.x;
			iy = m * p.direction.y + p.y;
			if (m > 0 && m < cd && ix >= x && ix <= x + 1 && iy >= y && iy <= y + 1) {
				cd = m;
				cf = "north";
			}
		}
		return [ cd, cf ];
	}
	function runRayTrace(x, y, z, faces) {
		let block = world.getBlock(x, y, z);
		if (block) {
			let rt = rayTrace(x, y, z, faces);

			if (rt[1] && rt[0] < hitBox.closest) {
				hitBox.closest = rt[0];
				hitBox.face = rt[1];
				hitBox.pos = [ x, y, z ];
			}
		}
	}
	function lookingAt() {
	// Checks blocks in front of the player to see which one they're looking at
		hitBox.pos = null;
		hitBox.closest = 1e9;
		let pd = p.direction;

		// Target block
		let tx = Math.round(pd.x * reach + p.x);
		let ty = Math.round(pd.y * reach + p.y);
		let tz = Math.round(pd.z * reach + p.z);

		let minX = p2.x;
		let maxX = 0;
		let minY = p2.y;
		let maxY = 0;
		let minZ = p2.z;
		let maxZ = 0;
		let faces = getFaces(tx, ty, tz);

		for (let i = 1; i < reach + 1; i++) {
			if (i > reach) {
				i = reach;
			}
			maxX = Math.round(p.x + pd.x * i);
			maxY = Math.round(p.y + pd.y * i);
			maxZ = Math.round(p.z + pd.z * i);
			if (maxX === minX && maxY === minY && maxZ === minZ) {
				continue;
			}
			if (minX !== maxX) {
				if (minY !== maxY) {
					if (minZ !== maxZ) {
						runRayTrace(maxX, maxY, maxZ, faces);
					}
					runRayTrace(maxX, maxY, minZ, faces);
				}
				if (minZ !== maxZ) {
					runRayTrace(maxX, minY, maxZ, faces);
				}
				runRayTrace(maxX, minY, minZ, faces);
			}
			if (minY !== maxY) {
				if (minZ !== maxZ) {
					runRayTrace(minX, maxY, maxZ, faces);
				}
				runRayTrace(minX, maxY, minZ, faces);
			}
			if (minZ !== maxZ) {
				runRayTrace(minX, minY, maxZ, faces);
			}
			if (hitBox.pos) {
				return; //The ray has collided; it can't possibly find a closer collision now
			}
			minZ = maxZ;
			minY = maxY;
			minX = maxX;
		}
	}
	let inBox = function(x, y, z, w, h, d) {
		let iy = y - h/2 - p.topH;
		let ih = h + p.bottomH + p.topH;
		let ix = x - w/2 - p.w;
		let iw = w + p.w*2;
		let iz = z - d/2 - p.w;
		let id = d + p.w*2;
		return p.x > ix && p.y > iy && p.z > iz && p.x < ix + iw && p.y < iy + ih && p.z < iz + id;
	};
	let boxCollision = function(x, y, z, w, h, d, vx, vy, vz, dt) {
		if(inBox(x, y, z, w, h, d)) {
			if(vx) {
				p.x -= p.velocity.x * dt;
				p.velocity.x = 0;
			} else if(vz) {
				p.z -= p.velocity.z * dt;
				p.velocity.z = 0;
			} else if(vy > 0) {
				p.y -= p.velocity.y * dt;
				p.velocity.y = 0;
			} else {
				p.y = y - h/2 - p.topH + (h + p.bottomH + p.topH); // y + h/2 + p.bottomH;
				p.onGround = true;
				p.velocity.y = 0;
			}
		}
	};
	let contacts = {
		array: [],
		size: 0,
		add: function(x, y, z) {

			if (this.size === this.array.length) {
				this.array.push([ x, y, z ]);
			} else {
				this.array[this.size][0] = x;
				this.array[this.size][1] = y;
				this.array[this.size][2] = z;
			}
			this.size++;
		},
		clear: function() {
			this.size = 0;
		},
	};
	let resolveContactsAndUpdatePosition = function() {
		let minX = p2.x - 1;
		let maxX = p2.x + 1;
		let minY = p2.y - 2;
		let maxY = p2.y + 1;
		let minZ = p2.z - 1;
		let maxZ = p2.z + 1;
		let wrld = world;
		let cont = contacts;
		let block = null;
		let player = p;

		for (let x = minX; x <= maxX; x++) {
			for (let y = minY; y <= maxY; y++) {
				for (let z = minZ; z <= maxZ; z++) {
					if (wrld.getBlock(x, y, z)) {
						cont.add(x, y, z);
					}
				}
			}
		}

		let dt = (win.performance.now() - p.lastUpdate) / 33;
		dt = dt > 2 ? 2 : dt;

		//Check collisions in the X direction
		player.x += player.velocity.x * dt;
		for (let i = 0; i < contacts.size; i++) {
			block = cont.array[i];
			boxCollision(block[0], block[1], block[2], 1, 1, 1, player.velocity.x, 0, 0, dt);
		}

		//Check collisions in the Y direction
		player.y += player.velocity.y * dt;
		for (let i = 0; i < contacts.size; i++) {
			block = cont.array[i];
			boxCollision(block[0], block[1], block[2], 1, 1, 1, 0, player.velocity.y, 0, dt);
		}

		//Check collisions in the Z direction
		player.z += player.velocity.z * dt;
		for (let i = 0; i < contacts.size; i++) {
			block = cont.array[i];
			boxCollision(block[0], block[1], block[2], 1, 1, 1, 0, 0, player.velocity.z, dt);
		}

		if (!p.flying) {
			let drag = p.onGround ? 0.5 : 0.85;
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
		} else {
			let drag = 0.9;
			p.velocity.z += (p.velocity.z * drag - p.velocity.z) * dt;
			p.velocity.x += (p.velocity.x * drag - p.velocity.x) * dt;
			p.velocity.y += (p.velocity.y * 0.8 - p.velocity.y) * dt;
			if (p.onGround) {
				p.flying = false;
			}
		}

		p.lastUpdate = win.performance.now();
		contacts.clear();
		lookingAt();
	};
	let runGravity = function() {
		if (p.flying) {
			return;
		}
		let dt = (win.performance.now() - p.lastUpdate) / 33;
		dt = dt > 2 ? 2 : dt;
		if(p.onGround) {
			if(Key[" "]) {
				p.velocity.y = p.jumpSpeed;
				p.onGround = false;
			} else {
				p.velocity.y = 0;
			}
		} else {
			p.velocity.y += p.gravityStength * dt;
			if(p.velocity.y < -p.maxYVelocity) {
				p.velocity.y = -p.maxYVelocity;
			}
		}
		p.onGround = false;
	};

	function box2(sides, tex) {
		let i = 0;
		for (let side in Block) {
			if (sides & Block[side]) {
				vertexAttribPointer("aVertex", programObject3D, "aVertex", 3, sideEdgeBuffers[Sides[side]]);
				if (blockFill) {
					vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap[tex[i]]]);
					gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_INT, 0);
				}

				if (blockOutlines) {
					vertexAttribPointer("aTexture", programObject3D, "aTexture", 2, texCoordsBuffers[textureMap.hitbox]);
					gl.drawArrays(gl.LINE_LOOP, 0, 4);
				}
			}
			i++;
		}
	}
	function block2(x, y, z, t) {
		copyArr(modelView, matrix);
		trans(modelView, x, y, z);
		matMult();
		trans(modelView, -x, -y, -z);
		transpose(matrix);
		uniformMatrix("view3d", programObject3D, "uView", false, matrix);
		box2(0xff, blockData[t].textures);
	}

	let changeWorldBlock = function(t) {
		let pos = hitBox.pos;
		if(pos && pos[1] > 0 && pos[1] < maxHeight) {
			world.setBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], t);
			if (t) {
				p.lastPlace = Date.now();
			} else {
				p.lastBreak = Date.now();
			}
		}
	};
	let newWorldBlock = function() {
		if(!hitBox.pos || !holding) {
			return;
		}
		let x = 0, y = 0, z = 0, pos = hitBox.pos;
		switch(hitBox.face) {
			case "top":
				y -= 1;
				break;
			case "bottom":
				y += 1;
				break;
			case "south":
				z -= 1;
				break;
			case "north":
				z += 1;
				break;
			case "west":
				x -= 1;
				break;
			case "east":
				x += 1;
				break;
		}
		if (!inBox(pos[0] + x, pos[1] + y, pos[2] + z, 1, 1, 1)) {
			pos[0] += x;
			pos[1] += y;
			pos[2] += z;
			changeWorldBlock(holding);
		}
	};

	let sphere;
	(function() {
		let blocks = [];
		let radius = 3.5;
		let radsq = radius * radius;
		for (let i = -radius; i <= radius; i++) {
			for (let j = -radius; j <= radius; j++) {
				for (let k = -radius; k <= radius; k++) {
					if (i*i + j*j + k*k < radsq) {
						blocks.push(i|0, j|0, k|0);
					}
				}
			}
		}
		sphere = new Int8Array(blocks);
	})();
	generator.caveSize = 0.0055;
	function isCave(x, y, z) {
		let smooth = 0.02;
		let cave1 = Math.abs(0.5 - caveNoise(x * smooth, y * smooth, z * smooth)) < generator.caveSize;
		let cave2 = Math.abs(0.5 - caveNoise(y * smooth, z * smooth, x * smooth)) < generator.caveSize;
		return (cave1 && cave2);
	}
	function carveSphere(x, y, z) {
		if (y > 3) {
			for (let i = 0; i < sphere.length; i += 3) {
				world.setBlock(x + sphere[i], y + sphere[i + 1], z + sphere[i + 2], blockIds.air, true);
			}
		}
	}

	let renderedChunks = 0;
	function getBlock(x, y, z, blocks) {
		return blocks[((x >> 4) + 1) * 9 + ((y >> 4) + 1) * 3 + (z >> 4) + 1][((x & 15) << 8) + ((y & 15) << 4) + (z & 15)] & 0xff;
	}
	function hideFace(x, y, z, blocks, type, func) {
		let block = func.call(world, x, y, z, blocks);
		let data = blockData[block]
		if (!block || block !== type && data.transparent || data.transparent && data.shadow) {
			return 1;
		}
		return 0;
	}
	let getShadows = {
		shade: [ 1, 0.85, 0.7, 0.6, 0.3 ],
		top: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z-1, block)].shadow,
				blockData[getBlock(x, y-1, z-1, block)].shadow,
				blockData[getBlock(x+1, y-1, z-1, block)].shadow,
				blockData[getBlock(x-1, y-1, z, block)].shadow,
				blockData[getBlock(x, y-1, z, block)].shadow,
				blockData[getBlock(x+1, y-1, z, block)].shadow,
				blockData[getBlock(x-1, y-1, z+1, block)].shadow,
				blockData[getBlock(x, y-1, z+1, block)].shadow,
				blockData[getBlock(x+1, y-1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8,
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8,
			];
		},
		bottom: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y+1, z-1, block)].shadow,
				blockData[getBlock(x, y+1, z-1, block)].shadow,
				blockData[getBlock(x+1, y+1, z-1, block)].shadow,
				blockData[getBlock(x-1, y+1, z, block)].shadow,
				blockData[getBlock(x, y+1, z, block)].shadow,
				blockData[getBlock(x+1, y+1, z, block)].shadow,
				blockData[getBlock(x-1, y+1, z+1, block)].shadow,
				blockData[getBlock(x, y+1, z+1, block)].shadow,
				blockData[getBlock(x+1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
			];
		},
		north: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z+1, block)].shadow,
				blockData[getBlock(x, y-1, z+1, block)].shadow,
				blockData[getBlock(x+1, y-1, z+1, block)].shadow,
				blockData[getBlock(x-1, y, z+1, block)].shadow,
				blockData[getBlock(x, y, z+1, block)].shadow,
				blockData[getBlock(x+1, y, z+1, block)].shadow,
				blockData[getBlock(x-1, y+1, z+1, block)].shadow,
				blockData[getBlock(x, y+1, z+1, block)].shadow,
				blockData[getBlock(x+1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
			];
		},
		south: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z-1, block)].shadow,
				blockData[getBlock(x-1, y, z-1, block)].shadow,
				blockData[getBlock(x-1, y+1, z-1, block)].shadow,
				blockData[getBlock(x, y-1, z-1, block)].shadow,
				blockData[getBlock(x, y, z-1, block)].shadow,
				blockData[getBlock(x, y+1, z-1, block)].shadow,
				blockData[getBlock(x+1, y-1, z-1, block)].shadow,
				blockData[getBlock(x+1, y, z-1, block)].shadow,
				blockData[getBlock(x+1, y+1, z-1, block)].shadow,
			];
			return [
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]],
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]],
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]],
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]],
			];
		},
		east: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x+1, y-1, z-1, block)].shadow,
				blockData[getBlock(x+1, y, z-1, block)].shadow,
				blockData[getBlock(x+1, y+1, z-1, block)].shadow,
				blockData[getBlock(x+1, y-1, z, block)].shadow,
				blockData[getBlock(x+1, y, z, block)].shadow,
				blockData[getBlock(x+1, y+1, z, block)].shadow,
				blockData[getBlock(x+1, y-1, z+1, block)].shadow,
				blockData[getBlock(x+1, y, z+1, block)].shadow,
				blockData[getBlock(x+1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[1] + blocks[2] + blocks[4] + blocks[5]]*0.8,
				this.shade[blocks[5] + blocks[4] + blocks[8] + blocks[7]]*0.8,
				this.shade[blocks[4] + blocks[3] + blocks[7] + blocks[6]]*0.8,
				this.shade[blocks[0] + blocks[1] + blocks[3] + blocks[4]]*0.8,
			];
		},
		west: function(x, y, z, block) {
			let blocks = [
				blockData[getBlock(x-1, y-1, z-1, block)].shadow,
				blockData[getBlock(x-1, y, z-1, block)].shadow,
				blockData[getBlock(x-1, y+1, z-1, block)].shadow,
				blockData[getBlock(x-1, y-1, z, block)].shadow,
				blockData[getBlock(x-1, y, z, block)].shadow,
				blockData[getBlock(x-1, y+1, z, block)].shadow,
				blockData[getBlock(x-1, y-1, z+1, block)].shadow,
				blockData[getBlock(x-1, y, z+1, block)].shadow,
				blockData[getBlock(x-1, y+1, z+1, block)].shadow,
			];
			return [
				this.shade[blocks[7] + blocks[8] + blocks[4] + blocks[5]]*0.8,
				this.shade[blocks[5] + blocks[4] + blocks[2] + blocks[1]]*0.8,
				this.shade[blocks[4] + blocks[3] + blocks[1] + blocks[0]]*0.8,
				this.shade[blocks[6] + blocks[7] + blocks[3] + blocks[4]]*0.8,
			];
		},
	};

	/** Section Class **/
	//{
	function Section(x, y, z, size, chunk) {
		this.x = x;
		this.y = y;
		this.z = z;
		this.size = size;
		this.arraySize = size * size * size;
		this.blocks = newInt32Array(this.arraySize);
		this.renderData = [];
		this.renderLength = 0;
		this.faces = 0;
		this.hasVisibleBlocks = false;
		this.chunk = chunk;
		this.edited = false;
		this.caves = false;
	}
	Section.prototype.getBlock = function(x, y, z) {
		let s = this.size;
		return this.blocks[x * s * s + y * s + z] & 0xff;
	};
	Section.prototype.setBlock = function(x, y, z, blockID, hidden) {
		let s = this.size;
		this.blocks[x * s * s + y * s + z] = !hidden << 31 | blockID;
	};
	Section.prototype.deleteBlock = function(x, y, z) {
		let s = this.size;
		let data = this.blocks[x * s * s + y * s + z];
		let index = this.renderData.indexOf(data);
		if (index >= 0 && index < this.renderLength) {
			this.renderData.splice(index, 1);
			this.renderLength--;
			this.hasVisibleBlocks = !!this.renderLength;
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk);
			}
		}
		this.blocks[x * s * s + y * s + z] = blockIds.air;
	};
	Section.prototype.optimize = function(world) {
		let visible = false;
		let pos = 0;
		let xx = this.x;
		let yy = this.y;
		let zz = this.z;
		let blockData = 0;
		let blockType = 0;
		let index = 0;
		let s = this.size;
		let blocks = this.blocks;
		this.hasVisibleBlocks = false;
		this.renderLength = 0;
		let localBlocks = world.getAdjacentSubchunks(xx, yy, zz);

		//Check all the blocks in the subchunk to see if they're visible.
		for (let i = 0; i < s; i++) {
			for (let j = 0; j < s; j++) {
				for (let k = 0; k < s; k++, index++) {
					blockData = blocks[index];
					if (blockData >= 0) {
						continue;
					}
					blockType = blockData & 0xff;
					// x = i + xx;
					// y = j + yy;
					// z = k + zz;
					visible = hideFace(i-1, j, k, localBlocks, blockType, getBlock)
					| hideFace(i+1, j, k, localBlocks, blockType, getBlock) << 1
					| hideFace(i, j-1, k, localBlocks, blockType, getBlock) << 2
					| hideFace(i, j+1, k, localBlocks, blockType, getBlock) << 3
					| hideFace(i, j, k-1, localBlocks, blockType, getBlock) << 4
					| hideFace(i, j, k+1, localBlocks, blockType, getBlock) << 5;
					if (visible) {
						pos = (i | j << 4 | k << 8) << 16;
						blockData = 1 << 31 | pos | visible << 8 | blockType;
						this.renderData[this.renderLength++] = blockData;
						blocks[index] = blockData;
						this.hasVisibleBlocks = true;
					} else {
						blocks[index] = blockType;
					}
				}
			}
		}
	};
	Section.prototype.updateBlock = function(x, y, z, world) {
		let i = x;
		let j = y;
		let k = z;
		let s = this.size;
		x += this.x;
		y += this.y;
		z += this.z;
		let blockData = this.blocks[i * s * s + j * s + k];
		let blockType = blockData & 0xff;
		let visible = blockType && hideFace(x-1, y, z, 0, blockType, world.getBlock)
		| hideFace(x+1, y, z, 0, blockType, world.getBlock) << 1
		| hideFace(x, y-1, z, 0, blockType, world.getBlock) << 2
		| hideFace(x, y+1, z, 0, blockType, world.getBlock) << 3
		| hideFace(x, y, z-1, 0, blockType, world.getBlock) << 4
		| hideFace(x, y, z+1, 0, blockType, world.getBlock) << 5;
		let pos = (i | j << 4 | k << 8) << 16;
		let index = blockData < 0 ? this.renderData.indexOf(blockData) : -1;

		if ((index < 0 || index >= this.renderLength) && !visible) {
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk);
			}
			return;
		}
		if (!visible) {
			this.renderData.splice(index, 1);
			this.blocks[i * s * s + j * s + k] = blockType; //Toggle invisible bit
			this.renderLength--;
			this.hasVisibleBlocks = !!this.renderLength;
			if (!world.meshQueue.includes(this.chunk)) {
				world.meshQueue.push(this.chunk);
			}
			this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
			this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
			return;
		}
		if (visible && (index < 0 || index >= this.renderLength)) {
			index = this.renderLength++;
			this.hasVisibleBlocks = true;
		}
		this.chunk.minY = y < this.chunk.minY ? y : this.chunk.minY;
		this.chunk.maxY = y > this.chunk.maxY ? y : this.chunk.maxY;
		this.renderData[index] = 1 << 31 | pos | visible << 8 | blockData & 0xff;
		this.blocks[i * s * s + j * s + k] = this.renderData[index];
		if (!world.meshQueue.includes(this.chunk)) {
			world.meshQueue.push(this.chunk);
		}
	};
	Section.prototype.genMesh = function(barray, index) {
		if (!this.renderLength) {
			return index;
		}
		let length = this.renderLength;
		let rData = this.renderData;
		let x = 0, y = 0, z = 0, loc = 0, data = 0, sides = 0, tex = null, x2 = 0, y2 = 0, z2 = 0, verts = null, texVerts = null;
		let wx = this.x, wy = this.y, wz = this.z;
		let blocks = world.getAdjacentSubchunks(wx, wy, wz);

		let shadows = null;
		let bData = blockData;
		let gShadows = getShadows;
		let sedgeVerts = sideEdgeVerts;
		let tCoords = textureCoords;
		let tmap = textureMap;
		let block = Block;
		let sideMap = Sides;
		let blockSides = Object.keys(block);
		let side = "";
		for (let i = 0; i < length; i++) {
			data = rData[i];
			tex = bData[data & 0xff].textures;
			sides = data >> 8 & 0x3f;
			loc = data >> 16;
			x = loc & 15;
			y = loc >> 4 & 15;
			z = loc >> 8 & 15;

			x2 = x + this.x;
			y2 = y + this.y;
			z2 = z + this.z;

			let texNum = 0;
			for (let n = 0; n < 6; n++) {
				side = blockSides[n];
				if (sides & block[side]) {
					shadows = gShadows[side](x, y, z, blocks);
					verts = sedgeVerts[sideMap[side]];
					texVerts = tCoords[tmap[tex[texNum]]];

					barray[index] = verts[0] + x2;
					barray[index+1] = verts[1] + y2;
					barray[index+2] = verts[2] + z2;
					barray[index+3] = texVerts[0];
					barray[index+4] = texVerts[1];
					barray[index+5] = shadows[0];

					barray[index+6] = verts[3] + x2;
					barray[index+7] = verts[4] + y2;
					barray[index+8] = verts[5] + z2;
					barray[index+9] = texVerts[2];
					barray[index+10] = texVerts[3];
					barray[index+11] = shadows[1];

					barray[index+12] = verts[6] + x2;
					barray[index+13] = verts[7] + y2;
					barray[index+14] = verts[8] + z2;
					barray[index+15] = texVerts[4];
					barray[index+16] = texVerts[5];
					barray[index+17] = shadows[2];

					barray[index+18] = verts[9] + x2;
					barray[index+19] = verts[10] + y2;
					barray[index+20] = verts[11] + z2;
					barray[index+21] = texVerts[6];
					barray[index+22] = texVerts[7];
					barray[index+23] = shadows[3];
					index += 24;
				}
				texNum++;
			}
		}
		return index;
	};
	Section.prototype.carveCaves = function() {
		let wx = this.x + 16, wz = this.z + 16, wy = this.y + 16;
		for (let x = this.x, xx = 0; x < wx; x++, xx++) {
			for (let z = this.z, zz = 0; z < wz; z++, zz++) {
				wy = this.chunk.tops[zz * 16 + xx];
				for (let y = this.y; y < wy; y++) {
					if (isCave(x, y, z)) {
						carveSphere(x, y, z);
					}
				}
			}
		}
		this.caves = true;
	}
	//}
	function newSection(x, y, z, size, chunk) {
		let section = Object.create(Section.prototype);
		Section.apply(section, [ x, y, z, size, chunk ]);
		return section;
	}
	let emptySection = newSection(0, 0, 0, 16);
	let fullSection = newSection(0, 0, 0, 16);
	fullSection.blocks.fill(blockIds.bedrock);

	/** Chunk Class **/
	//{
	function Chunk(x, z) {
		this.x = x;
		this.z = z;
		this.maxY = 0;
		this.minY = 255;
		this.sections = [];
		this.cleanSections = [];
		this.tops = new Uint8Array(16 * 16); // Store the heighest block at every (x,z) coordinate
		this.optimized = false;
		this.generated = false; //Terrain
		this.populated = false; //Trees
		this.lazy = false;
		this.edited = false;
		this.caves = false;
	}
	Chunk.prototype.getBlock = function(x, y, z) {
		let s = y >> 4;
		return this.sections.length > s ? this.sections[s].getBlock(x, y & 15, z) : 0;
	};
	Chunk.prototype.setBlock = function(x, y, z, blockID, hidden, user) {
		if (!hidden) {
			this.minY = y < this.minY ? y : this.minY;
			this.maxY = y > this.maxY ? y : this.maxY;
			// let top = this.tops[z * 16 + x];
			// this.tops[z * 16 + x] = top < y ? y : top;
		}
		if (!this.sections[y >> 4]) {
			do {
				this.sections.push(newSection(this.x, this.sections.length * 16, this.z, 16, this));
			} while (!this.sections[y >> 4]);
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice();
			this.sections[y >> 4].edited = true;
			this.edited = true;
		}
		this.sections[y >> 4].setBlock(x, y & 15, z, blockID, hidden);
	};
	Chunk.prototype.optimize = function(world) {
		for (let i = 0; i < this.sections.length; i++) {
			this.sections[i].optimize(world);
		}
		if (!world.meshQueue.includes(this)) {
			world.meshQueue.push(this);
		}
		this.optimized = true;
	};
	Chunk.prototype.render = function() {
		if (!this.buffer) {
			return;
		}
		if (chunkVisible(this.x, this.minY, this.z, this.maxY)) {
			renderedChunks++;
			gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
			gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
			gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
			gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
			gl.drawElements(gl.TRIANGLES, 6 * this.faces, gl.UNSIGNED_INT, 0);
		}
	};
	Chunk.prototype.updateBlock = function(x, y, z, world, lazy) {
		if (this.buffer) {
			this.lazy = lazy;
			if (this.sections.length > y >> 4) {
				this.sections[y >> 4].updateBlock(x, y & 15, z, world);
			}
		}
	};
	Chunk.prototype.deleteBlock = function(x, y, z, user) {
		if (!this.sections[y >> 4]) {
			return;
		}
		if (user && !this.sections[y >> 4].edited) {
			this.cleanSections[y >> 4] = this.sections[y >> 4].blocks.slice();
			this.sections[y >> 4].edited = true;
			this.edited = true;
		}
		this.sections[y >> 4].deleteBlock(x, y & 15, z);
		this.minY = y < this.minY ? y : this.minY;
		this.maxY = y > this.maxY ? y : this.maxY;
		// if (y === this.tops[z * 16 + x]) {
		// 	while(--y && !this.getBlock(x, y, z)) {}
		// 	this.tops[z * 16 + x] = y;
		// }
	};
	Chunk.prototype.carveCaves = function() {
		for (let i = 0; i < this.sections.length; i++) {
			if (!this.sections[i].caves) {
				this.sections[i].carveCaves();
				if (i + 1 >= this.sections.length) {
					this.caves = true;
				}
				return;
			}
		}
	};
	Chunk.prototype.populate = function() {
		randomSeed(hash(this.x, this.z) * 210000000);
		let wx = 0, wz = 0, ground = 0, top = 0, rand = 0, place = false;

		for (let i = 0; i < 16; i++) {
			for (let k = 0; k < 16; k++) {
				wx = this.x + i;
				wz = this.z + k;
				ground = this.tops[k * 16 + i];
				if (random() < 0.005 && this.getBlock(i, ground, k)) {

					top = ground + Math.floor(4.5 + random(2.5));
					rand = Math.floor(random(4096));
					let tree = random() < 0.6 ? blockIds.oakLog : ++top && blockIds.birchLog;

					//Center
					for (let j = ground + 1; j <= top; j++) {
						this.setBlock(i, j, k, tree);
					}
					this.setBlock(i, top + 1, k, blockIds.leaves);
					this.setBlock(i, ground, k, blockIds.dirt);

					//Bottom leaves
					for (let x = -2; x <= 2; x++) {
						for (let z = -2; z <= 2; z++) {
							if (x || z) {
								if ((x * z & 7) === 4) {
									place = rand & 1;
									rand >>>= 1;
									if (place) {
										world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
									}
								} else {
									world.spawnBlock(wx + x, top - 2, wz + z, blockIds.leaves);
								}
							}
						}
					}

					//2nd layer leaves
					for (let x = -2; x <= 2; x++) {
						for (let z = -2; z <= 2; z++) {
							if (x || z) {
								if ((x * z & 7) === 4) {
									place = rand & 1;
									rand >>>= 1;
									if (place) {
										world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
									}
								} else {
									world.spawnBlock(wx + x, top - 1, wz + z, blockIds.leaves);
								}
							}
						}
					}

					//3rd layer leaves
					for (let x = -1; x <= 1; x++) {
						for (let z = -1; z <= 1; z++) {
							if (x || z) {
								if (x & z) {
									place = rand & 1;
									rand >>>= 1;
									if (place) {
										world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
									}
								} else {
									world.spawnBlock(wx + x, top, wz + z, blockIds.leaves);
								}
							}
						}
					}

					//Top leaves
					world.spawnBlock(wx + 1, top + 1, wz, blockIds.leaves);
					world.spawnBlock(wx, top + 1, wz - 1, blockIds.leaves);
					world.spawnBlock(wx, top + 1, wz + 1, blockIds.leaves);
					world.spawnBlock(wx - 1, top + 1, wz, blockIds.leaves);
				}

				// Blocks of each per chunk in Minecraft
				// Coal: 185.5
				// Iron: 111.5
				// Gold: 10.4
				// Redstone: 29.1
				// Diamond: 3.7
				// Lapis: 4.1
				ground -= 4;

				if (random() < 3.7 / 256) {
					let y = random() * 16 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.diamondOre);
					}
				}

				if (random() < 111.5 / 256) {
					let y = random() * 64 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.ironOre);
					}
				}

				if (random() < 185.5 / 256) {
					let y = random() * ground | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.coalOre);
					}
				}

				if (random() < 10.4 / 256) {
					let y = random() * 32 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.goldOre);
					}
				}

				if (random() < 29.1 / 256) {
					let y = random() * 16 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.redstoneOre);
					}
				}

				if (random() < 4.1 / 256) {
					let y = random() * 32 | 0 + 1;
					y = y < ground ? y : ground;
					if (this.getBlock(i, y, k)) {
						this.setBlock(i, y < ground ? y : ground, k, blockIds.lapisOre);
					}
				}
			}
		}

		let chunkX = this.x >> 4;
		let chunkZ = this.z >> 4;
		let load = null;
		
		for (let i = 0; i < world.loadFrom.length; i++) {
			load = world.loadFrom[i];
			if (load.x === chunkX && load.z === chunkZ) {
				let y = load.y * 16;
				for (let j in load.blocks) {
					world.setBlock((j >> 8 & 15) + this.x, (j >> 4 & 15) + y, (j & 15) + this.z, load.blocks[j]);
				}
				world.loadFrom.splice(i--, 1);
			}
		}

		this.populated = true;
	};
	Chunk.prototype.genMesh = function() {
		let start = win.performance.now();
		let barray = bigArray;
		let index = 0;
		let g = gl;
		for (let i = 0; i < this.sections.length; i++) {
			index = this.sections[i].genMesh(barray, index);
		}
		let arrayDone = win.performance.now();

		if (!this.buffer) {
			this.buffer = g.createBuffer();
		}
		let data = barray.slice(0, index);
		this.faces = data.length / 24;
		g.bindBuffer(g.ARRAY_BUFFER, this.buffer);
		g.bufferData(g.ARRAY_BUFFER, data, g.DYNAMIC_DRAW);
		this.lazy = false;
		if (arrayDone - start > 3) {
			//console.log((arrayDone - start).toFixed(1), (win.performance.now() - arrayDone).toFixed(1), this.faces, this.sections.length);
		}
	};
	//}
	function newChunk(x, z) {
		let chunk = Object.create(Chunk.prototype);
		Chunk.call(chunk, x, z);
		return chunk;
	}

	let analytics = {
		totalTickTime: 0,
		worstFrameTime: 0,
		totalRenderTime: 0,
		totalFrameTime: 0,
		lastUpdate: 0,
		frames: 1,
		displayedTickTime: "0",
		displayedRenderTime: "0",
		displayedFrameTime: "0",
		displayedwFrameTime: 0,
		fps: 0,
	};
	function sortChunks(c1, c2) { //Sort the list of chunks based on distance from the player
		let dx1 = p.x - c1.x - 8;
		let dy1 = p.z - c1.z - 8;
		let dx2 = p.x - c2.x - 8;
		let dy2 = p.z - c2.z - 8;
		return dx1 * dx1 + dy1 * dy1 - (dx2 * dx2 + dy2 * dy2);
	}
	function optimizeLater(x, z) {
		let chunk = world.chunks[x] ? world.chunks[x][z] : null;
		if (chunk && chunk.buffer && !world.optimizeQueue.includes(chunk)) {
			world.optimizeQueue.push(chunk);
		}
	}

	function debug(message) {
		let ellapsed = performance.now() - debug.start;
		if (ellapsed > 30) {
			//console.log(message, ellapsed.toFixed(2));
		}
	}
	/** World Class **/
	//{
	let genChunk = function(chunk) {
		let x = chunk.x >> 4;
		let z = chunk.z >> 4;
		let trueX = chunk.x;
		let trueZ = chunk.z;

		if (chunk.generated) {
			return false;
		}
		let hide = !loadString;
		let smoothness = generator.smooth;
		let hilliness = generator.height;
		let gen = 0;
		for (let i = 0; i < 16; i++) {
			for (let k = 0; k < 16; k++) {
				gen = Math.round(noise((trueX + i) * smoothness, (trueZ + k) * smoothness) * hilliness) + generator.extra;
				chunk.tops[k * 16 + i] = gen;

				chunk.setBlock(i, gen, k, blockIds.grass);
				chunk.setBlock(i, gen - 1, k, blockIds.dirt);
				chunk.setBlock(i, gen - 2, k, blockIds.dirt);
				chunk.setBlock(i, gen - 3, k, blockIds.dirt);
				for (let j = 1; j < gen - 3; j++) {
					chunk.setBlock(i, j, k, blockIds.stone);
				}
				chunk.setBlock(i, 0, k, blockIds.bedrock);
			}
		}
		chunk.generated = true;
		generatedChunks++;

		optimizeLater(x + 1, z);
		optimizeLater(x - 1, z);
		optimizeLater(x, z + 1);
		optimizeLater(x, z - 1);
	};
	let getAdjacentSubchunks = function(x, y, z) {
		let minChunkX = x - 16 >> 4;
		let maxChunkX = x + 16 >> 4;
		let minChunkY = y - 16 >> 4;
		let maxChunkY = y + 16 >> 4;
		let minChunkZ = z - 16 >> 4;
		let maxChunkZ = z + 16 >> 4;
		let ret = [];
		for (x = minChunkX; x <= maxChunkX; x++) {
			for (let y = minChunkY; y <= maxChunkY; y++) {
				for (z = minChunkZ; z <= maxChunkZ; z++) {
					if (y < 0) {
						ret.push(fullSection.blocks);
					} else if (this.chunks[x] && this.chunks[x][z]) {
						ret.push((this.chunks[x][z].sections[y] || emptySection).blocks);
					} else {
						ret.push(emptySection.blocks);
					}
				}
			}
		}
		return ret;
	};
	let updateBlock = function(x, y, z, lazy) {
		let chunk = this.chunks[x >> 4] && this.chunks[x >> 4][z >> 4];
		if (chunk && chunk.buffer) {
			chunk.updateBlock(x & 15, y, z & 15, this, lazy);
		}
	};
	let getWorldBlock = function(x, y, z) {
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return blockIds.air;
		}
		return this.chunks[x >> 4][z >> 4].getBlock(x & 15, y, z & 15);
	};
	let getLoadedBlock = function(x, y, z) {
		let X = (x >> 4) + this.offsetX;
		let Z = (z >> 4) + this.offsetZ;
		if (y > maxHeight) {
			return blockIds.air;
		} else if (y < 0) {
			return blockIds.bedrock;
		} else if (X < 0 || X >= this.lwidth || Z < 0 || Z >= this.lwidth) {
			return this.getWorldBlock(x, y, z);
		}
		return this.loaded[X * this.lwidth + Z].getBlock(x & 15, y, z & 15);
	};
	let setBlock = function(x, y, z, blockID, lazy) {
		if (!this.chunks[x >> 4] || !this.chunks[x >> 4][z >> 4]) {
			return;
		}
		let chunk = this.chunks[x >> 4][z >> 4];

		let xm = x & 15;
		let zm = z & 15;
		if (blockID) {
			chunk.setBlock(xm, y, zm, blockID, false, !lazy);
		} else {
			chunk.deleteBlock(xm, y, zm, !lazy);
		}



		//Update the 6 adjacent blocks and 1 changed block
		if (xm && xm !== 15 && zm && zm !== 15) {
			chunk.updateBlock(xm - 1, y, zm, this, lazy);
			chunk.updateBlock(xm + 1, y, zm, this, lazy);
			chunk.updateBlock(xm, y - 1, zm, this, lazy);
			chunk.updateBlock(xm, y + 1, zm, this, lazy);
			chunk.updateBlock(xm, y, zm - 1, this, lazy);
			chunk.updateBlock(xm, y, zm + 1, this, lazy);
		}
		else {
			this.updateBlock(x - 1, y, z, lazy);
			this.updateBlock(x + 1, y, z, lazy);
			this.updateBlock(x, y - 1, z, lazy);
			this.updateBlock(x, y + 1, z, lazy);
			this.updateBlock(x, y, z - 1, lazy);
			this.updateBlock(x, y, z + 1, lazy);
		}
		
		chunk.updateBlock(xm, y, zm, this, lazy);

		//Update the corner chunks so shadows in adjacent chunks update correctly
		if (xm | zm === 0) { this.updateBlock(x - 1, y, z - 1, lazy); }
		if (xm === 15 && zm === 0) { this.updateBlock(x + 1, y, z - 1, lazy); }
		if (xm === 0 && zm === 15) { this.updateBlock(x - 1, y, z + 1, lazy); }
		if (xm & zm === 15) { this.updateBlock(x + 1, y, z + 1, lazy); }
	};
	let spawnBlock = function(x, y, z, blockID) {
		//Sets a block anywhere without causing block updates around it. Only to be used in world gen.

		let chunkX = x >> 4;
		let chunkZ = z >> 4;
		if (!this.chunks[chunkX]) {
			this.chunks[chunkX] = [];
		}
		let chunk = this.chunks[chunkX][chunkZ];
		if (!chunk) {
			chunk = newChunk(chunkX * 16, chunkZ * 16);
			this.chunks[chunkX][chunkZ] = chunk;
		}
		if (chunk.buffer) {
			//Only used if spawning a block post-gen
			this.setBlock(x, y, z, blockID, true);
		} else if (!chunk.getBlock(x & 15, y, z & 15)) {
			chunk.setBlock(x & 15, y, z & 15, blockID, false);
		}
	};
	let tick = function() {
		let tickStart = win.performance.now();
		let maxChunkX = (p.x >> 4) + renderDistance;
		let maxChunkZ = (p.z >> 4) + renderDistance;
		let chunk = maxChunkX + "," + maxChunkZ;
		if (chunk !== this.lastChunk) {
			this.lastChunk = chunk;
			this.loadChunks();
			this.chunkGenQueue.sort(sortChunks);
		}

		if (Key.leftMouse && p.lastBreak < Date.now() - 250) {
			changeWorldBlock(0);
		}
		if ((Key.rightMouse || Key.leftMouse && Key.control) && p.lastPlace < Date.now() - 250) {
			newWorldBlock();
		}
		if (Key.leftMouse && p.autoBreak && !Key.control) {
			changeWorldBlock(0);
		}

		do {
			let doneWork = false;
			debug.start = performance.now();
			if (this.meshQueue.length) {
				// Update all chunk meshes.
				let len = this.meshQueue.length - 1;
				do {
					this.meshQueue.pop().genMesh();
				} while(this.meshQueue.length);
				doneWork = true;
				debug("Meshes")
			}

			if (this.chunkGenQueue.length && !doneWork) {
				do {
					let chunk = this.chunkGenQueue[0];
					if (!chunk.generated) {
						this.genChunk(chunk);
						debug("Gen chunk")
					} else if (!chunk.caves) {
						chunk.carveCaves();
						debug("Carve caves")
					} else if (!chunk.populated) {
						chunk.populate();
						debug("Populate")
					} else if (!chunk.optimized) {
						chunk.optimize(this);
						debug("Optimize")
					} else if (!chunk.buffer) {
						chunk.genMesh();
						debug("Initial mesh")
					} else {
						this.chunkGenQueue.shift();
						if(this.chunkGenQueue.length) {
							continue;
						}
					}
					break;
				} while(this.chunkGenQueue.length);
				doneWork = !!this.chunkGenQueue.length;
			}
			if (this.optimizeQueue.length && !doneWork) {
				this.optimizeQueue.shift().optimize(this);
				debug("Re optimize")
				doneWork = true;
			}
			if (!doneWork) {
				break;
			}
		} while(win.performance.now() - tickStart < 5);
	};
	let render = function() {
		initModelView(p.x, p.y, p.z, p.rx, p.ry);

		p2.x = Math.round(p.x);
		p2.y = Math.round(p.y);
		p2.z = Math.round(p.z);

		renderedChunks = 0;
		gl.enableVertexAttribArray(glCache.locations.aShadow);

		let c = this.sortedChunks;
		let lx = p.direction.x;
		let ly = p.direction.y;
		let lz = p.direction.z;
		let nlx = lx < 0 ? 0 : 16;
		let nly = ly < 0;
		let nlz = lz < 0 ? 0 : 16;
		let x = p.x;
		let y = p.y;
		let z = p.z;
		let dx = 0, dy = 0, dz = 0;
		let chunk = null;
		for (let i = 0, l = c.length; i < l; i++) {
			chunk = c[i];
			dx = chunk.x - x + nlx;
			dy = (nly ? chunk.minY : chunk.maxY) - y;
			dz = chunk.z - z + nlz;
			if (dx * lx + dy * ly + dz * lz > 0) {
				chunk.render();
			}
		}

		if(hitBox.pos) {
			blockOutlines = true;
			blockFill = false;
			block2(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2], 0);
			blockOutlines = false;
			blockFill = true;
		}
		gl.flush();
	};
	let loadChunks = function() {
		let minChunkX = (p.x >> 4) - renderDistance;
		let maxChunkX = (p.x >> 4) + renderDistance;
		let minChunkZ = (p.z >> 4) - renderDistance;
		let maxChunkZ = (p.z >> 4) + renderDistance;

		this.offsetX = -minChunkX;
		this.offsetZ = -minChunkZ;
		this.lwidth = renderDistance * 2 + 1;

		if (this.loaded.length > this.lwidth * this.lwidth) {
			this.loaded.length = this.lwidth * this.lwidth;
		}

		let i = 0;
		for (let x = minChunkX; x <= maxChunkX; x++) {
			for (let z = minChunkZ; z <= maxChunkZ; z++) {
				let chunk;
				if (!this.chunks[x]) {
					this.chunks[x] = [];
				}
				if (!this.chunks[x][z]) {
					chunk = newChunk(x * 16, z * 16);
					this.chunkGenQueue.push(chunk);
					this.chunks[x][z] = chunk;
				}
				chunk = this.chunks[x][z];
				if (!chunk.generated && !this.chunkGenQueue.includes(chunk)) {
					this.chunkGenQueue.push(chunk);
				}
				this.loaded[i++] = chunk;
			}
		}
		this.sortedChunks = this.loaded.slice();
		this.sortedChunks.sort(sortChunks);
	};
	function getSaveString() {
		let edited = [];
		for (let x in this.chunks) {
			for (let z in this.chunks[x]) {
				let chunk = this.chunks[x][z];
				if (chunk.edited) {
					for (let y = 0; y < chunk.sections.length; y++) {
						if (chunk.sections[y].edited) {
							edited.push([ chunk.sections[y], chunk.cleanSections[y] ]);
						}
					}
				}
			}
		}

		let str = worldSeed.toString(36) + ";"
			+ Math.round(p.x).toString(36) + "," + Math.round(p.y).toString(36) + "," + Math.round(p.z).toString(36) + ","
			+ (p.rx * 100 | 0).toString(36) + "," + (p.ry * 100 | 0).toString(36) + ";"
			+ edited.length.toString(36) + ";";
		for (let i = 0; i < edited.length; i++) {
			let sc = edited[i][0];
			str += (sc.x / 16).toString(36) + ",";
			str += (sc.y / 16).toString(36) + ",";
			str += (sc.z / 16).toString(36) + ",";
		}
		str = str.substr(0, str.length - 1) + ";"; //Remove trailing comma

		for (let i = 0; i < edited.length; i++) {
			let real = edited[i][0];
			let blocks = real.blocks;
			let original = edited[i][1];
			for (let j = 0; j < original.length; j++) {
				if ((blocks[j] & 0xff) !== (original[j] & 0xff)) {
					str += (j << 8 | blocks[j] & 0xff).toString(36) + ",";
				}
			}
			str = str.substr(0, str.length - 1) + ";";
		}
		str = str.substr(0, str.length - 1);
		return str;
	}
	function loadSave(str) {
		let data = str.split(";");
		worldSeed = parseInt(data.shift(), 36);
		seedHash(worldSeed);
		caveNoise = openSimplexNoise(worldSeed);
		noiseSeed(worldSeed);
		let playerData = data.shift().split(",");
		p.x = parseInt(playerData[0], 36);
		p.y = parseInt(playerData[1], 36);
		p.z = parseInt(playerData[2], 36);
		p.rx = parseInt(playerData[3], 36) / 100;
		p.ry = parseInt(playerData[4], 36) / 100;
		let editCount = parseInt(data.shift(), 36);

		this.loadFrom = [];

		let coords = data.shift().split(",").map(function(n) {
			return parseInt(n, 36);
		});
		for (let j = 0; j < coords.length; j += 3) {
			this.loadFrom.push({
				x: coords[j],
				y: coords[j + 1],
				z: coords[j + 2],
				blocks: [],
			})
		}

		for (let i = 0; data.length > 0; i++) {
			let blocks = data.shift().split(",");
			for (let j = 0; j < blocks.length; j++) {
				let block = parseInt(blocks[j], 36);
				let index = block >> 8;
				let id = block & 0xff;
				this.loadFrom[i].blocks[index] = id;
			}
		}
	}
	//}
	function World() {
	//Initialize the world's arrays
		let loaded = [];
		let chunks = [];
		let queue = [];
		let lwidth = renderDistance * 2 + 1;
		let cx = renderDistance - (p.x >> 4);
		let cz = renderDistance - (p.z >> 4);
		let i = 0;
		for (let x = 0; x < lwidth; x++) {
			chunks[x - cx] = [];
			for (let z = 0; z < lwidth; z++) {
				let chunk = newChunk((x - cx) * 16, (z - cz) * 16);
				loaded[i++] = chunk;
				chunks[x - cx][z - cz] = chunk;
				queue.push(chunk);
			}
		}
		queue.sort(sortChunks);
		let sorted = queue.slice();
		return {
			chunks: chunks,
			loaded: loaded,
			sortedChunks: sorted,
			offsetX: cx,
			offsetZ: cz,
			lwidth: lwidth,
			chunkGenQueue: queue,
			optimizeQueue: [],
			meshQueue: [],
			loadFrom: [],
			lastChunk: cx + "," + cz,
			genChunk: genChunk,
			getAdjacentSubchunks: getAdjacentSubchunks,
			updateBlock: updateBlock,
			getBlock: getLoadedBlock,
			getWorldBlock: getWorldBlock,
			setBlock: setBlock,
			spawnBlock: spawnBlock,
			tick: tick,
			render: render,
			loadChunks: loadChunks,
			getSaveString: getSaveString,
			loadSave: loadSave,
		};
	}

	let defineWorld = function() {
		let tickStart = win.performance.now();
		world.tick();
		analytics.totalTickTime += win.performance.now() - tickStart;
		let renderStart = win.performance.now();
		world.render();
		analytics.totalRenderTime += win.performance.now() - renderStart;
	};

	let controls = function() {
		move.x = 0;
		move.z = 0;
		let dt = (win.performance.now() - p.lastUpdate) / 33;
		dt = dt > 2 ? 2 : dt;
		if(Key.w) {
			move.z += p.speed;
		}
		if(Key.s) {
			move.z -= p.speed;
		}
		if(Key.a) {
			move.x += p.speed;
		}
		if(Key.d) {
			move.x -= p.speed;
		}
		if (p.flying) {
			if(Key[" "]) {
				p.velocity.y += 0.06 * dt;
			}
			if(Key.shift) {
				p.velocity.y -= 0.06 * dt;
			}
		}
		if(Key.arrowleft) {
			p.ry -= 0.1 * dt;
		}
		if(Key.arrowright) {
			p.ry += 0.1 * dt;
		}
		if(Key.arrowup) {
			p.rx += 0.1 * dt;
		}
		if(Key.arrowdown) {
			p.rx -= 0.1 * dt;
		}

		if (Key.q) {
			p.sprinting = true;
		}

		if(p.sprinting) {
			move.x *= p.sprintSpeed;
			move.z *= p.sprintSpeed;
		}
		if(p.flying) {
			move.x *= p.flySpeed;
			move.z *= p.flySpeed;
		}
		if (!move.x && !move.z) {
			p.sprinting = false;
		} else if(Math.abs(move.x) > 0 && Math.abs(move.z) > 0) {
			move.x *= move.ang;
			move.z *= move.ang;
		}
		//Update the velocity, rather than the position.
		let co = Math.cos(p.ry);
		let si = Math.sin(p.ry);
		let friction = p.onGround ? 1 : 0.3;
		p.velocity.x += (co * move.x - si * move.z) * friction * dt;
		p.velocity.z += (si * move.x + co * move.z) * friction * dt;

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2;
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2;
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2;
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2;
		}

		p.direction.set(-si * Math.cos(p.rx), Math.sin(p.rx), co * Math.cos(p.rx));
		computeFrustum();
	};

	//Disable scroll
	(function() {
		let preventDefault = function(e) {
			e.preventDefault();
			if (e.deltaY > 0) {
				inventory.hotbarSlot++;
			} else if (e.deltaY < 0) {
				inventory.hotbarSlot--;
			}
			if (inventory.hotbarSlot > 8) {
				inventory.hotbarSlot = 0;
			} else if (inventory.hotbarSlot < 0) {
				inventory.hotbarSlot = 8;
			}

			updateHUD = true;
			holding = inventory.hotbar[inventory.hotbarSlot];
		};

		let keys = { 32: 1, 37: 1, 38: 1, 39: 1, 40: 1 };

		function preventDefaultForScrollKeys(e) {
			if (keys[e.keyCode]) {
				e.preventDefault();
				return false;
			}
		}

		// modern Chrome requires { passive: false } when adding event
		let supportsPassive = false;
		try {
			window.addEventListener("test", null, Object.defineProperty({}, 'passive', {
				get: function () {
					supportsPassive = true;
				},
			}));
		} catch(e) {}

		let wheelOpt = supportsPassive ? { passive: false } : false;
		let wheelEvent = 'onwheel' in document.createElement('div') ? 'wheel' : 'mousewheel';

		// call this to Disable
		function disableScroll() {
			window.addEventListener('DOMMouseScroll', preventDefault, false); // older FF
			window.addEventListener(wheelEvent, preventDefault, wheelOpt); // modern desktop
			window.addEventListener('touchmove', preventDefault, wheelOpt); // mobile
			window.addEventListener('keydown', preventDefaultForScrollKeys, false);
		}

		disableScroll();
	})();

	let buttons = [];
	let button = function(x, y, w, h) {
		if(mouseX > x && mouseY > y && mouseX < x + w && mouseY < y + h) {
			return true;
		} else {
			return false;
		}
	};
	let addButton = function(x, y, w, h, text, callback, screen) {
		buttons.push({
			x: x,
			y: y,
			w: w,
			h: h,
			text: text,
			callback: callback,
			screen: screen,
		});
	};
	let clickButton = function(button) {
		if (screen === button.screen && mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
			button.callback();
		}
	};
	let drawButton = function(button) {
		if (screen === button.screen) {
			if (mouseX > button.x && mouseY > button.y && mouseX < button.x + button.w && mouseY < button.y + button.h) {
				strokeWeight(3);
				cursor(HAND);
			} else {
				strokeWeight(1);
			}
			ctx.strokeStyle = "black";
			ctx.fillStyle = "rgb(92, 92, 92)";
			ctx.rect(button.x, button.y, button.w, button.h);
			ctx.stroke();
			ctx.fill();
			ctx.beginPath();
			ctx.fillStyle = "black";
			textSize(35);
			ctx.font = '35px Sans-Serif';
			ctx.textAlign = 'center';
			ctx.fillText(button.text, button.x + button.w / 2, button.y + button.h / 2 + 10);
		}
	};

	var initEverything;
	//Buttons
	{
		addButton(width / 2 - 150, height / 2 - 45, 300, 50, "Play", function() {
			play();
		}, "main menu");
		addButton(width / 2 - 150, height / 2 + 25, 300, 50, "Options", function() {
			screen = "options menu";
		}, "main menu");
		addButton(width / 2 - 150, height / 2 - -90, 300, 50, "Load Save", function() {
			scode();
		}, "main menu");
		addButton(width / 2 - 150, 125, 300, 50, "Resume", function() {
			play();
		}, "pause");
		addButton(width / 2 - 150, 195, 300, 50, "Options", function() {
			screen = "pause options";
		}, "pause");
		addButton(width / 2 - 150, 265, 300, 50, "Toggle Save Code", function() {
			if (savebox.hidden) {
				savebox.hidden = false;
				savebox.value = world.getSaveString();
			} else {
				savebox.hidden = true;
			}
		}, "pause");
		addButton(width / 2 - 150, 335, 300, 50, "Exit to Main Menu", function() {
			screen = "main menu";
		}, "pause");
		addButton(width / 2 - 150, 195, 300, 50, "Back", function() {
			screen = "main menu";
		}, "options menu");
		addButton(width / 2 - 150, 195, 300, 50, "Back", function() {
			screen = "pause";
		}, "pause options");
	}

	function initTextures() {
		let textureSize = 256;
		let texturePixels = newUint8Array(textureSize * textureSize * 4);
		textureMap = {};
		textureCoords = [];

		setPixel = function(textureNum, x, y, r, g, b, a) {
			let texX = textureNum & 15;
			let texY = textureNum >> 4;
			let offset = (texY * 16 + y) * 1024 + texX * 64 + x * 4;
			texturePixels[offset] = r;
			texturePixels[offset + 1] = g;
			texturePixels[offset + 2] = b;
			texturePixels[offset + 3] = a !== undefined ? a : 255;
		};
		getPixels = function(str) {
			// var w = parseInt(str.substr(0, 2), 36);
			// var h = parseInt(str.substr(2, 2), 36);
			var colors = [];
			var pixels = [];
			var dCount = 0;
			for (;str[4+dCount]==="0";dCount++) {}
			var ccount = parseInt(str.substr(4+dCount, dCount+1), 36);
			for (var i = 0; i < ccount; i++) {
				var num = parseInt(str.substr(5 + 2*dCount + i * 7, 7), 36);
				colors.push([ num >>> 24 & 255, num >>> 16 & 255, num >>> 8 & 255, num & 255 ]);
			}
			for (let i = 5 + 2*dCount + ccount * 7; i < str.length; i++) {
				let num = parseInt(str[i], 36);
				pixels.push(colors[num][0], colors[num][1], colors[num][2], colors[num][3]);
			}
			return pixels;
		};


		(function() {
		//Specify the texture coords for each index
			for (let i = 0; i < 256; i++) {
				let texX = i & 15;
				let texY = i >> 4;
				let offsetX = texX * 0.0625;
				let offsetY = texY * 0.0625;
				textureCoords.push(newFloat32Array([ 0.0625 + offsetX, offsetY, offsetX, offsetY, offsetX, 0.0625 + offsetY, 0.0625 + offsetX, 0.0625 + offsetY ]));
			}

			//Set all of the textures into 1 big tiled texture
			let n = 0;
			for (let i in textures) {
				if (typeof textures[i] === "function") {
					textures[i](n);
				} else if (typeof textures[i] === "string") {
					let pix = getPixels(textures[i]);
					for (let j = 0; j < pix.length; j += 4) {
						setPixel(n, j >> 2 & 15, j >> 6, pix[j], pix[j+1], pix[j+2], pix[j+3]);
					}
				}
				textureMap[i] = n;
				n++;
			}

			//Set the hitbox texture to 1 pixel
			for (let i = 0; i < 8; i += 2) {
				textureCoords[textureMap.hitbox][i] = textureCoords[textureMap.hitbox][2] + 0.01;
				textureCoords[textureMap.hitbox][i + 1] = textureCoords[textureMap.hitbox][1] + 0.01;
			}
		})();

		tex = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, tex);
		gl.activeTexture(gl.TEXTURE0);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureSize, textureSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels);
		gl.generateMipmap(gl.TEXTURE_2D);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.uniform1i(glCache.locations.uSampler, 0);

		genIcons();
	}
	function drawIcon(x, y, id) {
		x =  x / (3 * height) - 0.1666 * width / height;
		y = y / (3 * height) - 0.1666;
		initModelView(x, y, 0, 0, 0);

		let buffer = blockIcons[id];
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.vertexAttribPointer(glCache.locations.aVertex, 3, gl.FLOAT, false, 24, 0);
		gl.vertexAttribPointer(glCache.locations.aTexture, 2, gl.FLOAT, false, 24, 12);
		gl.vertexAttribPointer(glCache.locations.aShadow, 1, gl.FLOAT, false, 24, 20);
		gl.drawElements(gl.TRIANGLES, 6 * 3, gl.UNSIGNED_INT, 0);
	}

	function hotbar() {
		let before = currentFov;
		FOV(90);

		for(let i = 0; i < inventory.hotbar.length; i ++) {
			if(inventory.hotbar[i]) {
				let x = width / 2 - inventory.hotbar.length / 2 * inventory.size + (i + 0.5) * inventory.size + 25;
				let y = height - inventory.size;
				drawIcon(x, y, inventory.hotbar[i]);
			}
		}

		FOV(before);
	}
	function hud() {
		let s = inventory.size;
		let x = width / 2 + 0.5;
		let y = height / 2 + 0.5;

		ctx.lineWidth = 1;
		ctx.strokeStyle = "white";
		ctx.beginPath();

		ctx.moveTo(x - 10, y);
		ctx.lineTo(x + 10, y);
		ctx.moveTo(x, y - 10);
		ctx.lineTo(x, y + 10);
		ctx.stroke();

		//Hotbar
		x = width / 2 - 9 / 2 * s + 0.5 + 25;
		y = height - s * 1.5 + 0.5;

		ctx.strokeStyle = "black";
		ctx.lineWidth = 2;
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.lineTo(x + s * 9, y);
		ctx.moveTo(x, y + s);
		ctx.lineTo(x + s * 9, y + s);
		for(let i = 0; i <= 9; i++) {
			ctx.moveTo(x + i * s, y);
			ctx.lineTo(x + i * s, y + s);
		}
		ctx.stroke();

		ctx.strokeStyle = "white";
		ctx.lineWidth = 2;
		ctx.beginPath();

		ctx.strokeRect(width / 2 - 9 / 2 * s + inventory.hotbarSlot * s + 25, height - s * 1.5, s, s);

		let str = "Average Frame Time: " + analytics.displayedFrameTime + "ms\n"
		+ "Worst Frame Time: " + analytics.displayedwFrameTime + "ms\n"
		+ "Render Time: " + analytics.displayedRenderTime + "ms\n"
		+ "Tick Time: " + analytics.displayedTickTime + "ms\n"
		+ "Rendered Chunks: " + renderedChunks.toLocaleString() + " / " + world.loaded.length + "\n"
		+ "Generated Chunks: " + generatedChunks.toLocaleString() + "\n"
		+ "FPS: " + analytics.fps;

		if (p.autoBreak) {
			fastText("Super breaker enabled", 5, height - 89, 12);
		}

		ctx.textAlign = 'right';
		fastText(p2.x + ", " + p2.y + ", " + p2.z, width - 10, 15, 0);
		ctx.textAlign = 'left';
		fastText(str, 5, height - 77, 12);
	}
	function drawInv() {
		let x = 0;
		let y = 0;
		let s = inventory.size;
		let s2 = s / 2;
		let before = currentFov;
		let perRow = 13;

		//I don't know why, but this is barely transparent, so the gray bleeds through
		gl.clearColor(0.5, 0.5, 0.5, 0.0);
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
		ctx.fillStyle = "rgb(127, 127, 127)";
		ctx.fillRect(0, 0, canvas.width, canvas.height);
		FOV(90);

		// Draw the grid
		ctx.lineWidth = 1;
		ctx.strokeStyle = "black";
		ctx.beginPath();
		for (y = 0; y < 10; y++) {
			ctx.moveTo(50.5 - s2, 50.5 - s2 + y * s);
			ctx.lineTo(50.5 - s2 + s * perRow, 50.5 - s2 + y * s);
		}
		y--;
		for (x = 0; x < perRow + 1; x++) {
			ctx.moveTo(50.5 - s2 + s * x, 50.5 - s2);
			ctx.lineTo(50.5 - s2 + s * x, 50.5 - s2 + y * s);
		}

		// Hotbar
		x = width / 2 - inventory.hotbar.length / 2 * s + 0.5 + 25;
		y = height - s * 1.5 + 0.5;
		ctx.moveTo(x, y);
		ctx.lineTo(x + s * 9, y);
		ctx.moveTo(x, y + s);
		ctx.lineTo(x + s * 9, y + s);
		for(let i = 0; i <= inventory.hotbar.length; i ++) {
			ctx.moveTo(x + i * s, y);
			ctx.lineTo(x + i * s, y + s);
		}
		ctx.stroke();

		let overHot = (mouseX - x) / s | 0;
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			x += s * overHot;
			ctx.lineWidth = 2;
			ctx.strokeStyle = "white";
			ctx.beginPath();
			ctx.strokeRect(x, y, s, s);
		}

		//Box highlight in inv
		let overInv = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
		if (overInv >= 0 && overInv < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			x = overInv % perRow * s + 50 - s2;
			y = (overInv / perRow | 0) * s + 50 - s2;
			ctx.lineWidth = 2;
			ctx.strokeStyle = "white";
			ctx.beginPath();
			ctx.strokeRect(x, y, s, s);
		}

		if (inventory.holding) {
			drawIcon(mouseX, mouseY, inventory.holding);
		}
		for (let i = 1; i < blockData.length; i++) {
			x = (i - 1) % perRow * s + 50;
			y = ((i - 1) / perRow | 0) * s + 50;
			drawIcon(x, y, i);
		}

		hotbar();
		//hud();
		ctx.drawImage(gl.canvas, 0, 0);

		FOV(before);
	}
	function clickInv() {
		let s = inventory.size;
		let s2 = s / 2;
		let perRow = 13;
		let over = Math.round((mouseY - 50) / s) * perRow + Math.round((mouseX - 50) / s);
		let x = width / 2 - 9 / 2 * s + 25;
		let y = height - s * 1.5;
		let overHot = (mouseX - x) / s | 0;
		if (mouseX < x + 9 * s && mouseX > x && mouseY > y && mouseY < y + s) {
			let temp = inventory.hotbar[overHot];
			inventory.hotbar[overHot] = inventory.holding;
			inventory.holding = temp;
		} else if (over >= 0 && over < blockData.length - 1 && mouseX < 50 - s2 + perRow * s && mouseX > 50 - s2) {
			inventory.holding = over + 1;
		} else {
			inventory.holding = 0;
		}
	}

	let unpauseDelay = 0;
	function mmoved(e) {
		p.rx -= e.movementY / 300;
		p.ry += e.movementX / 300;

		while(p.ry > Math.PI*2) {
			p.ry -= Math.PI*2;
		}
		while(p.ry < 0) {
			p.ry += Math.PI*2;
		}
		if(p.rx > Math.PI / 2) {
			p.rx = Math.PI / 2;
		}
		if(p.rx < -Math.PI / 2) {
			p.rx = -Math.PI / 2;
		}
	}
	function trackMouse(e) {
		mouseX = e.x;
		mouseY = e.y;
	}
	document.onmousemove = trackMouse;
	document.onpointerlockchange = function() {
		if (doc.pointerLockElement === canvas) {
			doc.onmousemove = mmoved;
		} else {
			doc.onmousemove = trackMouse;
			if (screen === "play" && !freezeFrame) {
				screen = "pause";
				unpauseDelay = Date.now() + 1000;
			}
		}
		for (let key in Key) {
			Key[key] = false;
		}
	};
	canvas.onmousedown = function(e) {
		mouseX = e.x;
		mouseY = e.y;
		switch(e.button) {
			case 0:
				Key.leftMouse = true;
				break;
			case 1:
				Key.middleMouse = true;
				inventory.hotbar[inventory.hotbarSlot] = world.getBlock(hitBox.pos[0], hitBox.pos[1], hitBox.pos[2]);
				break;
			case 2:
				Key.rightMouse = true;
				break;
		}
		if(screen === "play") {
			if (doc.pointerLockElement !== canvas) {
				getPointer();
				p.lastBreak = Date.now();
			} else {
				place = false;
				if(e.button === 0) {
					if(Key.control) {
						place = true;
					} else {
						changeWorldBlock(0);
					}
				}
				holding = inventory.hotbar[inventory.hotbarSlot];
				if(e.button === 2 && holding) {
					place = true;
				}
				if(place) {
					newWorldBlock();
				}
			}
		} else if (screen === "inventory") {
			clickInv();
		} else if(screen === "options menu") {
			if(button(0, 125, 50, 50)) {
				if(renderDistance > 1) {
					renderDistance--;
				}
			}
			if(button(width - 50, 125, 50, 50)) {
				renderDistance++;
			}
		} else if(screen === "pause options") {
			if(button(0, 125, 50, 50)) {
				if(renderDistance > 1) {
					renderDistance --;
				}
			}
			if(button(width - 50, 125, 50, 50)) {
				renderDistance ++;
			}
		}
		let currentScreen = screen;
		for (let i = 0; i < buttons.length; i++) {
			if (buttons[i].screen === currentScreen) {
				clickButton(buttons[i]);
			}
		}
	};
	canvas.onmouseup = function(e) {
		switch(e.button) {
			case 0:
				Key.leftMouse = false;
				break;
			case 1:
				Key.middleMouse = false;
				break;
			case 2:
				Key.rightMouse = false;
				break;
		}
	};
	document.onkeydown = function(e) {
		if (e.repeat || Key[e.key.toLowerCase()]) {
			return;
		}
		let k = e.key.toLowerCase();
		Key[k] = true;
		if (k === "delete") {
			initEverything();
			releasePointer();
		}

		if (k === "t") {
			initTextures();
		}

		if (screen === "play") {
			if(k === "p") {
				releasePointer();
				screen = "pause";
			}

			if(k === "b") {
				p.autoBreak = !p.autoBreak;
			}

			if (k === " ") {
				if (Date.now() < p.lastJump + 400) {
					p.flying ^= true;
				} else {
					p.lastJump = Date.now();
				}
			}

			if (k === "z") {
				FOV(10);
			}

			if (k === "x") { //Quake Pro lol
				FOV(110);
			}

			if (k === "e") {
				screen = "inventory";
				releasePointer();
			}

			if (k === ";") {
				releasePointer();
				// ctx.clearRect(0, 0, canvas.width, canvas.height);
				// ctx.drawImage(gl.canvas, 0, 0);
				// hud();
				// updateHUD = false;
				freezeFrame = true;
			// analytics.lastUpdate = Date.now() + 10000;
			}

			if(Number(k)) {
				inventory.hotbarSlot = Number(k) - 1;
				holding = inventory.hotbar[inventory.hotbarSlot];
				updateHUD = true;
			}
		} else if (screen === "pause") {
			if(k === "p") {
				play();
			}
		} else if (screen === "inventory") {
			if (k === "e") {
				play();
			}
		}

	};
	document.onkeyup = function(e) {
		let k = e.key.toLowerCase();
		Key[k] = false;
		if(k === "escape" && (screen.includes("pause") || screen === "inventory") && Date.now() > unpauseDelay) {
			play();
		}
		if (screen === "play") {
			if (k === "z") {
				FOV(fov);
			}
		}
	};
	canvas.onblur = function() {
		for (let key in Key) {
			Key[key] = false;
		}
	}
	canvas.oncontextmenu = function(e) {
		e.preventDefault();
	}

	function initEverything() {
		console.log("Initializing world.");

		worldSeed = Math.random() * 2000000000 | 0;

		seedHash(worldSeed);
		caveNoise = openSimplexNoise(worldSeed);
		noiseSeed(worldSeed);

		renderDistance = 4;
		generatedChunks = 0;

		screen = "main menu";
		p = {
			speed: 0.075,
			velocity: new PVector(0, 0, 0),
			direction: new PVector(0, 0, 0),
			sprintSpeed: 1.5,
			flySpeed: 2.5,
			x: 8,
			y: Math.round(noise(8 * generator.smooth, 8 * generator.smooth) * generator.height) + 2 + generator.extra,
			z: 8,
			w: 3 / 8,
			bottomH: 1.62,
			topH: 0.18,
			rx: random(-0.5),
			ry: random(7),
			onGround: false,
			jumpSpeed: 0.3,
			sprinting: false,
			maxYVelocity: 1.5,
			gravityStength: -0.032,
			lastUpdate: win.performance.now(),
			lastBreak: Date.now(),
			lastPlace: Date.now(),
			lastJump: Date.now(),
			autoBreak: false,
			flying: false,
			frustum: [],
		};
		for (let i = 0; i < 4; i++) {
			p.frustum[i] = new Plane();
		}
		world = World();
		win.world = world;
		if (loadString) {
			world.loadSave(loadString);
		}
		win.player = p;
		win.p2 = p2;

		if (!win.gl) {
			let canv = document.createElement('canvas');
			canv.width = ctx.canvas.width;
			canv.height = ctx.canvas.height;
			canv.style.position = "absolute";
			canv.style.zIndex = -1;
			canv.style.top = "0px";
			canv.style.left = "0px";
			// var ctxNames = ['experimental-webgl', 'webgl', 'webkit-3d'];
			// for (var i=0, l=ctxNames.length; i<l; i++) {
			//	 gl = canv.getContext(ctxNames[i], {antialias: false});
			//	 if (gl) {
			//		 break;
			//	 }
			// }
			gl = canv.getContext("webgl", { preserveDrawingBuffer: true, antialias: false, premultipliedAlpha: false });
			let ext = gl.getExtension('OES_element_index_uint');
			if (!ext) {
				alert("Please use a supported browser, or update your current browser.")
			}
			gl.viewport(0, 0, canv.width, canv.height);
			gl.enable(gl.DEPTH_TEST);
			gl.enable(gl.BLEND);
			gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
			win.gl = gl;
		} else {
			gl = win.gl;
		}

		if (!document.body.contains(gl.canvas)) {
			document.body.append(gl.canvas);
		}


		modelView = newFloat32Array(16);
		glCache = { attributes: {}, locations: {} };
		programObject3D = createProgramObject(gl, vertexShaderSrc3D, fragmentShaderSrc3D);
		gl.useProgram(programObject3D);
		glCache.locations.uEdge = gl.getUniformLocation(programObject3D, "uEdge");
		glCache.locations.uSampler = gl.getUniformLocation(programObject3D, "uSampler");
		glCache.locations.aShadow = gl.getAttribLocation(programObject3D, "aShadow");

		//Send the block textures to the GPU
		initTextures();

		sideEdgeBuffers = {};
		for (let side in sideEdgeVerts) {
			let edgeBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, edgeBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, sideEdgeVerts[side], gl.STATIC_DRAW);
			sideEdgeBuffers[side] = edgeBuffer;
		}
		texCoordsBuffers = [];
		for (let t in textureCoords) {
			let buff = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buff);
			gl.bufferData(gl.ARRAY_BUFFER, textureCoords[t], gl.STATIC_DRAW);
			texCoordsBuffers.push(buff);
		}

		//Bind the Vertex Array Object (VAO) that will be used to draw everything
		indexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indexOrder, gl.STATIC_DRAW);

		//Tell it not to render the insides of blocks
		gl.enable(gl.CULL_FACE);
		gl.cullFace(gl.BACK);

		gl.disableVertexAttribArray(glCache.locations.aShadow);
		gl.vertexAttrib1f(glCache.locations.aShadow, 1.0);
		gl.lineWidth(2);
		blockOutlines = false;
		gl.enable(gl.POLYGON_OFFSET_FILL);
		gl.polygonOffset(1, 1);
		gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
		gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);

		FOV(60);
		let HALF_PI = Math.PI / 2;
		initModelView(0, 0, 0, -HALF_PI / 6, -HALF_PI / 2.5);

		block2(1, -1, 5, 1);
		block2(2, -1, 5, 1);
		block2(3, -2, 4, 1);
		block2(3, -2, 5, 1);
		block2(2, -2, 4, 1);
		block2(1, -2, 4, 1);
		block2(0, -3, 4, 1);
		block2(1, -3, 4, 2);
		block2(1, -4, 3, 1);
		block2(2, -3, 3, 1);
		block2(3, -2, 3, 1);
		block2(3, -3, 2, 1);
		block2(5, -3, 2, 1);
		block2(4, -4, 1, 1);
		block2(4, -3, 2, 1);
		block2(0, -2, 5, 1);
		block2(4, -2, 3, 1);
		block2(4, -2, 4, 1);
		block2(5, -3, 3, 1);
		//ctx.drawImage(gl.canvas, 0, 0);
		FOV(fov);
	}

	function gameLoop() {
		let frameStart = win.performance.now();
		if (!screen) {
			initEverything();
			releasePointer();
		}

		if(screen.includes("menu")) {
			cursor(CROSS);
			strokeWeight(1);
			ctx.clearRect(0, 0, width, height);
			fill(0, 0, 0);
			textSize(75);
			ctx.textAlign = 'center';
			text("Minecraft", width / 2, 100);

			if(screen === "main menu") {
				fill(0, 0, 0);
				textSize(20);
				ctx.textAlign = 'right';
				text("Version " + version, width - 10, height - 10);
			} /* else if(screen === "load menu") {
        //set a save code with a prompt, bit messy
				var PLOAD = prompt('Enter Save Code:');
        localStorage.setItem('savecode', PLOAD);
        play();
        world.loadSave(loadString);
        localStorage.removeItem('savecode');
        delete PLOAD;
			}*/ else if(screen === "options menu") {
				ctx.beginPath();
				ctx.strokeStyle = "black";
				ctx.fillStyle = "rgb(92, 92, 92)";
				strokeWeight(2);
				ctx.rect(width / 2 - 150, 125, 300, 50);
				ctx.stroke();
				ctx.fill();
				fill(0, 0, 0);
				textSize(30);
				ctx.textAlign = 'center';
				text("Render Distance: " + renderDistance, width / 2, 160);
				strokeWeight(7);
				stroke(255, 255, 255);
				ctx.beginPath();
				line(10, 150, 40, 150);
				line(width - 10, 150, width - 40, 150);
				line(width - 25, 135, width - 25, 165);
				ctx.stroke();
				ctx.beginPath();
			}
		} else if(screen === "play") {
			controls();
			runGravity();
			resolveContactsAndUpdatePosition();
			
			if (updateHUD) {
				ctx.clearRect(0, 0, canvas.width, canvas.height);
				gl.clearColor(0.0, 0.0, 0.0, 0.0);
				gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
				hotbar();
				hud();
				ctx.drawImage(gl.canvas, 0, 0);
				updateHUD = false;
				freezeFrame = false;

				gl.clearColor(84 / 255, 138 / 255, 184 / 255, 1.0);
			}
			gl.clear(gl.DEPTH_BUFFER_BIT | gl.COLOR_BUFFER_BIT);
			defineWorld(); // Load, draw, and update the world
			gl.flush();
			gl.finish();
		} else if (screen === "inventory") {
			drawInv();
		} else if(screen.includes("pause")) {
			cursor(CROSS);
			strokeWeight(1);
			ctx.clearRect(0, 0, canvas.width, canvas.height);
			ctx.drawImage(gl.canvas, 0, 0);

			// fill(0, 0, 0, 100);
			// rect(-2, -2, width + 4, height + 4);

			textSize(60);
			fill(0, 0, 0);
			ctx.textAlign = 'center';
			text("Paused", width / 2, 60);
			if(screen === "pause options") {
				ctx.beginPath();
				ctx.strokeStyle = "black";
				ctx.fillStyle = "rgb(92, 92, 92)";
				strokeWeight(2);
				ctx.rect(width / 2 - 150, 125, 300, 50);
				ctx.stroke();
				ctx.fill();
				fill(0, 0, 0);
				textSize(30);
				text("Render Distance: " + renderDistance, width / 2, 160);
				strokeWeight(7);
				stroke(255, 255, 255);
				ctx.beginPath();
				line(10, 150, 40, 150);
				line(width - 10, 150, width - 40, 150);
				line(width - 25, 135, width - 25, 165);
				ctx.stroke();
				ctx.beginPath();
			}
		}
		buttons.forEach(drawButton);

		if (Date.now() - analytics.lastUpdate > 500 && analytics.frames) {
			analytics.displayedTickTime = (analytics.totalTickTime / analytics.frames).toFixed(1);
			analytics.displayedRenderTime = (analytics.totalRenderTime / analytics.frames).toFixed(1);
			analytics.displayedFrameTime = (analytics.totalFrameTime / analytics.frames).toFixed(1);
			analytics.fps = Math.round(analytics.frames * 1000 / (Date.now() - analytics.lastUpdate));
			analytics.displayedwFrameTime = analytics.worstFrameTime.toFixed(1);
			analytics.frames = 0;
			analytics.totalRenderTime = 0;
			analytics.totalTickTime = 0;
			analytics.totalFrameTime = 0;
			analytics.worstFrameTime = 0;
			analytics.lastUpdate = Date.now();
			updateHUD = true;
		}

		analytics.frames++;
		analytics.totalFrameTime += win.performance.now() - frameStart;
		analytics.worstFrameTime = Math.max(win.performance.now() - frameStart, analytics.worstFrameTime);
		win.raf = requestAnimationFrame(gameLoop);
	}
	return gameLoop;
})();
if (window.parent.raf) {
	window.cancelAnimationFrame(window.parent.raf);
	console.log("Canceled", window.parent.raf)
}
init();


	</script>
	</body>
</html>
